LE
LANGAGE
Java
Petit
mémento
de
syntaxe
&
éléments
de
programmation
SITES
de
REFERENCE
Le
site
officiel
de
Java
est
:
java.sun.com
.

On
peut
notamment
y
consulter
avec
intérêt
:
-
des
tutoriels
:
java.sun.com/docs/books/tutorial/
-
une
grande
collection
de
petits
exemples
de
programmes
:
java.sun.com/developer/codesamples/examplets/
-
du
recommandations
de
style
:
java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html
-
le
descriptif
de
tous
les
paquetages
,
classes
et
méthodes
standard
:
java.sun.com/javase/6/docs/api/
-
le
mode
de
emploi
du
générateur
de
documentation
javadoc
:
java.sun.com/j2se/javadoc/index.jsp
-
une
préparation
à
la
certification
de
programmeur
Java
:
java.sun.com/docs/books/tutorial/extra/certification/
SOMMAIRE
1
LANGAGE
ET
PROGRAMMATION
ORIENTÉS
OBJETS
...
7
2
PROGRAMME
Java
...
...
.

8
2.1
Style
de
programmation
8
2.2
Identificateurs
...
8
2.3
Commentaires
...
...
8
2.3.1
Commentaires
de
documentation
...
...
8
2.3.2
Commentaires
de
implémentation
...
9
2.4
Fichier
Java
...
9
24.1
Nom
et
contenu
de
un
fichier
java
...
...
9
24.2
Compilation
,
exécution
,
génération
de
la
documentation
10
2.5
Paquetages
...
10
2.5.1
Paquetages
standard
...
...
10
2.5.2
Affectation
de
une
classe
à
un
paquetage
...
...
10
2.5.3
Importation
de
une
classe
de
un
paquetages
11
3
CLASSES
ET
INTERFACES
...
...
12
3.1
Classes
standard
...
...
12
3.2
Classes
abstraites
et
sous-classes
...
13
3.2.1
Classes
abstraites
.

13
3.2.2
Sous-classe
...
14
3.3
Interfaces
...
...
15
3.3.1
Interface
...
16
3.3.2
Classe
implantant
une
interface
...
16
3.4
Enumération
...
...
...
...
...
...
16
3.5
Classes
imbriquées
(
Nested
classes
)
...
17
3.6
Contrôle
de
accès
par
les
modificateurs
...
18
4
INSTANCE
de
CLASSE
...
...
20
5
TYPES
de
DONNEES
...
.

21
5.1
Types
primitifs
...
21
5.2
Types
objet
(
ou
types
référence
)
.

..22
5.2.1
Classes
enveloppes
...
.
.
22
5.2.2
Chaîne
de
caractères
non
modifiable
(
String
)
...
23
5.2.3
Chaîne
de
caractères
modifiable
(
StringBuffer
)
...
...
...
...
...
...
...
...
.
.
23
5.2.4
Tableau
...
...
23
5.2.5
Collection
...
...
25
5.3
Transtypage
...
...
27
6
OPERATEURS
ET
EXPRESSIONS
...
...
29
6.1
Opérateurs
et
expressions
arithmétiques
...
29
6.2
Opérateurs
et
expressions
booléennes
...
30
6.3
Opérateurs
relationnels
...
30
7
METHODES
...
31
7.1
Définition
et
appel
de
une
méthode
ordinaire
...
31
7.2
Constructeur
...
...
32
7.3
Méthode
main
...
...
...
...
...
.

33
8
INSTRUCTIONS
...
...
34
8.1
Instruction
de
affectation
...
...
34
8.2
Instructions
de
contrôle
...
34
8.2.1
Instructions
de
sélection
...
...
34
8.2.2
Instructions
de
boucle
...
...
36
8.3
Instructions
de
entrée
/
sortie
...
38
8.3.1
Notion
de
flux
...
38
8.3.2
Entrée
/
sortie
terminal
...
...
38
8.3.3
Entrée
/
sortie
fichier
...
...
39
8.3.4
Lecture
de
une
chaîne
de
caractères
formatée
...
40
9
HERITAGE
...
...
.

42
9.1
Notion
de
héritage
...
42
9.2
Qu'
hérite
une
sous-classe
?

...
...
43
9.3
Redéfinir
une
méthode
...
43
9.4
Type
statique
/
dynamique
-
Liaison
statique
/
dynamique
...
46
9.4.1
Type
statique
/
dynamique
-
Transtypage
...
...
...
...
...
...
...
46
9.4.2
Liaison
statique
/
dynamique
...
47
9.5
Polymorphisme
...
...
48
9.6
Classes
et
méthodes
particulières
...
49
9.7
Interfaces
...
...
49
10
EXCEPTIONS
...
...
50
10.1
Exceptions
contrôlées
et
non
contrôlées
...
50
10.2
Classes
de
exception
standard
...
...
51
10.2.1
La
hiérarchie
Error
...
...
...
51
10.2.2
La
hiérarchie
Exception
...
51
10.23
La
hiérarchie
RuntimeException
...
...
...
.

...
51
10.3
Lancement
de
une
exception
...
...
51
10.4
Capture
de
une
exception
...
...
...
52
10.4.1
Clause
throws
...
52
10.4.2
Instruction
try
.
.
catch
...
...
...
...
.
.
iii
52
10.5
Définir
une
nouvelle
classe
de
exception
...
54
11
ANNEXE
1
-
PROGRAMMATION
GRAPHIQUE
...
55
111
SWING
.
.
...
...
55
11.2
Conteneurs
et
composants
...
...
56
11.3
Gestion
de
la
mise
en
page
...
...
57
11.4
Gestion
du
événements
...
58
11.4.1
Notion
de
événement
...
58
11.4.2
Réaliser
un
gestionnaire
de
événement
...
...
...
...
...
59
11.5
Affichage
/
fermeture
de
une
fenêtre
graphique
...
60
11.6
Architecture
du
composants
Swing
...
...
60
11.7
Applets
...
...
61
12
ANNEXE
2
-
THREADS
...
...
63
12.1
Créer
un
thread
par
extension
de
la
classe
Thread
...
63
12.2
Créer
un
thread
par
implémentation
de
l'
interface
Runnable
...
...
...
...
...
...
...
.
.
64
12.3
Synchronisation
et
communication
entre
threads
...
64
12.3.1
Sections
critiques
et
synchronisation
...
64
12.3.2
Communication
entre
threads
...
...
64
13
ANNEXE
3
-
CONCEPTION
ET
DEVELOPPEMENT
EN
Java
...
66
13.1
Conseils
généraux
pour
une
bonne
conception
du
classes
...
66
13.2
Architecture
de
une
application
interactive
:
le
modèle
MVC
...
67
13.3
Tests
unitaires
...
...
70
13.3.1
Définitions
...
70
13.32
JUnit
...
...
...
.

71
13.4
Java
Beans
...
...
72
13.5
Design
patterns
...
...
74
13.5.1
Exemple
:
le
modèle
Singleton
...
...
75
13.5.2
Exemple
:
le
modèle
Decorator
...
...
...
...
...
.
.
...
75
14
ANNEXE
4
-
MACHINE
VIRTUELLE
Java
(
Jvm
)
...
77
15
ANNEXE
5
-
COMMUNICATION
ENTRE
Java
ET
C
(
JNI
)
...
...
...
...
...
...
79
15.1
Appel
de
une
procédure
C
...
80
15.1.1
Déclaration
et
appel
java
.

...
80
15.1.2
Prototype
C
...
81
15.1.3
Implémentation
C
...
...
81
15.2
Echange
de
données
entre
Java
et
C
...
82
15.2.1
Déclaration
et
appel
java
...
...
82
15.2.2
Prototype
C
...
83
15.2.3
Implémentation
C
...
...
83
16
ANNEXE
6
-
PLATES-FORMES
Java
...
...
84
17
ANNEXE
7
-
GLOSSAIRE
...
...
85
1
LANGAGE
ET
PROGRAMMATION
ORIENTÉS
OBJETS
Java
[
1
]
est
un
langage
de
programmation
orienté
objets
.

Un
objet
est
une
représentation
simplifiée
de
une
entité
du
monde
réel
:
entité
concrète
(
ex
:
ma
voiture
)
ou
non
(
ex
:
la
date
de
aujourd'hui
)
.

Un
objet
se
caractérise
par
son
état
et
son
comportement
.

Un
objet
stocke
son
état
dans
des
variables
appelées
champs
(
ou
attributs
)
et
présente
son
comportement
au
travers
de
fonctionnalités
appelées
méthodes
.

Exemple
de
objet
:
maVoiture
=
à
valeur
du
attributs
:
Fiat
,
grise
,
6
/100km
,
...
.
;
méthodes
:
démarrer
,
arrêter
,
accélérer
,
...
.
}
Typiquement
,
l'
état
est
encapsulé
au
coeur
de
l'
objet
et
n'
est
accessible
depuis
l'
extérieur
de
l'
objet
,
en
consultation
ou
modification
,
que
via
les
méthodes
offertes
par
cet
objet
.

Exemple
:
l'
objet
maVoiture
getCouleur
setCouleur
démarrer
arrêter
accélérer
...
Fiat
grise
6
On
interagit
avec
un
objet
en
lui
envoyant
un
message
de
demande
de
activation
de
une
de
ses
méthodes
.

Exemple
de
envoi
de
un
message
à
un
objet
:
maVoiture.accélérer(
)
;
Une
méthode
particulière
,
appelée
constructeur
,
permet
de
initialiser
l'
état
de
l'
objet
à
sa
création
.

Une
classe
sert
à
regrouper
sous
une
même
catégorie
et
un
même
nom
générique
les
objets
partageant
le
même
type
de
état
et
le
même
comportement
.

Une
classe
est
donc
un
type
de
objet
;
on
dit
réciproquement
que
un
objet
est
une
instance
de
classe
.

Exemple
de
classe
:
Automobile
=
{
attributs
:
marque
,
couleur
,
consommation
,
...
.
;
méthodes
:
démarrer
,
arrêter
,
accélérer
,
...
.
}
Les
classes
peuvent
être
organisées
en
hiérarchies
.

Chaque
classe
hérite
alors
des
attributs
et
méthodes
du
classes
situées
sur
sa
ligne
hiérarchique
ascendante
.

Réaliser
un
programme
dans
un
langage
orienté
objets
,
c'
est
:
-
modéliser
par
des
classes
les
objets
que
l'
on
a
à
manipuler
-
écrire
ces
classes
dans
le
langage
de
programmation
orienté
objets
-
créer
des
objets
instances
de
ces
classes
-
communiquer
avec
ces
objets
en
invoquant
leurs
méthodes
.

[
1
]
Java
est
né
en
1995
dans
l'
entreprise
californienne
Sun
Microsystems
.

Il
a
été
conçu
par
James
GOSLING
&
al
.

2
PROGRAMME
Java
2.1
Style
de
programmation
Il
est
largement
admis
que
le
respect
de
la
syntaxe
et
un
programme
qui
fonctionne
ne
sont
pas
des
critères
de
qualité
suffisants
pour
un
programme
.

L'
expérience
de
la
programmation
a
ainsi
conduit
à
établir
des
recommandations
de
style
.

Les
respecter
n'
est
pas
techniquement
obligatoire
mais
contribue
à
améliorer
la
lisibilité
du
programmes
.

Ces
conventions
visent
en
fait
une
finalité
économique
:
contribuer
à
produire
des
programmes
plus
facilement
maintenables
pendant
toute
leur
durée
de
vie
.

Dans
les
chapitres
suivants
,
les
exemples
respectent
les
conventions
de
style
préconisées
par
java.sun.com
2.2
Identificateurs
Quelques
règles
et
recommandations
pour
nommer
les
identificateurs
:
p
Le
caractère
minuscule-majuscule
du
caractères
est
discriminant
(
règle
du
langage
Java
)
p
Les
identificateurs
de
objets
,
de
champs
et
de
méthodes
commencent
toujours
par
une
minuscule
(
par
convention
)
p
Les
identificateurs
de
classe
(
et
de
interface
)
commencent
toujours
par
une
majuscule
(
par
convention
)
p
Les
identificateurs
de
constantes
sont
tout
en
majuscules
(
par
convention
)
p
Les
identificateurs
de
méthode
commencent
par
un
verbe
(
recommandation
)
2.3
Commentaires
2.3.1
Commentaires
de
documentation
Les
commentaires
de
documentation
visent
à
décrire
la
spécification
du
code
,
sans
considération
de
implémentation
.

Ils
sont
destinés
à
des
développeurs
et
utilisateurs
qui
n'
auraient
pas
nécessairement
les
codes
sources
sous
la
main
.

Ces
commentaires
peuvent
être
automatiquement
extraits
par
l'
utilitaire
javadoc
pour
en
constituer
un
fichier
de
documentation
en
HTML
.

La
documentation
de
une
classe
devrait
inclure
a
minima
:
-
le
nom
de
la
classe
,
sa
fonctionnalité
et
ses
grandes
caractéristiques
,
son
auteur
,
sa
version
-
une
documentation
pour
chaque
constructeur
et
chaque
méthode
La
documentation
de
une
méthode
devrait
inclure
a
minima
:
-
le
nom
de
la
méthode
,
sa
fonctionnalité
,
une
description
de
chaque
paramètre
et
de
la
valeur
retournée
,
les
exceptions
susceptibles
de
être
lancées
par
cette
méthode
Syntaxe
:
/**
*
commentaires
*/
/**
commentaire
*/
Principales
balises
de
commentaires
prédéfinies
:
@author
@version
@param
@return
@see
@throws
2.3.2
Commentaires
de
implémentation
Les
commentaires
de
implémentation
visent
à
expliciter
(
sans
paraphraser
)
le
code
et
les
choix
de
implémentation
.

Le
choix
du
identificateurs
et
la
clarté
de
la
programmation
devrait
permettre
de
minimiser
le
nombre
de
tels
commentaires
.

Syntaxe
:
/*
*
commentaires
*/
/*
commentaire
*/
//
commentaire
2.4
Fichier
Java
2.4.1
Nom
et
contenu
de
un
fichier
java
p
Chaque
fichier
source
java
contient
une
seule
classe
publique
.

L'
organisation
recommandée
est
la
suivante
:
1
)
Les
commentaires
de
début
.

C'
est
un
commentaire
de
documentation
comprenant
typiquement
:
l'
intitulé
de
la
classe
et
un
descriptif
sommaire
de
sa
fonction
,
l'
auteur
,
la
version
2
)
Les
instructions
de
paquetage
3
)
Les
instructions
de
import
4
)
Les
déclarations
du
classes
p
Un
fichier
devrait
contenir
moins
de
2000
lignes
et
des
lignes
de
moins
de
80
caractères
,
voire
70
pour
les
commentaires
de
documentation
(
recommandation
)
p
Un
fichier
Java
porte
le
nom
de
la
classe
publique
qu'
il
contient
;
les
fichiers
source
Java
ont
pour
suffixe
.java
;
les
fichiers
Java
compilés
ont
pour
suffixe
.class
(
par
convention
)
.

Les
suffixe
ajava
et
.class
sont
imposés
par
les
outils
.

2.4.2
Compilation
,
exécution
,
génération
de
la
documentation
depuis
la
ligne
de
commande
:
p
Compilation
:
javac
fileName.java
p
Exécution
:
java
fileName
//
fichier
du
main
p
Génération
de
la
documentation
:
javadoc
*
.

java
Pour
avoir
une
documentation
"
programmeur
"
complète
(
y
compris
les
membres
privés
)
de
toutes
les
classes
et
de
leur
interaction
,
il
faut
lancer
cette
commande
avec
l'
option
-
private
.

2.5
Paquetages
Un
paquetage
(
package
en
anglais
)
est
une
bibliothèque
de
classes
organisées
de
façon
hiérarchique
.

Le
nom
de
un
paquetage
est
nécessairement
le
nom
de
son
répertoire
.

Le
nom
de
un
paquetage
est
toujours
en
lettres
minuscules
(
par
convention
)
.

Différents
paquetages
peuvent
être
rassemblés
et
compactés
dans
un
fichier
de
archive
.zip
ou
.jar
2.5.1
Paquetages
standard
La
variable
de
environnement
CLASSPATH
indique
à
la
machine
virtuelle
Java
où
trouver
les
classes
et
bibliothèques
de
classes
dont
elle
a
besoin
.

Hiérarchie
partielle
du
paquetages
standard
:
java
applet
awt
io
lang
util
event
Paquetages
les
plus
immédiatement
utiles
Paquetage
Contenu
java.io
Classes
relatives
au
entrées/sorties
java.lang
Classes
fondamentales
:
types
basiques
(
classes
enveloppes
,
String
,
StringBuffer
,
...
...
)
,
classe
Math
,
...
java.util
Classes
utilitaires
diverses
:
collections
(
ArrayList
,
Vector
,
...
)
,
classe
Random
,
gestion
du
dates
et
du
heures
,
...
2.5.2
Affectation
de
une
classe
à
un
paquetage
Pour
que
une
classe
appartienne
à
un
paquetage
,
il
faut
déclarer
le
paquetage
de
appartenance
en
tête
de
fichier
source
.

Syntaxe
:
package
packageName
;
2.5.3
Importation
de
une
classe
de
un
paquetage
Pour
utiliser
une
classe
définie
dans
un
paquetage
autre
que
celui
de
la
classe
de
utilisation
,
cette
classe
doit
être
importée
en
tête
de
fichier
source
.

Syntaxe
:
import
packageName.CTassName
;
import
packageName.*
;
//
forme
déconseillée
car
peu
informative
Exemples
:
import
java.util.ArrayList
;
import
java.util.lterator
;
import
java.io.*
;
//
forme
déconseillée
car
peu
informative
Le
paquetage
java.lang
est
importé
automatiquement
.

3
CLASSES
et
INTERFACES
3.1
Classes
standard
Syntaxe
:
public
class
ClassName
à
Fields
Constructors
Methods
//
accessor
methods
...
//
mutator
methods
...
à
Exemple
:
/**
*
Class
RationalNumber
-
Represents
a
rational
number
num
/
den
*
*
@author
Am
*
@version
1.0
*
*/
public
class
RationalNumber
à
//
FIELDS
private
int
numerator
;
private
int
denominator
;
private
boolean
reduced
;
//
CONSTRUCTORS
éùà
Construct
a
rational
number
initialized
to
0/1
*/
public
RationalNumber(
)
{
numerator
=
0
;
denominator
=
1
;
reduced
à
true
;
}
//
METHODS
-
ACCESSORS
éùà
Get
the
numerator
of
this
rational
number
*/
public
int
getNumerator(
)
à
return
numerator
;
}
éùà
Get
the
denominator
of
this
rational
number
*/
public
int
getDenominator(
)
à
return
denominator
;
}
éùà
Return
true
iff
the
numerator/denominator
form
is
irreducible
*/
public
boolean
isReduced(
)
à
return
reduced
;
}
//
METHODS
-
MUTATORS
éùà
Set
this
rational
number
to
_numerator/_denominator
*/
public
void
setNumber(int
_numerator
,
int
_denominator
)
à
numerator
=
_numerator
;
denominator
=
_denominator
;
reduced
=
false
;
à
/**
Set
this
rational
number
to
a
irreducible
*
numerator/denominator
form
*/
public
void
reduce(
)
à
int
divisor
=
greatestCommonDivisor(numerator
,
denominator
j
)
;
numerator
=
numerator
/
divisor
;
denominator
à
denominator
/
divisor
;
reduced
=
true
;
}
//
METHODS
-
UTILITIES
éùà
Return
the
greatest
common
divisor
of
the
two
integers
*
x
and
y
*/
private
int
greatestCommonDivisor(int
x
,
int
y
)
à
int
divisor
;
//
...
à
implémenter
...
return
divisor
;
à
}
//
end
class
RationalNumber
3.2
Classes
abstraites
et
sous-classes
Une
classe
qui
possède
au
moins
une
méthode
abstraite
(
i.e.
sans
corps
)
est
abstraite
et
doit
être
déclarée
avec
le
modificateur
abstract
.

Les
classes
abstraites
ne
peuvent
pas
être
instanciées
.

Pour
pouvoir
créer
des
objets
,
il
faut
créer
une
sous-classe
dans
laquelle
toutes
les
méthodes
abstraites
seront
définies
:
cette
sous-
classe
,
non
abstraite
,
pourra
alors
être
instanciée
.

3.2.1
Classes
abstraites
Syntaxe
:
public
abstract
class
ClassName
à
Fields
Constructors
Methods
à
Exemple
:
/**
*
Abstract
Class
Progression
*
*
Represents
a
real
linear
progression
of
order
1
with
constant
*
coefficients
*
*
@author
Am
*
@version
1.0
*/
public
abstract
class
Progression
à
//
FIELDS
private
double
u0
;
//
the
first
term
of
the
progression
//
CONSTRUCTORS
éùà
Define
a
progression
,
the
first
term
of
which
is
u0
*/
public
Progression(double
u0
)
{
this.u0
=
u0
;
}
//
METHODS
éùà
Get
the
first
term
of
this
progression
*/
public
double
getu0()
à
return
u0
;
}
/**
Given
à
current
term
u(n)
,
return
the
next
term
u(n+1)
*/
public
abstract
double
nextTerm(double
un
)
;
éùà
Return
the
term
of
rank
n
*/
public
double
termOfRank(int
n
)
{
double
u
=
u0
;
//
u(n)
double
v
;
//
u(n+1)
for(int
i
à
1
;
i
çù
n
;
iuu
)
{
v
=
nextTerm(u)
;
u
=
v
;
à
return
u
;
}
}
//
end
class
Progression
3.2.2
Sous-classe
Syntaxe
:
public
class
SubclassName
extends
SuperclassName
à
Fields
Constructors
Methods
à
Exemple
:
éùà
*
Class
ArithGeomProgression
*
*
Represents
a
real
arithmetic-geometric
progression
with
constant
*
coefficients
:
u(n+1)
=
a*u(n)
p
b
*
*
@author
Am
*
@version
1.0
*/
public
class
ArithGeomProgression
extends
Progression
à
//
FIELDS
private
double
a
;
//
multiplying
coefficient
private
double
b
;
//
additive
coefficient
//
CONSTRUCTORS
éùà
Define
an
arithmetic-geometric
progression
*
@param
u0O
first
term
of
the
progression
*
@param
a
multiplying
coefficient
*
@param
b
additive
coefficient
*/
public
ArithGeomProgression
(
double
u0
,
double
a
,
double
b
)
à
super
(
u0
)
;
this.a
=
a
;
this.b
=
b
;
}
//
METHODS
/**
Given
à
current
term
u(n)
,
return
the
next
term
u(n+1)
*/
public
double
nextTerm(double
u
)
à
return
açu
p
b
;
}
}
//
end
class
ArithGeomProgression
3.3
Interfaces
Remarque
liminaire
.

Le
terme
"
interface
"
a
une
sémantique
multiple
.

Dans
le
cadre
de
la
programmation
en
Java
,
il
peut
prendre
,
selon
le
contexte
,
trois
sens
distincts
(
même
si
conceptuellement
apparentés
)
:
-
au
sens
informatique
commun
:
une
interface
est
une
"
jonction
entre
deux
éléments
(
matériels
ou
logiciels
)
permettant
l'
échange
de
information
"
;
par
exemple
,
l'
interface
homme-machine
.

-
au
sens
programmation
objet
:
l'
interface
de
une
classe
est
la
partie
visible
publique
de
cette
classe
;
elle
se
définit
typiquement
par
la
liste
du
membres
(
attributs
,
constructeurs
,
méthodes
)
non
privés
associés
à
leurs
commentaires
de
documentation
-
au
sens
spécifique
du
Langage
Java
:
une
interface
est
une
sorte
de
classe
abstraite
possédant
des
caractéristiques
particulières
et
qui
définit
un
protocole
de
comportement
;
c'
est
le
sens
qui
est
défini
dans
cette
section
.

C'
est
son
contexte
de
utilisation
qui
donne
sens
au
mot
interface
.

Les
interfaces
(
au
sens
du
Langage
Java
)
sont
des
sortes
de
classes
abstraites
sans
aucun
détail
de
implémentation
et
qui
possèdent
un
degré
de
abstraction
supérieur
à
celui
du
classes
abstraites
.

Les
interfaces
:
-
ont
des
méthodes
qui
sont
toutes
implicitement
abstraites
(
elles
n'
ont
pas
de
corps
)
-
à
noter
que
il
n'
est
pas
recommandé
de
ajouter
le
modificateur
abstract
puisque
il
est
implicite
;
-
ne
possèdent
pas
de
champs
,
à
l'
exception
éventuelle
de
constantes
de
classe
(
implicitement
static
final
)
assignées
;
-
ses
membres
sont
implicitement
publics
si
l'
interface
est
publique
.

Une
interface
spécifie
la
signature
minimale
de
une
classe
qui
l'
implémente
.

Une
interface
est
donc
un
contrat
à
respecter
.

Quand
une
classe
implémente
une
interface
,
elle
s'
engage
à
se
conformer
à
cette
interface
.

Une
classe
peut
implémenter
plusieurs
interfaces
.

Une
classe
définit
un
type
et
son
implémentation
;
une
interface
définit
un
type
sans
son
implémentation
.

3.3.1
Interface
Syntaxe
:
public
interface
InterfaceName
{
constantAttributes
abstractMethods
à
Exemple
:
public
interface
Measurable
{
double
sizeëë
;
éùà
@return
-1
,
0
,
1
if
this
is
<
,
=
or
à
than
x
*/
int
isLargerThan(Measurable
x
)
;
}
3.3.2
Classe
implantant
une
interface
Syntaxe
:
public
class
ClassName
implements
InterfaceNamel
,
InterfaceName2
,
...
{
...
}
Exemple
:
public
class
Square
implements
Measurable
à
private
double
width
;
public
Square(double
_width
)
{
width
=
_width
;
}
public
double
sizeëë
à
return
width*width
;
}
public
int
isLargerThan(Measurable
x
)
{
if
(
this.size()
<
x
à
return
-1
;
}
if
(
this.size()
>
x
à
return
1
;
à
return
0
;
}
}
3.4
Enumération
Une
classe
enum
permet
de
représenter
un
ensemble
de
constantes
nommées
dont
le
type
est
la
classe
elle-même
.

Ces
classes
contribuent
à
accroître
la
lisibilité
du
programmes
.

Syntaxe
:
public
enum
EnumName
à
//
List
of
named
constants
.

//
Possibility
of
other
fields
and
methods
.

à
Exemple
:
public
enum
Direction
à
NORTH
,
SOUTH
,
EAST
,
WEST
;
}
public
class
Test
à
private
Direction
dir
;
public
setDir(Direction
duà
dir
=
d
;
}
public
boolean
isNorthSouth()
à
return
(
dir
çù
Direction.NORTH
)
||
(
dir
çù
Direction.SOUTH
)
;
}
}
sous
leur
forme
la
plus
simple
,
les
classes
enum
sont
souvent
utilisées
sous
la
forme
de
une
classe
interne
(
inner
class
)
.

Exemple
:
public
class
MyClass
à
private
Direction
dir
;
...
private
enum
Direction
à
NORTH
,
SOUTH
,
EAST
,
WEST
;
}
public
void
setNorth()
à
dir
=
Direction.NORTH
;
}
...
}
-
il
est
possible
de
associer
à
chaque
constante
énumérée
une
valeur
de
un
type
quelconque
-
il
est
possible
de
utiliser
un
type
énuméré
dans
une
instruction
switch
3.5
Classes
imbriquées
(
Nested
classes
)
Ce
concept
n'
est
pas
vital
pour
un
débutant
.

Une
classe
peut
être
définie
à
l'
intérieur
de
une
autre
classe
.

On
parle
alors
de
classe
imbriquée
.

On
en
distingue
quatre
catégories
:
-
les
classes
membres
déclarées
static
(
static
nested
classes
)
:
membres
statiques
de
la
classe
englobante
;
-
les
classes
internes
(
inner
classes
)
:
membres
non
statiques
de
la
classe
englobante
;
-
les
classes
locales
(
local
classes
)
:
classes
définies
à
l'
intérieur
de
une
méthode
;
-
les
classes
anonymes
(
anonymous
classes
)
:
classes
locales
sans
nom
.

Exemple
:
public
class
OuterClass
{
...
public
static
class
StaticNestedClass
{
...
à
private
class
InnerClass
{
...
}
}
//
Exemple
de
référence
à
la
classe
StaticNestedClass
:
//
OuterClass.StaticNestedClass
Quel
intérêt
peut
-il
y
avoir
à
déclarer
des
classes
imbriquées
?

Potentiellement
un
regroupement
logique
,
une
encapsulation
accrue
,
un
code
plus
lisible
et
plus
facilement
maintenable
.

En
pratique
,
la
plupart
du
classes
imbriquées
sont
des
classes
internes
.

Quant
au
classes
anonymes
,
elles
peuvent
rendre
le
code
difficile
à
lire
et
doivent
donc
être
limitées
à
des
classes
très
petites
(
de
une
ou
deux
méthodes
)
:
voir
exemple
typique
en
section
11.4.2
.

3.6
Contrôle
de
accès
par
les
modificateurs
Le
contrôle
de
accès
à
un
membre
de
une
classe
peut
être
précisé
dans
leur
déclaration
par
des
mots-clés
appelés
modificateurs
.

Ces
modificateurs
permettent
de
spécifier
:
-
la
visibilité
du
champ
ou
de
la
méthode
:
private
,
protected
ou
public
-
le
lieu
de
stockage
:
dans
la
classe
(
modificateur
static
)
ou
dans
l'
objet
(
par
défaut
)
-
le
caractère
modifiable
(
par
défaut
)
ou
non
(
modificateur
final
)
Modificateur*
Commentaires
et
exemple
private
Un
membre
déclaré
private
n'
est
accessible
que
à
l'
intérieur
de
sa
classe
de
définition
.

Modificateur
de
accès
recommandé
pour
les
champs
.

protected
Un
membre
déclaré
protected
n'
est
accessible
que
depuis
sa
classe
de
déclaration
,
une
sous-classe
,
ou
une
classe
du
même
paquetage
.

Modificateur
de
accès
recommandé
pour
les
méthodes
du
super-
classes
.

public
Un
membre
déclaré
public
est
accessible
depuis
n'
importe
quelle
classe
.

Modificateur
de
accès
recommandé
pour
les
méthodes
static
Un
champ
déclaré
static
est
une
variable
de
classe
et
n'
est
pas
dupliqué
dans
les
différentes
instances
;
un
champ
non
static
est
une
variable
de
instance
et
est
dupliqué
dans
chaque
instance
.

Une
méthode
déclarée
static
est
une
méthode
de
classe
et
est
invoquée
sans
référence
à
un
objet
particulier
mais
en
faisant
référence
à
sa
classe
;
une
méthode
non
static
est
une
méthode
de
instance
et
est
invoquée
sur
un
objet
particulier
Voir
également
chapitre
14
.

final
Une
variable
déclarée
final
ne
peut
plus
être
modifiée
après
que
elle
a
été
initialisée
.

Cela
permet
en
particulier
de
déclarer
des
champs
constants
.

Exemple
:
final
int
Size
=
10
;
Une
méthode
déclarée
final
ne
peut
pas
être
redéfinie
dans
une
sous-classe
.

Une
classe
déclarée
final
ne
peut
pas
être
sous-classée
.

*
Nota
:
à
défaut
de
modificateur
private
,
protected
ou
public
,
la
visibilité
est
dite
"
package
access
"
:
le
membre
de
la
classe
est
visible
depuis
toutes
les
classes
du
même
paquetage
.

Exemple
:
public
static
final
double
GRAVITY
=
9.81
;
4
INSTANCE
de
CLASSE
Avant
de
pouvoir
être
utilisé
,
un
objet
-
ou
instance
de
classe
-
doit
être
:
1
)
déclaré
ClassName
objectName
;
2
)
créé
pui
initialisé
objectName
=
new
constructorCall
;
Exemples
:
GregorianCalendar
cal
;
cal
=
GregorianCalendar()
;
Timer
myTimer
=
new
Timer(
)
;
La
déclaration
de
un
objet
ne
crée
pas
l'
objet
mais
uniquement
une
variable
pointeur
destinée
à
mémoriser
l'
adresse
future
de
l'
objet
!

La
création
de
l'
objet
en
lui-même
(
i.e.
l'
instance
proprement
dite
)
est
réalisée
par
l'
opérateur
new
.

L'
appel
au
constructeur
qui
suit
l'
opérateur
new
a
pour
rôle
de
initialiser
proprement
l'
objet
ainsi
créé
.

In
fine
,
l'
adresse
de
l'
objet
ainsi
créé
et
initialisé
,
adresse
renvoyée
par
l'
opérateur
new
,
est
stockée
,
grâce
à
l'
opérateur
de
affectation
=
,
dans
la
variable
préalablement
déclarée
.

Quelques
précisions
importantes
:
*
Déclaration
.

La
déclaration
ClassName
objectName
;
crée
une
variable
de
nom
objectName
de
type
référence
(
i.e.
un
pointeur
)
et
l'
initialise
automatiquement
à
null
.

null
est
une
constante
littérale
prédéfinie
de
Java
qui
peut
être
assignée
à
toute
variable
de
type
référence
et
qui
identifie
un
pointeur
nul
.

Une
variable
de
valeur
null
ne
pointe
vers
aucun
objet
.

Toute
tentative
de
référer
à
un
objet
à
partir
de
un
pointeur
null
engendre
une
erreur
(
de
compilation
ou
de
exécution
selon
le
contexte
)
.

*
Gestion
dynamique
de
la
mémoire
.

L'
opérateur
new
crée
l'
instance
de
classe
dans
une
zone
mémoire
générale
appelée
"
tas
"
qui
contient
toutes
les
données
allouées
à
l'
exécution
et
n'
ayant
pas
de
portée
locale
.

L'
objet
ainsi
créé
conserve
donc
une
portée
globale
et
reste
"
vivant
"
tant
que
on
dispose
de
une
référence
(
i.e.
un
pointeur
)
permettant
de
y
accéder
.

Quand
un
objet
n'
est
plus
référencé
,
il
devient
définitivement
inaccessible
et
"
meurt
"
:
son
espace
mémoire
est
automatiquement
désalloué
(
la
récupération
automatique
de
cet
espace
mémoire
est
réalisée
par
un
processus
appelé
ramasse-miettes
(
garbage
collector
)
)
.

Une
façon
de
détruire
un
objet
est
donc
de
assigner
la
valeur
null
au
variables
qui
y
font
référence
directement
ou
indirectement
.

5
TYPES
de
DONNEES
Java
connaît
deux
types
de
données
:
-
Les
types
primitifs
.

Les
données
de
type
primitif
sont
stockées
directement
dans
les
variables
et
ont
une
sémantique
de
valeur
(
i.e.
c'
est
la
valeur
qui
est
copiée
quand
une
variable
est
affectée
à
une
autre
variable
)
.

-
Les
types
objet
(
ou
types
référence
)
.

Les
données
de
type
objet
sont
stockées
sous
forme
de
référence
à
cet
objet
(
et
non
pas
en
tant
que
objet
même
)
.

Quand
une
variable
de
type
objet
est
affectée
à
une
autre
variable
,
seule
la
référence
est
copiée
,
pas
l'
objet
lui-même
.

Java
utilise
le
système
Unicode-4
,
en
interne
,
pour
coder
les
caractères
,
les
chaînes
de
caractères
et
les
identificateurs
.

Chaque
caractère
Unicode
est
codé
sur
16
bits
,
ce
qui
permet
de
représenter
de
nombreux
alphabets
(
grec
,
cyrillique
,
hébreu
,
arabe
,
...
)
ainsi
que
les
symboles
mathématiques
et
techniques
.

Bien
que
Unicode
soit
utilisé
par
certains
systèmes
de
exploitation
(
Windows
NTM
ou
Vista
par
exemple
)
,
la
plupart
du
systèmes
de
exploitation
utilisent
des
systèmes
de
codage
8
bits
,
de
sorte
que
des
transcodages
sont
nécessaires
et
des
problèmes
de
incompatibilité
peuvent
survenir
à
l'
affichage
.

5.1
Types
primitifs
Type
Description
Exemples
de
littéraux
Nombres
entiers
:
Types
signés
:
byte
octet
(
entier
8
bits
)
127
-128
short
entier
court
(
16
bits
)
32767
-32768
int
entier
(
32
bits
)
2147483647
-2147483648
long
entier
long
(
64
bits
)
5123456789L
-55L
Nombres
réels
:
Types
signés
:
float
réel
simple
précision
43.889F
341.159E-2F
double
réel
double
précision
45.63
-2.4E107
Autres
types
:
Types
non
signés
:
char
caractère
(
un
seul
;
16
bits
)
'
?

'
'
\u00F6
'
boolean
valeur
booléenne
false
true
p
Un
nombre
sans
point
décimal
est
interprété
comme
un
entier
de
type
int
mais
immédiatement
converti
en
byte
,
short
ou
long
lors
de
l'
affection
.

On
peut
déclarer
un
littéral
de
type
long
en
l'
affectant
du
suffixe
Lo
p
Un
nombre
avec
un
point
décimal
est
interprété
comme
un
réel
de
type
double
.

On
peut
déclarer
un
littéral
de
type
float
en
l'
affectant
du
suffixe
Fo
p
Un
caractère
littéral
peut
être
écrit
sous
forme
de
un
unique
caractère
Unicode
entre
apostrophes
ou
de
une
valeur
Unicode
précédée
par
'
çu
'
.

p
Les
deux
littéraux
booléens
sont
true
et
false
.

p
Les
variables
de
un
type
primitif
ne
référant
pas
à
des
objets
,
elles
n'
ont
pas
de
méthodes
associées
.

5.2
Types
objet
(
ou
types
référence
)
Tous
les
types
autres
que
les
types
primitifs
sont
des
types
objet
.

Ils
incluent
les
classes
(
non
abstraites
)
du
bibliothèques
standard
Java
(
tels
que
le
type
String
,
par
exemple
)
ainsi
que
les
classes
définies
par
l'
utilisateur
.

Une
variable
de
un
type
objet
contient
une
référence
(
ou
pointeur
)
sur
cet
objet
.

Les
affectations
et
passage
de
paramètres
ont
une
sémantique
de
référence
(
i.e.
c'
est
la
référence
qui
est
copiée
et
non
l'
objet
lui-même
)
.

Après
l'
affectation
de
une
variable
à
une
autre
,
les
deux
variables
réfèrent
au
même
objet
:
il
s'
agit
donc
de
une
copie
de
surface
(
par
opposition
à
une
copie
profonde
qui
dupliquerait
les
objets
)
.

Les
deux
variables
sont
alors
dites
alias
pour
le
même
objet
.

5.2.1
Classes
enveloppes
Les
classes
enveloppes
permettent
de
transformer
un
type
simple
en
objet
(
cette
opération
est
appelée
,
en
anglais
,
boxing
)
.

Classe
enveloppe
Type
primitif
Boolean
boolean
Byte
byte
Character
char
Double
double
Float
float
Integer
int
Long
long
Short
short
Exemples
:
//
convert
primitive
type
à
wrapper
type
Integer
k
=
new
Integer(456)
;
//
convert
wrapper
type
>
primitive
type
double
x
=
K.doubleValue(
)
;
Les
classes
enveloppes
sont
utiles
quand
une
méthode
n'
accepte
pas
les
types
simples
mais
requiert
du
objets
.

Toutefois
,
depuis
la
plate-forme
5.0
(
voir
chapitre
16
)
,
les
valeurs
de
type
primitif
sont
,
en
cas
de
besoin
,
implicitement
converties
en
l'
objet
de
la
classe
enveloppe
correspondante
(
autoboxing
)
,
et
réciproquement
(
unboxing
)
.

Auparavant
,
la
conversion
devait
être
explicite
.

Les
objets
de
telles
classes
sont
immuables
(
immutable
)
,
c'est-à-dire
non
modifiables
une
foi
créés
.

En
conséquence
,
une
méthode
ne
peut
pas
avoir
de
paramètres
de
sortie
de
tels
types
.

Les
classes
enveloppes
présentent
surtout
l'
intérêt
de
offrir
des
méthodes
de
conversion
type
primitif
<->
String
,
ainsi
que
des
utilitaires
pour
des
données
de
type
primitif
.

Exemple
:
//
Convert
String
type
-
primitive
type
double
x
=
Double.parseDouble(
"
3.14159
"
)
;
5.2.2
Chaîne
de
caractères
non
modifiable
(
String
)
Bien
que
les
chaînes
de
caractères
de
type
String
soient
des
objets
,
il
n'
est
pas
nécessaire
de
avoir
recours
à
l'
opérateur
new
pour
les
créer
.

Les
caractères
de
une
chaîne
de
caractères
chaine
sont
indicés
de
0
à
chaine.length()-1
Une
chaîne
de
caractères
littérale
est
notée
entre
apostrophes
.

L'
opérateur
p
est
l'
opérateur
de
concaténation
de
chaînes
.

Il
produit
une
nouvelle
chaîne
sans
éléments
physiquement
partagés
avec
ses
opérandes
.

La
comparaison
de
deux
chaînes
(
caractère
par
caractère
)
nécessite
de
faire
appel
à
la
fonction
equals()
,
l'
opérateur
==
ne
donnant
le
résultat
intuitivement
attendu
que
dans
un
cas
particulier
.

Les
objets
de
type
String
sont
immuables
(
immutable
)
,
c'est-à-dire
non
modifiables
une
foi
créés
.

En
conséquence
,
une
méthode
ne
peut
pas
avoir
de
paramètres
de
sortie
de
type
String
.

La
classe
String
appartient
au
paquetage
java.lang
Exemple
:
String
chaine
=
"
Exemple
n°
"
p
1
p
"
de
chaine
littérale
"
;
System.out.println("Longueur
de
\
"
"
p
chaine
p
"
\
"
=
"
p
chaine.length()
)
;
5.2.3
Chaîne
de
caractères
modifiable
(
StringBuffer
)
Ces
chaînes
de
caractères
,
contrairement
au
chaînes
de
type
String
,
peuvent
être
modifiées
.

L'
opérateur
new
est
indispensable
pour
créer
une
chaîne
de
type
StringBuffer
.

La
classe
StringBuffer
appartient
au
paquetage
java.lang
Exemple
:
StringBuffer
chaine
;
chaine
=
new
StringBuffer
(
"
Meeting
at
6
pm
!

"
)
;
chaine.setCharAt(11
,
'
5
'
)
;
//
meeting
at
5
and
not
6
!

System.out.println(chaine)
;
5.2.4
Tableau
Un
tableau
est
une
collection
de
taille
fixe
de
éléments
de
même
type
.

Chaque
élément
est
repéré
par
son
indice
qui
permet
un
accès
direct
à
l'
élément
.

à
tout
tableau
est
automatiquement
associée
une
classe
dérivée
de
Object
et
partagée
par
tous
les
tableaux
ayant
le
même
type
de
éléments
.

L'
attribut
de
instance
length
(
qui
est
un
champ
public
et
non
une
méthode
)
contient
le
nombre
de
éléments
du
tableau
.

Les
éléments
de
un
tableau
array
sont
indicés
de
0
à
array.length
-
1
Quand
on
tente
de
accéder
à
un
élément
dont
l'
indice
est
hors
de
la
plage
permise
,
une
exception
de
type
IndexOutOfBoundsException
est
levée
.

Il
est
à
noter
que
un
tableau
de
caractères
n'
est
pas
un
objet
de
type
Siring
et
réciproquement
.

Syntaxe
(
pour
le
cas
de
un
tableau
mono-dimensionnel
)
:
//
Declaring
an
array
variable
TypeOfElements[
]
arrayVariable
;
//
Creating
an
array
object
arrayVariable
=
new
TypeOfElements[numberOfElements
]
;
//
Referring
to
an
element
arrayVariable[integerIndex
]
Exemple
:
//
Declaring
an
array
variable
private
double[
]
marks
;
//
Creating
an
array
object
static
final
int
NB_OF_STUDENTS
=
48
;
marks
=
new
double[NB_OF_STUDENTS
]
;
//
Using
an
array
object
for
(
int
1
=
0
;
1
<
marks.length
;
iu
)
{
marks[i
]
=
Math.random()
*
20.0
;
System.out.println("marks[
"
p
1
+
"
]
=
"
p
marks[i
]
)
;
}
Exemple
:
static
final
int
NROW
10
;
static
final
int
NCOL
=
20
;
String[][
]
matrix
=
new
String[NROW][NCOL
]
;
Il
est
possible
de
créer
et
de
initialiser
un
tableau
à
la
déclaration
.

Exemple
:
int[
]
t
=
{
150
,
-300
,
40
,
500
}
;
System.out.println(t[0
]
p
"
"
p
t[3
]
)
;
//
150
500
String[
][
]
s
=
{
{
"
Mr
.

"
,
"
Mrs
.

"
,
"
m
.

"
}
,
//
row
0
{
"
Smith
"
,
"
Jones
"
}
//
row
1
}
;
System.out.print(s[0][2
]
p
s[1][1
]
)
;
//
m
.

Jones
La
classe
java.util.Arrays
offre
diverses
méthodes
utilitaires
applicables
à
des
tableaux
(
comparaison
,
tri
,
...
...
)
.

depuis
la
plate-forme
5.0
(
voir
chapitre
16
)
,
Java
offre
une
boucle
For
simplifiée
pour
parcourir
les
éléments
de
un
tableau
.

Exemple
:
//
for
each
element
of
my
array
of
doubles
,
print
this
element
for
(
double
e
:
myArrayOfDoubles
)
{
System.out.println(e)
;
}
5.2.5
Collection
Une
collection
est
un
objet
représentant
un
groupe
de
objets
.

Une
collection
est
un
agrégat
qui
regroupe
des
éléments
multiples
en
une
seule
entité
.

Aucune
hypothèse
n'
est
faite
a
priori
sur
le
type
du
éléments
,
ni
sur
l'
ordre
du
éléments
,
ni
sur
la
possibilité
de
éléments
dupliqués
.

Plus
formellement
,
en
Java
,
une
collection
de
éléments
de
type
e
est
une
classe
qui
implémente
l'
interface
Collection<E>
.

Le
paquetage
standard
java.util
offre
une
variété
de
collections
(
collections
framework
)
qui
répondent
au
besoins
les
plus
fréquents
,
par
exemple
:
ArrayList<E>
,
Vector<E>
,
LinkedList<E>
,
Stack<E>
,
Hashtable<K,V>
,
...
.

5.2.5.1
Généricité
Cette
notion
n'
existe
en
Java
que
depuis
la
plate-forme
5.0
(
voir
chapitre
16
)
.

Cette
version
5.0
introduit
une
révision
majeure
par
rapport
à
la
précédente
,
notamment
en
matière
de
gestion
du
collections
.

L'
apparition
de
types
génériques
en
est
probablement
l'
évolution
la
plus
marquante
.

La
généricité
permet
de
communiquer
au
compilateur
le
type
du
éléments
de
une
collection
au
moment
de
la
création
de
l'
objet
et
non
pas
en
le
fixant
a
priori
dans
la
définition
de
classe
.

Exemple
de
classe
générique
:
//
Defining
a
generic
collection
.

//
The
formal
parameter
T
is
the
generic
type
of
the
elements
.

public
class
MyCollection<T>
implements
List<T>
{
...
//
T
can
be
used
here
as
any
type
...
}
//
Creating
a
collection
of
Integers
MyCollection<Integer>
collectionOfIntegers
;
CollectionOfIntegers
=
new
MyCollection<Integer>()
;
//
Creating
a
collection
of
Strings
MyCollection<String>
collectionOfStrings
;
CollectionOfStrings
=
new
MyCollection<String>()
;
Tout
comme
les
déclarations
de
type
peuvent
être
génériques
,
les
déclarations
de
méthodes
peuvent
être
aussi
génériques
,
c'est-à-dire
paramétrisées
par
un
ou
plusieurs
paramètres
.

Exemple
de
méthode
générique
:
//
Defining
public
static
<T>
void
fromArrayToCollection(T[
]
a
,
Collection<T>
c){
for
(
T
o
:
a
)
{
c.add(o)
;
}
}
//
Using
it
String[
]
a1
=
{
"
datal
"
,
"
data2
"
,
"
data3
"
,
"
data4
"
,
"
data5
"
}
;
Collection<Object>
c1
=
new
ArrayList<String>()
;
fromArrayToCollection(a1
,
c1
)
;
Nota
.

Il
est
à
signaler
que
les
tableaux
et
les
génériques
ne
font
pas
encore
bon
ménage
!

Exemple
:
Vector<Integer>[
]
sheets
=
new
Vector<Integer>[NBOFSHEETS
]
;
produit
l'
erreur
classique
"
Generic
array
creation
"
.

Dans
cet
exemple
,
une
solution
pourrait
consister
à
passer
par
une
classe
intermédiaire
simplement
définie
par
:
class
VectorOfIntegers
extends
Vector<Integer>
{
}
Le
type
?

est
appelé
type
joker
(
wildcard
type
)
.

Il
permet
de
représenter
tout
type
.

Exemple
:
public
void
printAll(Collection<
?

>
c
)
à
for
(
Object
o
:
c
)
{
System.out.println(o)
;
}
}
Il
est
possible
de
borner
le
type
joker
.

Un
caractère
joker
avec
une
borne
supérieure
est
spécifié
:
<
?

extends
Typeë
et
représente
tous
les
sous-types
de
Type
.

Un
caractère
joker
avec
une
borne
inférieure
est
spécifié
:
<
?

super
Typeë
et
représente
tous
les
types
qui
sont
des
super-types
de
Type
.

5.2.5.2
Exemple
de
collection
:
ArrayList
Un
objet
de
type
ArrayList<E>
est
une
collection
de
taille
variable
de
éléments
de
type
E
Chaque
élément
est
repéré
par
son
indice
qui
permet
un
accès
direct
à
l'
élément
.

Une
liste-tableau
supporte
les
principales
fonctionnalités
suivantes
:
-
ajout
de
un
élément
en
fin
de
tableau
(
méthode
add(E))
-
accès
à
un
élément
de
indice
donné
(
méthodes
get(int)
et
add(int
,
e
)
)
-
suppression
de
un
élément
de
indice
donné
(
méthode
remove
(int))
-
consultation
du
nombre
de
éléments
(
méthode
size())
Les
éléments
de
un
objet
collection
de
type
ArrayList<E>
sont
indicés
de
0
à
collection.size(
)
-
1
La
classe
ArrayList<E>
doit
être
importée
du
paquetage
java.util
par
:
import
java.util.ArrayList
;
Exemple
:
ArrayList<Integer>
myCollectionOfIntegers
;
myCollectionOfIntegers
=
new
ArrayList<Integer>()
;
for
(
int
1
=
0
;
1
<
10
;
iuu
)
{
listOfintegers.add(i
,
0
)
;
}
5.2.5.3
Parcours
de
une
collection
--
Itérateur
Le
parcours
de
une
collection
est
l'
opération
qui
consiste
à
explorer
cette
collection
élément
par
élément
.

Deux
façons
de
faire
pour
parcourir
une
collection
:
-
Soit
utiliser
un
itérateur
.

Un
itérateur
est
un
objet
de
type
Iterator<E>
.

Les
trois
fonctionnalités
les
plus
utiles
pour
créer
et
gérer
un
itérateur
sont
les
méthodes
:
iterator()
(
de
la
classe
Collection
)
,
hasNext()
et
next()
(
de
la
classe
Iterator
)
.

à
noter
que
la
suppression
de
éléments
de
la
collection
en
cours
de
parcours
relève
de
la
méthode
remove()
de
l'
itérateur
et
non
de
celle
de
la
collection
.

La
classe
Iterator<E>
doit
être
importée
du
paquetage
java.util
par
:
import
java.util.Iterator
;
Les
itérateurs
sont
la
façon
de
faire
historique
pour
parcourir
une
collection
.

depuis
la
version
5.0
ils
sont
génériques
.

-
Soit
utiliser
une
boucle
for
généralisée
.

Une
telle
boucle
permet
de
s'
affranchir
des
itérateurs
et
de
parcourir
très
simplement
une
collection
quelconque
.

Elle
n'
est
offerte
que
depuis
la
version
5.0
.

Exemple
de
parcours
avec
itérateur
:
Iterator<Integer>
it
=
myCollectionOfIntegers.iterator()
;
while
(
it.hasNext()
)
{
//
call
it.next()
to
get
the
next
object
of
the
collection
//
and
do
something
with
that
object
}
Exemple
de
parcours
sans
itérateur
:
//
for
each
element
of
my
collection
of
Integers
,
print
it
for
(
Integer
v
:
myCollectionOfIntegers
)
{
System.out.println(v)
;
}
5.3
Transtypage
Le
transtypage
(
en
anglais
:
cast
/
casting
)
est
une
opération
qui
consiste
à
convertir
le
type
de
une
expression
.

La
conversion
de
type
se
réalise
en
faisant
précéder
l'
expression
par
le
type
cible
entre
parenthèses
.

Cette
proposition
s'
applique
à
certains
types
primitifs
et
au
types
objets
liés
par
une
relation
de
héritage
.

Les
conversions
incorrectes
provoquent
une
erreur
à
la
compilation
ou
à
l'
exécution
.

à
noter
que
un
transtypage
ne
change
pas
le
type
du
variables
concernées
(
le
type
de
une
variable
est
défini
une
foi
pour
toute
dès
sa
création
)
:
l'
opération
de
transtypage
est
simplement
un
changement
de
point
de
vue
qu'
on
demande
au
compilateur
.

Syntaxe
:
(
newType
)
expression
Exemple
:
int
n
=
87
;
char
c
=
(
char
)
(
n
/
2
)
;
mais
certaines
classes
offrent
des
méthodes
spécifiques
plus
adéquates
,
notamment
:
°
pour
les
conversions
réel
->
entier
:
-
la
méthode
Math
.

round(realValue)
permet
de
convertir
un
réel
en
l'
entier
le
plus
proche
-
la
méthode
Math.floor(realValue)
associée
à
une
conversion
en
entier
fournit
le
plus
grand
entier
inférieur
ou
égal
à
l'
argument
.

Exemple
:
(int)Math.floor(15.7)
vaut
15
-
la
méthode
Math.ceil(realValue)
associée
à
une
conversion
en
entier
fournit
le
plus
petit
entier
supérieur
ou
égal
à
l'
argument
.

Exemple
:
(int)Math.cei1(15.7)
vaut
16
°
pour
les
conversions
en
ou
à
partir
de
String
:
-
la
méthode
toString()
,
dont
hérite
tout
objet
,
permet
de
convertir
un
objet
en
String
-
la
méthode
valueOf(primitiveTypeExpression)
,
de
la
classe
String
,
renvoie
la
représentation
String
de
la
valeur
de
son
argument
-
la
méthode
valueOf(string)
,
dont
dispose
toute
classe
enveloppe
,
renvoie
une
instance
de
cette
classe
enveloppe
contenant
la
valeur
représentée
par
l'
argument
de
type
String
Exemples
:
//
Convert
String
type
-
primitive
type
double
x
=
Double.parseDouble("3.14159")
;
//
Convert
String
type
-
wrapped
type
Double
pi
=
Double.valueOf("3.14159")
;
//
Convert
wrapped
type
-
primitive
type
int
K
=
Integer.valueOf("1789").intValue()
;
//
Convert
primitive
type
-
String
type
String
piStr
=
String.valueOf(3.14159)
;
//
Convert
primitive
type
-
String
type
Double
pi
=
new
Double(3.14159)
;
String
s
=
pi.toString()
;
Autoboxing
/
unboxing
.

depuis
la
plate-forme
5.0
(
voir
chapitre
16
)
,
les
valeurs
de
type
primitif
sont
,
en
cas
de
besoin
,
implicitement
converties
en
l'
objet
de
la
classe
enveloppe
correspondante
(
autoboxing
)
,
et
réciproquement
(
unboxing
)
.

Auparavant
,
la
conversion
devait
être
explicite
.

6
OPERATEURS
ET
EXPRESSIONS
Java
possède
un
nombre
considérable
de
opérateurs
arithmétiques
et
logiques
.

Les
expressions
sont
constituées
de
opérandes
et
de
opérateurs
.

Les
opérandes
peuvent
être
de
différentes
natures
:
variable
,
constante
,
appel
de
fonction
.

Dans
une
expression
,
tous
les
opérateurs
doivent
être
explicites
.

Quand
plus
de
un
opérateur
apparaît
dans
une
seule
expression
,
alors
des
règles
de
précédence
sont
utilisées
pour
déterminer
l'
ordre
de
application
.

si
il
est
nécessaire
de
altérer
l'
ordre
normal
de
évaluation
,
des
parenthèses
peuvent
être
utilisées
.

à
précédences
égales
,
l'
expression
est
évaluée
de
gauche
à
droite
.

Recommandations
de
style
:
p
Utiliser
les
parenthèses
pour
isoler
les
sous-expressions
afin
de
éviter
les
problèmes
de
précédence
de
opérateur
et
rendre
le
code
plus
lisible
pour
tout
programmeur
.

p
Insérer
un
espace
avant
et
après
chaque
opérateur
autre
que
le
point
6.1
Opérateurs
et
expressions
arithmétiques
Quelques
opérateurs
arithmétiques
binaires
Opérateur
Fonction
Champ
de
application
/
division
réelle
Réels
/
division
entière
Entiers
à
modulo
(
reste
de
la
division
entière)*
Entiers
*
Nota
1
.

En
Java
comme
dans
la
plupart
du
langages
de
programmation
,
à
%
b
est
toujours
du
signe
de
a
(
alors
que
en
mathématiques
le
reste
de
la
division
euclidienne
est
toujours
positif
,
le
quotient
se
calculant
en
conséquence
)
.

Pour
Java
:
Adb
=
sgn(A)*sgn(B)*|A|/|B|
;
Aëb
=
A-çambëëb
-7
%
5
-7
/
5
En
java
-2
-1
En
math
3
-2
*
Nota
2
.

En
Java
,
l'
opérateur
modulo
%
peut
aussi
être
appliqué
sur
des
réels
.

Le
résultat
est
alors
le
reste
obtenu
après
soustraction
de
l'
opérande
droit
à
l'
opérande
gauche
un
nombre
entier
de
foi
.

Toutefois
,
à
cause
du
arrondis
de
calculs
,
le
résultat
n'
est
pas
toujours
celui
qu'
on
attendrait
(
par
exemple
:
64.5
%
6.45
donne
6.449999999999998
et
non
0.0
)
.

Grande
prudence
,
donc
,
avec
cet
opérateur
appliqué
sur
des
réels
.

Quelques
opérateurs
arithmétiques
unaires
Opérateur
Fonction
Champ
de
application
uu
Incrémentation
Entiers
ou
réels
--
décrémentation
Entiers
ou
réels
6.2
Opérateurs
et
expressions
booléennes
Quelques
opérateurs
booléens
binaires
Opérateur
Fonction
&&
ET
logique
conditionnel
*
||
OU
logique
conditionnel
*
à
OU
logique
exclusif
*
Avec
ces
opérateurs
,
l'
évaluation
de
l'
expression
logique
s'
arrête
dès
que
il
est
possible
de
inférer
la
valeur
finale
de
l'
expression
;
tous
les
opérandes
ne
sont
donc
pas
nécessairement
évalués
.

Opérateur
booléen
unaire
Opérateur
Fonction
!

Négation
logique
6.3
Opérateurs
relationnels
Quelques
opérateurs
relationnels
(
ou
de
comparaison
)
Opérateur
Fonction
==
égal
à
!

=
non
égal
à
<
inférieur
à
<=
inférieur
ou
égal
à
>
supérieur
à
>=
supérieur
ou
égal
à
7
METHODES
7.1
Définition
et
appel
de
une
méthode
ordinaire
Définition
de
une
procédure
Définition
de
une
fonction
public
void
procName(formalParams)
public
fctlype
fctName(formalParams)
à
{
declarations
declarations
statements
statements
à
return
expression
;
}
Appel
de
une
procédure
Appel
de
une
fonction
Appel
interne
à
la
classe
de
définition
:
Appel
interne
à
la
classe
de
définition
:
procName(actualParams)
;
variable
=
fctName(actualParams)
;
Appel
externe
à
la
classe
de
définition
:
Appel
externe
à
la
classe
de
définition
:
-
méthode
de
instance
-
méthode
de
instance
objectName.procName(actualParams)
;
variable
=
objectName.fctName(actualParams)
;
-
méthode
de
classe
-
méthode
de
classe
ClassName.procName(actualParams)
;
variable
=
ClassName
.

fctName(actualParams)
;
Déclaration
de
un
paramètre
formel
Spécification
de
un
paramètre
effectif
(
formal
parameter
)
(
actual
parameter
)
Paramètre
de
entrée
(
type
primitif
ou
objet
)
:
Paramètre
de
entrée
(
type
primitif
ou
objet
)
:
parameterType
parameterName
Expression
Paramètre
de
sortie
de
type
primitif
:
Paramètre
de
sortie
de
type
primitif
:
Impossible
(
utiliser
une
fonction
ou
passer
Impossible
un
paramètre
de
type
objet
)
Paramètre
de
sortie
de
type
objet
:
Paramètre
de
sortie
de
type
objet
:
parameterType
parameterName
objectName
p
Les
paramètres
spécifiés
dans
la
définition
de
une
méthode
sont
appelés
paramètres
formels
;
ils
doivent
être
précédés
de
leur
type
.

Les
paramètres
apparaissant
dans
la
forme
de
appel
sont
appelés
paramètres
effectifs
.

si
il
y
a
plusieurs
paramètres
,
ils
sont
séparés
par
des
virgules
.

p
Tous
les
paramètres
de
type
primitif
sont
passés
par
valeur
(
c'
est
une
copie
de
cet
argument
qui
est
transmise
à
la
méthode
,
elle
ne
dispose
pas
de
l'
original
)
.

Tous
les
paramètres
de
type
objet
sont
passés
par
référence
(
c'
est
une
référence
,
i.e.
un
pointeur
,
qui
est
transmis
à
la
méthode
,
et
pas
l'
objet
lui-même
)
.

p
Par
défaut
,
les
méthodes
sont
des
méthodes
de
instance
:
elles
sont
invoquées
sur
une
instance
de
classe
.

Il
existe
aussi
des
méthodes
de
classe
qui
peuvent
être
invoquées
sans
instance
.

On
spécifie
une
méthode
de
classe
en
la
déclarant
static
p
La
signature
[
1
]
de
une
méthode
est
constituée
de
son
nom
et
de
la
liste
du
types
du
paramètres
.

Dans
une
même
classe
,
deux
méthodes
ne
peuvent
pas
avoir
la
même
signature
;
elles
peuvent
toutefois
porter
le
même
nom
(
cela
s'
appelle
la
surcharge
)
.

+
Dans
toute
méthode
de
instance
ou
constructeur
,
on
peut
référer
à
l'
objet
courant
(
i.e.
l'
objet
dont
la
méthode
ou
le
constructeur
est
en
cours
de
appel
)
par
le
mot
clé
this
.

On
peut
ainsi
référer
à
tout
membre
(
champ
ou
méthode
)
de
l'
objet
courant
par
un
identifiant
de
la
forme
this.membre
7.2
Constructeur
Un
constructeur
est
une
méthode
particulière
dont
l'
invocation
est
explicitement
associée
à
la
création
de
une
instance
de
classe
et
dont
la
finalité
est
de
initialiser
proprement
l'
état
de
cet
objet
lors
de
sa
création
.

La
définition
de
un
constructeur
suit
des
règles
syntaxiques
spécifiques
:
le
nom
de
un
constructeur
est
obligatoirement
le
nom
de
sa
classe
de
appartenance
;
l'
en-tête
de
sa
définition
ne
lui
spécifie
pas
de
type
.

Syntaxe
de
définition
de
un
constructeur
de
une
classe
de
nom
ClassName
:
public
ClassName(formalParameters)
{
//
...
Fields
initializations
...
}
Un
constructeur
est
typiquement
utilisé
en
association
avec
l'
opérateur
new
.

Exemple
de
syntaxe
de
utilisation
de
un
constructeur
de
une
classe
de
nom
ClassName
:
ClassName
object
=
new
ClassName(actualParameters)
;
Une
même
classe
peut
comporter
plusieurs
constructeurs
sous
condition
que
ils
n'
aient
pas
les
mêmes
paramètres
.

Dans
ce
cas
,
pour
éviter
de
la
duplication
de
code
,
un
constructeur
peut
en
appeler
un
autre
avec
la
syntaxe
:
this(actualParameters
)
.

Exemple
:
public
class
Point
à
private
int
x
,
y
;
public
Pointe
int
x
,
int
y
)
{
//
à
first
constructor
this.x
=
X
;
this.y
=
y
;
à
public
Point()
{
//
à
second
constructor
this(
0
,
0
)
;
}
//
...
}
[
1
]
à
noter
que
cette
définition
,
adoptée
par
Java
,
ne
prend
pas
en
considération
le
type
de
la
méthode
.

En
ce
sens
,
la
"
signature
"
correspond
à
ce
qui
est
parfois
appelé
par
ailleurs
"
profil
"
de
la
méthode
.

7.3
Méthode
main
La
méthode
main
,
comme
en
C
ou
C++
,
est
le
point
de
entrée
de
une
application
au
lancement
de
l'
exécution
.

Syntaxe
:
public
static
void
main(String[
]
args
)
{
...
à
L'
argument
args
capte
les
éventuels
arguments
de
la
ligne
de
commande
,
le
premier
argument
de
la
ligne
de
commande
étant
stocké
dans
args[0
]
(
et
non
dans
args[1
]
comme
en
C/C++
)
Exemple
:
Considérons
une
application
dont
la
classe
principale
-
celle
contenant
la
méthode
main
-
s'
appelle
Game
.

Supposons
que
l'
application
dépende
de
deux
paramètres
dont
les
valeurs
doivent
être
fournies
au
lancement
.

Supposons
également
que
le
fichier
source
Game
.

java
ait
été
compilé
en
un
fichier
exécutable
Game.class
.

Le
lancement
de
l'
application
par
la
commande
:
java
Game
Daniel
20
attribuera
à
args
le
tableau
{
"
Daniel
"
,
"
20
"
}
8
INSTRUCTIONS
Sur
le
plan
syntaxique
,
les
instructions
(
statements
)
peuvent
être
regroupées
en
3
grandes
catégories
:
-
les
instructions
simples
:
instructions
de
affectation
,
instructions
de
entrée
/
sortie
,
instructions
de
appel
à
une
procédure
.

Une
instruction
simple
se
termine
toujours
par
un
point-virgule
.

Un
point-virgule
seul
définit
une
instruction
vide
.

-
les
instructions
de
contrôle
:
instructions
de
sélection
,
instructions
de
boucle
,
instructions
de
rupture
de
séquence
.

-
les
blocs
de
instructions
.

Un
bloc
de
instructions
-
aussi
appelé
instruction
composée
-
est
une
séquence
de
instructions
enserrée
entre
accolades
.

Le
bloc
{
}
définit
une
instruction
vide
.

8.1
Instruction
de
affectation
Syntaxe
:
variable
=
expression
;
Le
symbole
=
est
l'
opérateur
de
affectation
.

La
valeur
de
l'
expression
située
en
partie
droite
est
affectée
à
la
variable
spécifiée
en
partie
gauche
.

Le
type
de
l'
expression
doit
s'
apparier
au
type
de
la
variable
.

L'
impact
physique
est
différent
selon
que
l'
expression
est
de
type
primitif
ou
objet
(
voir
chapitre
5
)
.

8.2
Instructions
de
contrôle
8.2.1
Instructions
de
sélection
8.2.1.1
if-else
Première
forme
:
Deuxième
forme
:
if
(
expression
)
à
if
(
expression
)
à
statements
statements
à
à
else
à
statements
}
Exemple
:
if
(
field.size()
çù
0
)
{
System.out.println("The
field
is
empty
.
"
)
;
}
Exemple
:
if
(
number
<
0
)
{
reportError()
;
à
else
{
processNumber(number)
;
}
Exemple
:
if
(
n
<
0
)
à
handleNegative()
;
à
else
if
(
n
==
0
)
{
handlezero()
;
à
else
{
handlePositive()
;
}
8.2.1.2
switch
Première
forme
:
Deuxième
forme
:
switch
(
expression
)
{
switch
(
expression
)
à
case
value1
:
case
value1
:
statements
;
/*
falls
through
*/
break
;
case
value2
:
case
value2
:
/*
falls
through
*/
statements
;
case
value3
:
break
;
statements
;
default
:
break
;
statements
;
case
value4
:
break
;
/*
falls
through
*/
à
case
value5
:
statements
;
break
;
default
:
statements
;
break
;
}
p
Une
instruction
switch
peut
avoir
un
nombre
quelconque
de
labels
case
p
L'
instruction
break
met
fin
à
l'
instruction
switch
.

à
défaut
de
instruction
break
,
l'
exécution
se
poursuit
sur
les
instructions
du
labels
suivants
.

La
deuxième
forme
ci-
dessus
exploite
ce
comportement
:
chacune
du
trois
premières
valeurs
conduira
à
l'
exécution
de
la
partie
statements
associée
à
value3
;
chacune
du
deux
valeurs
suivantes
conduira
à
l'
exécution
de
la
partie
statements
associée
à
value5
;
p
La
clause
default
est
optionnelle
,
mais
recommandée
.

à
défaut
,
il
se
peut
que
aucun
cas
ne
conduise
à
une
exécution
.

Exemple
:
switch
(
day
)
à
case
1
:
dayString
=
"
Monday
"
;
break
;
case
2
:
dayString
=
"
Tuesday
"
;
break
;
case
3
:
dayString
=
"
Wednesday
"
;
break
;
case
4
:
dayString
=
"
Thursday
"
;
break
;
case
5
:
dayString
=
"
Friday
"
;
break
;
case
6
:
dayString
=
"
Saturday
"
;
break
;
case
7
:
dayString
=
"
Sunday
"
;
break
;
default
:
error()
;
break
;
}
Exemple
:
switch
(
winterMonth
)
à
case
11
:
numberOfDays
=
30
;
break
;
case
12
:
/*
falls
through
*/
case
1
:
numberOfDays
=
31
;
break
;
case
2
:
if
(isLeapYear())
{
numberOfDays
à
29
;
à
else
{
numberOfDays
=
28
;
}
break
;
default
:
error()
;
break
;
}
8.2.2
Instructions
de
boucle
8.2.2.1
while
La
boucle
while
exécute
un
bloc
de
instructions
aussi
longtemps
que
la
valeur
de
une
expression
donnée
est
true
.

L'
expression
est
testée
avant
chaque
exécution
du
corps
de
boucle
,
si
bien
que
le
corps
de
boucle
peut
être
exécuté
0
foi
.

Syntaxe
:
while
(
expression
)
à
statements
}
Exemple
:
int
i
=
0
;
while
(
1
<
text.size())
{
System.out.printl(text.get())
;
iu
;
}
Exemple
:
while
(iter.hasNext())
{
processObject(iter.next()
;
}
8.2.2.2
do-while
La
boucle
do-while
le
exécute
un
bloc
de
instructions
aussi
longtemps
que
la
valeur
de
une
expression
donnée
est
true
.

L'
expression
est
testée
après
chaque
exécution
du
corps
de
boucle
,
si
bien
que
le
corps
de
boucle
est
toujours
exécuté
au
moins
1
foi
.

Syntaxe
:
do
à
statements
}
while
(
expression
)
;
Exemple
:
do
{
input
=
readInput()
;
if
(
input
çù
null
)
{
System.out.printl("Try
again
"
)
;
}
}
while
(
input
==
null
)
;
8.2.2.3
for
La
boucle
for
s'
exécute
aussi
longtemps
que
une
condition
s'
évalue
à
true
.

Avant
que
la
boucle
ne
démarre
,
une
instruction
de
initialisation
est
exécutée
exactement
1
foi
.

La
condition
est
évaluée
avant
chaque
exécution
du
corps
de
boucle
(
comme
pour
une
boucle
while
)
.

Une
instruction
de
mise
à
jour
des
variables
est
exécutée
après
chaque
exécution
du
corps
de
boucle
.

Syntaxe
:
for
(
initialization
;
condition
;
update
)
à
statements
}
Exemple
:
for
(
int
1
=
0
;
1
<
text.size()
;
iuu
)
à
System.out.println(text.get())
;
}
8.2.2.4
foreach
depuis
la
plate-forme
5.0
(
voir
chapitre
16
)
,
Java
offre
une
boucle
for
améliorée
pour
parcourir
les
éléments
de
un
tableau
ou
de
une
collection
(
se
reporter
au
sections
respectives
)
.

Syntaxe
:
//
for
each
element
of
the
collection
,
process
element
for
(
TypeOfElements
element
:
collectionOfElements
)
{
//
...
process
element
...
}
8.3
Instructions
de
entrée
/
sortie
Java
offre
un
nombre
considérable
de
fonctions
et
procédures
de
entrée
/
sortie
,
tant
en
mode
texte
que
graphique
.

Nous
nous
limitons
dans
cette
section
au
principales
instructions
de
entrées/sorties
en
mode
texte
;
pour
des
entrées/sorties
en
mode
graphique
,
voir
chapitre
11
.

Les
méthodes
de
entrée
/
sortie
primaires
appartiennent
au
classes
du
paquetage
java
.

io
.

depuis
la
plate-forme
5.0
(
voir
chapitre
16
)
,
la
classe
Scanner
du
paquetage
java.uti1
offre
:
-
des
fonctionnalités
de
base
pour
lire
facilement
des
données
depuis
tout
flux
de
entrée
;
-
des
sorties
formatées
comme
en
Co
En
complément
,
la
classe
java.util.Formatter
permet
de
spécifier
des
formats
de
entrée
ou
de
sortie
.

8.3.1
Notion
de
flux
Les
flux
ou
flots
(
streams
en
anglais
)
généralisent
la
notion
de
périphérique
de
entrée
/
sortie
.

Un
flux
peut
être
vu
comme
une
interface
intelligente
unidirectionnelle
reliant
la
machine
Java
et
le
périphérique
,
et
qui
permet
,
en
lecture
aussi
bien
que
en
écriture
,
de
s'
affranchir
du
spécificités
du
périphérique
concerné
.

Réaliser
une
entrée
/
sortie
consiste
ainsi
à
:
1
)
créer
un
flux
du
type
approprié
(
sauf
si
il
existe
déjà
,
ou
est
prédéfini
(
System.in
,
System.out
ou
System.err
)
)
2
)
lire
ou
écrire
,
selon
le
cas
,
dans
ce
flux
3
)
et
souvent
,
dans
le
cas
de
une
lecture
,
convertir
la
donnée
lue
dans
le
type
cible
souhaité
Pour
une
première
approche
,
nous
nous
limiterons
à
des
flux
à
accès
séquentiel
.

8.3.2
Entrée
/
sortie
terminal
Les
solutions
suivantes
ne
s'
affranchissent
pas
des
erreurs
de
saisie
.

Pour
gérer
ce
type
de
erreur
,
se
reporter
au
chapitre
Exceptions
(
chapitre
10
)
.

8.3.2.1
Affichage
écran
Syntaxe
de
un
affichage
écran
en
mode
texte
:
System.out.print(string)
;
System.out.println(string)
;
System.out.print(primitiveTypeExpression)
;
System.out.println(primitiveTypeExpresstion)
;
8.3.2.2
Affichage
formaté
depuis
la
plate-forme
5.0
,
Java
offre
également
une
méthode
printf
permettant
des
sorties
formatées
comme
en
C
(
voir
classe
java.util.Formatter
pour
la
spécification
du
formats
)
.

Exemples
:
System.out.println("count
=
"
p
count
)
;
System.out.printf("%s
%5d
\n
"
,
user
,
total
)
;
Fonctionnement
du
printf
et
codes
de
formatage
:
Un
printf
réclame
une
chaîne
de
caractères
en
premier
paramètre
.

Cette
chaîne
peut
être
suivie
de
n
variables
,
n>0
.

C'
est
cette
chaîne
,
qui
peut
contenir
des
codes
de
formatage
,
qui
est
imprimée
.

Un
code
de
formatage
commence
par
le
caractère
%
.

à
chaque
foi
que
un
code
de
formatage
est
rencontré
,
printf
imprime
la
variable
suivante
dans
la
liste
de
ses
paramètres
.

Principaux
codes
de
formatage
Commande
l'
affichage
de
une
valeur
de
type
:
%c
Caractère
%d
Entier
%e
Réel
(
en
notation
avec
exposant
)
ff
Réel
#s
Chaîne
de
caractères
Le
code
de
formatage
peut
inclure
une
spécification
de
format
du
champ
de
affichage
.

Exemples
de
codes
de
formatage
Champ
de
affichage
spécifié
pour
le
paramètre
du
type
considéré
:
%6d
Champ
de
6
caractères
%-6d
Champ
de
6
caractères
avec
justification
à
gauche
%8.2f
Champ
de
8
caractères
dont
2
à
droite
de
la
virgule
8.3.2.3
Lecture
clavier
Exemple
:
Scanner
input
à
new
Scanner(System.in)
;
String
s1
=
input.next()
;
//
read
a
string
(
a
word
)
String
s2
=
input.nextLine()
;
//
read
the
rest
of
the
line
int
n
=
input.nextInt()
;
//
read
an
integer
double
r
=
input.nextDouble()
;
//
read
a
double
input.close()
;
8.3.3
Entrée
/
sortie
fichier
Opérer
sur
un
fichier
consiste
à
:
1
)
créer
un
flux
approprié
au
opérations
souhaitées
2
)
lire
ou
écrire
dans
le
fichier
3
)
fermer
le
fichier
Les
solutions
suivantes
ne
s'
affranchissent
pas
du
erreurs
de
entrée
/
sortie
.

Pour
gérer
ce
type
de
erreur
,
se
reporter
au
chapitre
Exceptions
(
chapitre
10
)
.

8.3.3.1
Ecriture
fichier
depuis
la
plate-forme
5.0
,
Java
offre
également
une
méthode
printf
permettant
des
sorties
formatées
comme
en
C
(
voir
classe
java.util.Formatter
pour
la
spécification
du
formats
)
.

Exemple
de
écriture
dans
un
fichier
texte
:
PrintWriter
out
à
new
PrintWriter(outputFileName)
;
for
(
int
i=0
;
i<10
;
iuu
)
out.printf("%c%d",'\t',i)
;
out.close()
;
8.3.3.2
Lecture
fichier
Exemple
de
lecture
de
un
fichier
texte
mot
à
mot
:
Scanner
in
=
new
Scanner(new
File(inputFileName))
;
String
s
;
while
(in.hasNext())
{
s
=
in.next()
;
//
read
a
string
(
a
word
)
System.out.println(s)
;
à
in.close()
;
8.3.3.3
Contextes
particuliers
Cas1
.

Ouverture
en
lecture
de
un
fichier
texte
stocké
dans
le
fichier
.jar
exécuté
import
java.io.InputStream
;
import
java.util.Scanner
;
ClassLoader
cl
=
ClassLoader.getSystemClassLoader()
;
InputStream
is
=
cl.getResourceAsStream(inputFileName)
;
Scanner
in
=
new
Scanner(is)
;
Cas2
.

Ouverture
en
lecture
de
un
fichier
texte
distant
identifié
par
une
URL
import
java.net.URL
;
import
java.util.Scanner
;
URL
url
=
new
URL("http://www.esiee.fr/
...
/inputFileName
"
)
;
Scanner
in
=
new
Scanner
(url.openStream())
;
Nota
.

Solution
non
applicable
depuis
une
applet
.

En
outre
,
bien
s'
assurer
que
toutes
les
conditions
de
accessibilité
au
fichier
sont
levées
(
pas
de
interdiction
par
le
pare-feu
local
notamment
!

)
Cas3
.

Ouverture
de
une
nouvelle
page
html
depuis
une
applet
(
de
même
répertoire
)
import
java.net.URL
;
import
javax.swing.JApplet
;
URL
url
=
new
URL(getDocumentBase()
,
"
myFile.html
"
)
;
getAppletContext().showDocument(url
,
"
_blank
"
)
;
repaint()
;
8.3.4
Lecture
de
une
chaîne
de
caractères
formatée
Il
est
fréquent
de
avoir
à
lire
une
chaîne
de
caractères
dont
on
connaît
le
format
,
quel
que
soit
le
flux
de
entrée
(
terminal
ou
fichier
)
.

depuis
la
plate-forme
5.0
,
la
classe
Scanner
du
paquetage
java.util
offre
des
fonctionnalités
très
pratiques
.

Exemple
de
lecture
de
une
chaîne
de
caractères
formatée
:
String
str
=
"
1
XXX
2
XXX
yellow
XXX
blue
XXX
'
"
'
;
Scanner
in
=
new
Scanner(str).useDelimiter("\\s*XXX\\s*")
;
System.out.println(in.nextInt())
;
System.out.println(in.nextInt())
;
System.out.println(in.next())
;
System.out.println(in.next())
;
in.close()
;
//
Will
display
:
//
1
//
2
//
yellow
//
blue
9
HERITAGE
9.1
Notion
de
héritage
L'
héritage
est
une
technique
qui
offre
de
nombreux
avantages
:
-
évite
la
duplication
de
code
-
permet
la
réutilisation
de
code
dans
un
autre
contexte
-
facilite
la
maintenance
du
programmes
-
facilite
l'
extension
de
applications
existantes
.

L'
héritage
(
inheritance
)
est
une
relation
"
est_un
"
(
non
pas
"
a_un
"
!

!
!

)
qui
permet
de
définir
une
classe
comme
l'
extension
de
une
autre
.

Exemple
:
Classe
Astre
est_un
est_un
Classe
Etoile
Classe
Planète
Une
étoile
est
un
astre
;
une
planète
est
un
astre
.

La
classe
Etoile
étend
la
classe
Astre
à
la
classe
Etoile
hérite
de
la
classe
Astre
.

Une
super-classe
est
une
classe
qui
est
étendue
par
d'
autres
classes
.

Une
sous-classe
est
une
classe
qui
étend
(
hérite
de
)
une
autre
classe
.

Elle
hérite
l'
état
et
le
comportement
de
tous
ses
ancêtres
,
mais
peut
aussi
les
redéfinir
.

Les
classes
qui
sont
liées
par
des
relations
de
héritage
forment
une
hiérarchie
de
héritage
.

Exemple
de
hiérarchie
de
héritage
:
Astre
Etoile
Planète
Exoplanète
Planète
Solaire
Pégaside
Chtonienne
Tellurique
Habitable
Le
constructeur
de
une
sous-classe
doit
toujours
invoquer
le
constructeur
de
la
super-classe
en
première
instruction
(
à
défaut
,
Java
essaiera
de
insérer
un
appel
automatique
)
.

La
forme
de
appel
est
la
suivante
:
super(actualParameters)
;
Toute
classe
sans
super-classe
explicite
a
Object
comme
super-classe
.

Comme
pour
la
hiérarchie
de
classes
,
les
types
forment
une
hiérarchie
de
types
.

Le
type
défini
par
la
définition
de
une
sous-classe
est
un
sous-type
du
type
défini
par
la
super-classe
.

Exemple
:
Etoile
est
un
sous-type
du
type
Astre
Une
variable
peut
contenir
:
-
un
objet
du
type
déclaré
de
la
variable
-
ou
un
objet
de
tout
sous-type
de
ce
type
déclaré
Exemple
:
Astre
al
=
new
Astre()
;
//
correct
Astre
a2
=
new
Etoile
)
;
//
correct
(
transtypage
ascendant
)
Astre
a3
=
new
Planete()
;
//
correct
(
transtypage
ascendant
)
Etoile
el
=
new
Astre()
;
//
erreur
Etoile
e3
=
(Etoile)a2
;
//
correct
(
un
transtypage
descendant
//
doit
être
explicite
)
Un
objet
de
un
sous-type
peut-être
utilisé
partout
où
un
objet
de
un
super-type
est
attendu
.

Ceci
s'
appelle
la
substitution
.

Java
ne
permet
pas
l'
héritage
multiple
:
une
sous-classe
ne
peut
hériter
directement
que
de
une
seule
super-classe
.

9.2
Qu'
hérite
une
sous-classe
?

Une
sous-classe
hérite
de
tous
les
membres
de
sa
super-classe
qui
sont
accessibles
,
sauf
si
ce
membre
(
attribut
ou
méthode
)
est
redéfini
dans
la
sous-classe
.

Une
sous-classe
hérite
de
sa
super-classe
:
-
les
membres
déclarés
public
ou
protected
-
les
membres
déclarés
sans
modificateur
de
accès
,
si
la
sous-classe
est
dans
le
même
paquetage
que
la
super-classe
.

Une
sous-classe
n'
hérite
pas
de
sa
super-classe
:
-
les
membres
qui
sont
redéfinis
dans
la
sous-classe
-
les
constructeurs
.

Attention
au
choix
du
identificateurs
dans
la
sous-classe
:
ce
choix
peut
involontairement
masquer
un
membre
de
la
super-classe
!

C'
est
particulièrement
le
cas
pour
les
attributs
:
un
attribut
ayant
le
même
nom
que
un
attribut
de
sa
super-classe
masque
l'
attribut
de
la
super-
classe
,
même
si
ils
sont
de
types
différents
.

9.3
Redéfinir
une
méthode
Pour
redéfinir
une
méthode
dans
une
sous-classe
,
il
faut
que
elle
ait
la
même
signature
et
le
même
type
de
retour
que
la
méthode
de
la
super-classe
.

La
méthode
redéfinie
peut
autoriser
un
accès
plus
large
mais
pas
moins
(
ex
:
une
méthode
déclarée
protected
dans
la
super-
classe
peut
être
redéfinie
public
dans
la
sous-classe
,
mais
pas
private
)
.

L'
exemple
typique
est
la
méthode
toString
de
la
classe
Object
:
appliquée
à
un
objet
,
elle
produit
une
chaîne
de
caractères
formée
du
nom
de
sa
classe
et
de
son
code
de
hachage
,
mais
cette
méthode
peut
être
redéfinie
dans
toute
classe
.

si
la
méthode
redéfinie
dans
la
sous-classe
a
simplement
besoin
de
ajouter
quelques
fonctionnalités
complémentaires
à
celles
de
la
méthode
de
la
super-classe
,
il
n'
est
pas
besoin
de
la
réécrire
complètement
car
elle
peut
appeler
la
méthode
de
la
super-classe
par
:
super.superclassMethodName(actualParameters)
Quelques
règles
:
-
une
méthode
de
instance
ne
peut
pas
redéfinir
une
méthode
de
classe
,
et
réciproquement
-
une
méthode
de
instance
de
une
sous-classe
ayant
les
mêmes
signature
et
type
que
une
méthode
de
instance
dans
la
super-classe
redéfinit
la
méthode
de
la
super-classe
:
la
version
de
la
méthode
invoquée
sur
une
instance
de
la
sous-classe
(
type
dynamique
car
liaison
dynamique
du
méthodes
de
instance
)
est
celle
de
la
sous-classe
.

-
une
méthode
de
classe
de
une
sous-classe
ayant
les
mêmes
signature
et
type
que
une
méthode
de
classe
dans
la
super-classe
masque
la
méthode
de
la
super-classe
:
la
version
de
la
méthode
invoquée
dépend
de
si
elle
est
appelée
sur
la
super-classe
ou
sur
la
sous-classe
(
car
liaison
statique
du
méthodes
de
classe
)
.

-
une
sous-classe
ne
peut
pas
redéfinir
les
méthodes
déclarées
final
de
sa
super-classe
-
une
sous-classe
doit
redéfinir
les
méthodes
déclarées
abstract
dans
la
super-classe
,
à
moins
que
la
sous-classe
soit
elle-même
déclarée
abstract
.

depuis
la
plate-forme
5.0
(
voir
chapitre
16
)
:
Il
est
conseillé
de
utiliser
l'
annotation
(
ou
méta-donnée
)
@Override
pour
marquer
toute
méthode
qui
est
supposée
redéfinir
une
méthode
héritée
de
une
classe
parent
.

Cela
permet
au
compilateur
de
signaler
immédiatement
une
erreur
si
jamais
la
redéfinition
n'
est
pas
avérée
(
à
cause
par
exemple
de
une
faute
de
frappe
dans
le
nom
de
la
méthode
)
.

En
outre
,
en
signalant
les
méthodes
redéfinies
,
l'
annotation
@Override
permet
de
accroître
la
lisibilité
du
code
.

La
covariance
du
types
de
retour
est
autorisée
:
une
méthode
de
une
sous-classe
peut
retourner
un
objet
dont
le
type
est
une
sous-classe
du
type
retourné
par
la
méthode
de
même
signature
dans
la
super-classe
.

Cette
caractéristique
supprime
le
besoin
de
tests
et
de
conversions
de
types
excessifs
.

Exemple
:
@Override
public
String
toString()
{
//
...
}
Exemple
:
Soit
une
classe
Point
possédant
deux
attributs
x
et
y
;
soit
une
classe
ColoredPoint
héritant
de
Point
et
possédant
un
attribut
spécifique
color
.

Où
et
comment
écrire
la
méthode
equals
sans
duplication
de
code
?

/*
In
the
class
Point
*/
@Override
public
boolean
equals(
Object
o
)
à
if
(
o
==
null
)
return
false
;
//
case
null
if
(
this
==
o
)
return
true
;
//
reflexivity
if
(
this.getClass()
!

=
o.getClass()
)
return
false
;
//
symmetry
//
Now
,
this
and
o
having
the
same
class
,
compare
the
fields
Point
p
=
(Point)o
;
return
(
this.x
çù
pox
)
&&
(
this.y
çà
p.y
)
;
}
/*
In
the
class
ColoredPoint
extending
Point
*/
@Override
public
boolean
equals(
Object
o
)
{
//
Verify
if
this
and
o
have
the
same
class
and
if
their
super
//
fields
are
equal
if
(
!

super.equals(o)
)
return
false
;
//
Now
compare
the
specific
fields
ColoredPoint
cp
=
(ColoredPoint)o
;
return
this.color.equals(cp.color)
;
}
Exemple
:
public
class
MotherClass
{
public
void
normal()
à
System.out.println("the
normal
method
in
MotherClass
"
)
;
}
public
static
void
hideçà
à
System.out.println("the
hide
method
in
MotherClass
"
)
;
}
public
void
override()
{
System.out.println("the
override
method
in
MotherClass
"
)
;
}
}
//
end
MotherClass
public
class
DaughterClass
extends
MotherClass
à
@Override
public
static
void
hideçà
à
System.out.println("the
hide
method
in
DaughterClass
"
)
;
}
@Override
public
void
override()
{
System.out.println("the
override
method
in
DaughterClass
"
)
;
}
public
static
void
main(String[
]
args
)
à
DaughterClass
o1
=
new
DaughterClass()
;
MotherClass
o2
o1
;
o1.normal()
;
//
call
super.normal()
o2.normal()
;
//
call
super.normal()
o1.hide()
;
//
call
this.hide()
o2.hide()
;
//
call
super.hide()
!

!

liaison
statique
o1.override()
;
//
call
this.override()
o2.override()
;
//
call
this.override()
!

!

Tiaison
dynamique
à
}
//
end
DaughterClass
La
méthode
main
affichera
:
the
normal
method
in
MotherClass
the
normal
method
in
MotherClass
the
hide
method
in
DaugterClass
the
hide
method
in
MotherClass
the
override
method
in
DaugterClass
the
override
method
in
DaugterClass
9.4
Type
statique
/
dynamique
-
Liaison
statique
/
dynamique
Cette
section
reprend
et
formalise
quelques
uns
du
importants
concepts
introduits
dans
les
sections
précédentes
.

9.4.1
Type
statique
/
dynamique
-
Transtypage
Le
type
statique
de
un
objet
est
le
type
spécifié
par
sa
déclaration
.

C'
est
le
type
déclaré
.

C'
est
le
type
à
la
compilation
.

Le
type
dynamique
de
un
objet
est
le
type
(
i.e.
la
classe
de
appartenance
)
de
l'
objet
instancié
.

C'
est
le
type
constaté
.

C'
est
le
type
effectif
à
l'
exécution
.

Le
type
dynamique
de
un
objet
est
toujours
soit
son
type
statique
soit
un
sous-type
de
son
type
statique
(
sauf
exceptions
dues
au
transtypages
)
.

Exemple
:
Soient
une
classe
à
et
une
classe
b
sous-classe
de
ao
Considérons
le
code
suivant
:
à
a
;
if
(
myClass.booleanRandom()
)
{
a
à
new
aùà
;
}
else
{
a
à
new
bçë
;
//
transtypage
ascendant
implicite
à
Le
type
statique
de
a
est
a
;
le
type
dynamique
de
a
sera
à
ou
b
mais
ne
pourra
être
constaté
qu'
après
que
la
condition
aura
été
évaluée
.

Le
transtypage
(
casting
)
appliqué
à
une
référence
n'
est
que
la
possibilité
de
avoir
une
vue
spécifique
de
l'
objet
pointé
.

Il
ne
change
en
rien
le
type
de
l'
objet
sous-jacent
!

(
qui
garde
bien
évidemment
tout
au
long
de
sa
vie
le
type
avec
lequel
il
a
été
créé
)
.

L'
opération
de
transtypage
est
purement
syntaxique
et
ne
fait
qu'
indiquer
au
compilateur
le
point
de
vue
depuis
lequel
il
doit
voir
l'
objet
.

Le
transtypage
vers
un
sur-type
est
dit
ascendant
.

Le
transtypage
ascendant
est
implicite
.

Le
transtypage
vers
un
sous-type
est
dit
descendant
.

Un
transtypage
descendant
doit
être
explicite
.

Il
permet
de
forcer
la
compilation
mais
ne
garantit
pas
nécessairement
l'
absence
de
erreur
de
exécution
.

Un
transtypage
n'
est
garanti
correct
que
si
il
respecte
la
règle
suivante
:
Soient
T1
et
T2
deux
types
définis
.

Soit
o
un
objet
de
type
dynamique
T3
.

Considérons
la
déclaration
:
T1
obj
à
(T2)o
;
Ce
transtypage
est
garanti
possible
,
tant
à
la
compilation
que
à
l'
exécution
,
si
et
seulement
si
T3
est
un
sous-type
de
T2
et
T2
un
sous-type
de
T1
.

L'
opérateur
instanceof
permet
de
tester
si
un
objet
est
de
un
type
dynamique
donné
ou
de
tout
sous-type
de
ce
type
donné
.

Il
peut
donc
permettre
vérifier
la
compatibilité
du
types
avant
de
opérer
un
transtypage
.

Exemple
:
Supposons
définies
:
public
class
Shape2D
{
...
}
public
class
Circle
extends
Shape2D
{
...
}
public
class
Triangle
extends
Shape2D
{
...
}
public
class
Date
{
...
}
Les
déclarations
suivantes
génèreraient
une
erreur
pour
incompatibilité
de
types
:
Shape2D
s
=
(
Shape2D
)
(
new
Date())
;
//
erreur
de
compilation
Circle
c
=
new
Shape2D()
;
//
erreur
de
compilation
Circle
c
à
(Circle)(new
Shape2D())
;
//
erreur
de
exécution
Triangle
t
=
new
Triangle()
;
Circle
c
=
(Circle)t
;
//
erreur
de
exécution
Les
déclarations
suivantes
sont
saines
:
Shape2D
s
=
new
Circle()
;
Circle
c
à
(Circle)s
;
Shape2D
s
;
if
(
obj
instanceof
Shape2D
)
s
=
(Shaped2D)obj
;
9.4.2
Liaison
statique
/
dynamique
Considérons
l'
invocation
o.m
où
o
est
un
objet
de
type
statique
T
et
de
type
dynamique
T
'
,
et
m
un
message
(
attribut
ou
méthode
)
envoyé
à
ou
si
le
message
m
exécuté
est
celui
dont
le
code
est
accessible
depuis
la
classe
T
,
alors
la
liaison
de
l'
objet
au
message
sera
dite
statique
(
liaison
à
la
compilation
)
sinon
elle
sera
dite
dynamique
(
liaison
à
l'
exécution
)
.

En
java
:
-
la
liaison
de
un
objet
avec
ses
variables
de
instance
est
statique
;
-
la
liaison
de
un
objet
avec
ses
méthodes
est
dynamique
(
sauf
si
méthode
static
ou
final
)
.

Exemple
:
public
class
à
{
public
boolean
m1(A
a
)
à
return
true
;
}
public
boolean
m2(A
a
)
à
return
true
;
}
à
public
class
B
extends
à
{
public
boolean
m1(A
a
)
à
return
false
;
}
public
boolean
m3(A
a
)
à
return
false
;
}
public
static
void
main(String[
]
args
)
{
a
a
à
new
Büë
;
System.out.prinln(a.m1(a))
;
System.out.prinln(a.m2(a))
;
//
System.out.prinln(a.m3(a))
;
//
problème
}
à
La
méthode
main
affichera
:
false
true
Pourquoi
?

Le
type
statique
de
a
est
a
,
et
son
type
dynamique
Bo
C'
est
donc
le
m1
de
b
qui
est
exécutée
.

Quant
à
la
méthode
m2
,
elle
n'
est
pas
définie
dans
b
mais
dans
sa
super-classe
a
:
b
hérite
donc
normalement
de
m2
et
m2
est
exécutée
.

La
dernière
instruction
System.out.prinln(a.m3(a))
provoquerait
une
erreur
à
la
compilation
.

Pourquoi
?

Parce
que
le
compilateur
ne
connaît
que
le
type
statique
(
i.e.
le
type
déclaré
)
:
la
méthode
m3
n'
étant
pas
définie
dans
la
classe
à
ni
dans
une
de
ses
super-classes
,
le
compilateur
ne
trouve
pas
la
définition
de
m3
(
bien
que
dans
b
)
et
génère
une
erreur
.

La
solution
serait
le
transtypage
descendant
préalable
de
a
:
System.out.prinln(((B)a).m3(a)
)
.

Ce
transtypage
serait
correct
car
à
possède
déjà
,
par
création
,
tous
les
attributs
de
une
instance
de
Bo
9.5
Polymorphisme
Un
même
appel
de
méthode
peut
invoquer
des
méthodes
différentes
car
la
liaison
est
réalisée
dynamiquement
(
i.e.
à
l'
exécution
et
non
à
la
compilation
)
,
l'
identification
du
type
de
l'
objet
associé
à
l'
appel
étant
dynamique
.

Exemple
de
polymorphisme
de
héritage
:
public
class
shape
{
public
void
draw()
{
System.out.println(
this
p
"
.draw()
;
"
)
;
}
}
public
class
Circle
extends
Shape
à
@Override
public
String
toString()
à
return
"
circle
"
;
}
}
public
class
Square
extends
Shape
à
@Override
public
String
toString()
à
return
"
square
"
;
}
}
public
class
Picture
à
public
static
void
main(String[
]
args
)
{
Vector<Shape>
v
=
new
Vector<Shape>()
;
voaddà
new
Circle()
)
;
voaddà
new
Square()
)
;
for
(
Shape
s
:
v
)
{
System.out.prinln(
s.draw()
)
;
//
polymorphism
à
La
méthode
main
affichera
:
circle.draw()
;
square.draw()
;
9.6
Classes
et
méthodes
particulières
Une
classe
déclarée
final
ne
peut
pas
être
sous-classée
.

Une
méthode
déclarée
final
ne
peut
pas
être
redéfinie
dans
une
sous-classe
.

Une
classe
déclarée
abstract
représente
un
concept
abstrait
:
elle
ne
peut
pas
être
instanciée
et
ne
peut
être
que
sous-classée
.

Une
méthode
déclarée
abstract
est
une
méthode
dont
le
corps
n'
est
pas
spécifié
.

Une
classe
abstraite
peut
contenir
des
méthodes
non
abstraites
,
mais
toute
classe
contenant
une
méthode
abstraite
doit
être
déclarée
abstract
.

si
une
sous-classe
n'
implémente
pas
toutes
les
méthodes
abstraites
de
sa
super-classe
,
elle
doit
être
déclarée
abstract
.

9.7
Interfaces
Une
interface
(
au
sens
du
langage
Java
,
cf
section
3.3
)
est
un
protocole
de
comportement
qui
peut
être
implanté
par
toute
classe
.

Une
interface
est
en
dehors
de
la
hiérarchie
du
classes
.

Une
interface
se
différencie
principalement
de
une
classe
abstraite
par
ces
caractéristiques
:
-
aucune
méthode
concrète
(
par
opposition
à
abstraite
)
ne
peut
être
définie
dans
une
interface
;
-
une
classe
peut
implémenter
plusieurs
interfaces
.

Tout
comme
on
peut
construire
une
hiérarchie
de
classes
,
on
peut
construire
une
hiérarchie
de
interfaces
.

mais
alors
que
une
classe
ne
peut
étendre
directement
qu'
une
seule
super-classe
,
(
pas
de
héritage
multiple
)
,
une
interface
peut
étendre
directement
plusieurs
super-interfaces
(
héritage
multiple
possible
)
.

Exemple
:
public
interface
List<E>
extends
Collection<E>
{
...
}
Exemple
:
public
interface
Predator
{
boolean
chasePrey(Prey
p
)
;
}
public
interface
Prey
{
boolean
isChasedBy(Predator
p
)
;
}
public
interface
Venomous
{
...
à
public
interface
VenomousPredator
extends
Predator
,
Venomous
{
...
}
public
class
Pet
{
...
}
public
class
Cat
extends
Pet
implements
Predator
{
...
à
public
class
Frog
implements
Predator
,
Prey
{
...
}
10
EXCEPTIONS
Une
exception
est
un
objet
fournissant
des
informations
relatives
à
une
défaillance
du
programme
.

Une
exception
est
générée
dans
chacune
du
situations
suivantes
:
-
condition
de
exécution
anormale
,
comme
par
exemple
:
tentative
de
division
par
zéro
,
mémoire
insuffisante
,
-
exécution
de
une
instruction
throw
Le
paquetage
java
.

lang
définit
nombre
de
classes
de
exception
qui
couvrent
les
cas
les
plus
courants
.

10.1
Exceptions
contrôlées
et
non
contrôlées
Toute
exception
est
une
instance
de
la
classe
Throwable
ou
une
de
ses
sous-classes
:
Object
Throwable
Error
Exception
MyCheckedException
RunTimeException
MyUncheckedException
Java
divise
les
classes
de
exception
en
deux
catégories
:
-
Les
exceptions
non
contrôlées
(
unchecked
)
.

Ces
exceptions
concernent
les
cas
"
imprévus
"
,
c'est-à-dire
les
situations
où
il
ne
devrait
pas
y
avoir
de
défaillance
en
fonctionnement
normal
.

Elles
concernent
des
situations
qui
pourraient
être
raisonnablement
évitées
(
exemple
:
un
indice
de
tableau
hors
limite
)
.

Ces
exceptions
indiquent
généralement
une
erreur
de
programme
.

Elles
ont
normalement
vocation
à
conduire
à
un
arrêt
immédiat
et
définitif
du
programme
.

-
Les
exceptions
contrôlées
(
checked
)
.

Ces
exceptions
concernent
les
cas
"
prévus
"
,
c'est-à-dire
les
situations
où
le
programmeur
devrait
s'
attendre
à
ce
qu'
une
opération
puisse
échouer
.

Elles
concernent
des
situations
de
défaillance
qui
sont
au
delà
du
contrôle
du
programmeur
(
exemple
:
un
disque
devenu
plein
rendant
impossible
une
écriture
dans
un
fichier
)
.

Ces
exceptions
ont
normalement
vocation
à
être
récupérées
pour
permettre
au
programme
de
se
poursuivre
normalement
.

La
gestion
de
une
exception
contrôlée
impose
l'
utilisation
de
la
clause
throws
et
de
l'
instruction
de
contrôle
try
.
.
catch
.

Les
exceptions
non
contrôlées
sont
les
classes
RuntimeException
,
Error
et
leurs
sous-
classes
;
toutes
les
autres
classes
et
sous-classes
sont
des
exceptions
contrôlées
.

10.2
Classes
de
exception
standard
10.2.1
La
hiérarchie
Error
La
classe
Error
est
la
super-classe
de
une
hiérarchie
de
erreurs
graves
non
contrôlées
.

Cette
hiérarchie
est
habituellement
réservée
au
erreurs
de
exécution
système
.

Exemples
de
sous-
classes
prédéfinies
:
NoSuchMethodError
StackOverFlowError
OutOfMemoryError
IllegalAccessError
10.22
La
hiérarchie
Exception
La
classe
Exception
est
la
super-classe
de
une
hiérarchie
de
exceptions
,
exclusion
faite
de
la
sous-hiérarchie
RuntimeException
,
contrôlées
.

Exemples
de
sous-classes
de
exceptions
contrôlées
prédéfinies
:
DataFormatException
IOException
EOFException
FileNotFoundException
10.23
La
hiérarchie
RuntimeException
La
classe
RuntimeException
est
la
super-classe
de
une
hiérarchie
de
exceptions
non
contrôlées
.

Exemples
de
sous-classes
prédéfinies
:
ArithmeticException
IllegalArgumentException
NumberFormatException
IllegalStateException
IndexOutOfBoundsException
NullPointerException
10.3
Lancement
de
une
exception
L'
instruction
throw
permet
de
lancer
une
exception
.

Il
est
recommandé
de
ne
l'
appliquer
qu'
à
des
exceptions
non
contrôlées
.

Syntaxe
:
throw
new
ClassOfException(
"
diagnostic
message
to
print
"
)
;
Exemple
:
if
(
key
çù
null
)
{
throw
new
NullPointerException("null
key
found
in
method
x
"
)
;
}
Exemple
:
if
(
key
==
0
)
{
throw
new
IllegalArgumentException("empty
key
received
"
)
;
}
Exemple
(
dans
un
constructeur
)
:
if
(
this.name.length()
çù
0
)
{
throw
new
IllegalStateException(
"
name
must
be
provided
-
"
+
"
object
creation
aborted
"
)
;
}
Exemple
.

L'
opération
remove()
de
l'
interface
Iterator
est
spécifiée
optionnelle
,
c'est-à-dire
que
son
implémentation
pourrait
être
dans
ce
cas
:
public
void
remove()
{
throw
new
UnsupportedOperationException()
;
}
10.4
Capture
de
une
exception
La
capture
de
une
exception
n'
est
obligatoire
que
pour
les
exceptions
que
l'
on
veut
contrôler
.

Dans
le
cas
du
exceptions
contrôlées
,
le
compilateur
renforce
ses
contrôles
à
la
foi
dans
la
méthode
qui
lance
une
telle
exception
et
dans
l'
appelant
de
cette
méthode
.

10.41
Clause
throws
Une
clause
throws
est
une
déclaration
ajoutée
à
l'
en-tête
de
une
méthode
susceptible
de
lever
une
exception
contrôlée
.

Elle
déclare
les
exceptions
contrôlées
à
prendre
en
compte
dans
le
cadre
de
cette
méthode
.

Ceci
est
nécessaire
pour
que
le
compilateur
puisse
savoir
quelles
exceptions
contrôler
.

Par
convention
,
les
exceptions
non
contrôlées
ne
devraient
pas
être
incluses
dans
une
clause
throws
.

Syntaxe
:
throws
ExceptionClass1
,
ExceptionClass2
,
...
Exemple
:
public
void
saveToFile(String
filename
)
throws
IOException
{
...
}
10.42
Instruction
try
.
.
catch
L'
instruction
try
.
.
catch
permet
de
capturer
une
exception
générée
par
l'
appel
de
une
méthode
.

Quand
une
exception
est
générée
,
le
contrôle
est
transféré
du
code
qui
a
généré
l'
exception
à
la
clause
catch
qui
a
capturé
l'
exception
.

La
clause
catch
doit
avoir
un
seul
paramètre
formel
.

Le
type
de
ce
paramètre
doit
être
la
classe
Throwable
ou
une
de
ses
sous-classes
.

Une
instruction
try
peut
contenir
plusieurs
blocs
catch
.

Dans
ce
cas
,
l'
exception
la
plus
générale
doit
être
traitée
en
dernier
.

Syntaxe
:
try
{
//
protect
one
or
more
statement
here
}
catch
(
ExceptionClass
e
)
{
//
report
and
recover
from
the
exception
here
à
finally
à
//
in
fine
,
in
any
case
,
always
execute
these
statements
à
Le
bloc
finally
est
optionnel
,
mais
il
permet
souvent
de
éviter
la
duplication
de
code
.

Exemple
(
à
partir
de
la
plate-forme
5.0
)
:
//
Read
a
double
from
the
standard
input
stream
Scanner
input
à
new
Scanner(System.in)
;
double
x
;
try
{
x
=
input.nextDouble()
;
à
catch(InputMismatchException
e
)
à
System.err.println("Error
-
Double
waited
-
"
p
e
)
;
}
input.close()
;
Exemple
(
à
partir
de
la
plate-forme
5.0
)
:
//
Create
a
copy
of
a
text
file
Scanner
in
=
null
;
PrintWriter
out
=
null
;
try
à
in
=
new
Scanner(new
File(inputFileName))
;
out
=
new
PrintWriter(outputFileName)
;
while
(in.hasNext())
{
out.println(in.nextLine())
;
}
}
catch
(
Exception
e
)
{
System.err.println("Error
in
reading/writing
file
-
"
+
e
)
;
}
finally
à
if
(
in
!

=
null
)
in.close())
;
if
(
out
!

=
null
)
out.close()
;
}
Exemple
(
à
partir
de
la
plate-forme
5.0
)
:
//
Read
and
print
a
text
file
of
doubles
Scanner
in
=
null
;
try
à
in
=
new
Scanner(new
File(inputFileName))
;
while(in.hasNext())
{
System.out.println(Double.parseDouble(in.next()))
;
}
}
catch
(
FileNotFoundException
e
)
{
System.err.println("Unable
to
open
the
input
file
.
"

p
e
)
;
}
catch
(
NumberFormatException
e
)
à
System.err.println("A
token
is
not
a
double
.
"

p
e
)
;
}
catch
(
Exception
e
)
'
System.err.println("Problem
in
reading
the
file
"
p
e
)
;
}
finally
à
if
(
in
!

=
null
)
{
try
à
in.close()
;
}
catch
(
Exception
e
)
{
System.err.println("Error
in
closing
the
file
.
"

p
e
)
;
}
}
10.5
Définir
une
nouvelle
classe
de
exception
Une
du
principales
raisons
conduisant
à
la
définition
de
une
nouvelle
classe
de
exception
est
le
besoin
de
inclure
des
informations
complémentaires
dans
l'
objet
exception
afin
de
permettre
le
diagnostic
et
la
récupération
de
l'
erreur
.

Toute
nouvelle
classe
de
exception
sera
définie
comme
sous-classe
de
une
classe
de
exception
existante
de
la
hiérarchie
Exception
.

Exemple
:
public
class
WrongValueException
extends
Exception
à
private
String
key
;
public
WrongValueException(String
key
)
{
this.key
=
key
;
}
public
String
getKey()
à
return
key
;
}
public
String
toString()
à
return
"
Wrong
value
"
p
key
p
"
found
"
;
}
}
11
ANNEXE
1
-
PROGRAMMATION
GRAPHIQUE
Références
:
Bases
de
Swing
et
exemples
de
programmation
de
interfaces
graphiques
:
java.sun.com/docs/books/tutorial/uiswing/mini/index.html
Gestion
du
événements
et
exemples
de
programmation
:
java.sun.com/docs/books/tutorial/uiswing/events/api.html
Swing
Architecture
Overview
java.sun.com/products/jfc/isc/articles/architecture
Ce
chapitre
introduit
à
la
programmation
graphique
avec
la
bibliothèque
javax.swing
11.1
Swing
Il
existe
deux
grands
paquetages
de
utilitaires
Java
pour
réaliser
des
interfaces
graphiques
:
-
AWT
(
Abstract
Window
Toolkit
)
:
le
paquetage
primitif
.

Les
composants
de
ce
paquetage
s'
importent
par
:
import
java.awt.*
;
-
Swing
:
le
plus
récent
et
le
plus
évolué
,
construit
sur
AWT
,
c'
est
le
paquetage
recommandé
.

Les
composants
de
ce
paquetage
s'
importent
par
:
import
javax.swing.*
;
Les
deux
paquetages
Swing
les
plus
communément
utilisés
sont
:
javax.swing
javax.swing.event
Les
classes
de
javax.swing
les
plus
courantes
sont
:
JFrame
JPanel
JLabel
JTextField
JButton
JOPtionPane
Exemple
de
saisie
/
affichage
dans
une
boîte
de
dialogue
:
//
import
javax.swing.JOptionPane
;
//
use
method
showInputDialog
to
prompt
for
some
input
String
inputValue
à
JOptionPane.showInputDialog("Value
?

"
)
;
//
use
method
showMessageDialog
to
display
a
message
JOptionPane.showMessageDialog(null,"A
message
...
"
)
11.2
Conteneurs
et
composants
Tout
objet
graphique
est
composé
de
différents
objets
:
des
conteneurs
(
containers
)
et
des
composants
atomiques
,
ces
différents
constituants
étant
organisés
en
une
hiérarchie
de
inclusion
.

Principales
catégories
de
conteneurs
et
composants
:
p
les
conteneurs
de
plus
haut
niveau
Pour
que
un
objet
graphique
puisse
être
affiché
à
l'
écran
,
la
hiérarchie
de
ses
constituants
doit
nécessairement
avoir
pour
racine
l'
un
du
trois
conteneurs
suivants
:
à
Frame
(
classe
JFrame
)
:
conteneur
le
plus
général
,
il
fournit
la
fenêtre
principale
dans
laquelle
les
autres
composants
Swing
pourront
se
dessiner
.

à
Dialog
(
classe
JDialog
)
:
plus
limité
que
un
Frame
,
il
fournit
une
fenêtre
de
dialogue
;
la
classe
J0ptionPane
permet
de
créer
des
fenêtres
de
dialogue
simples
et
standard
;
la
classe
JDialog
permet
de
créer
des
fenêtres
de
dialogue
personnalisées
.

à
Applet
(
classe
JApplet
)
:
spécialisé
pour
des
interfaces
web
,
il
fournit
une
fenêtre
qui
sera
affichée
par
un
navigateur
web
.

p
les
conteneurs
intermédiaires
,
notamment
:
à
Panel
(
classe
JPanel
)
:
simplifie
le
positionnement
du
objets
graphiques
atomiques
.

Tout
conteneur
de
haut
niveau
contient
un
conteneur
intermédiaire
spécial
appelé
ContentPane
.

C'
est
le
conteneur
intermédiaire
principal
.

Il
contient
typiquement
un
ou
plusieurs
panels
.

p
les
composants
atomiques
,
par
exemple
:
>
Button
(
classe
JButton
)
>
Label
(
classe
JLabel
)
>
Text
field
(
classe
JTextField
)
sauf
pour
les
conteneurs
de
plus
haut
niveau
,
tous
les
composants
(
conteneur
intermédiaire
ou
composant
atomique
)
qui
commencent
par
J
héritent
de
la
classe
JComponent
.

Pour
ajouter
un
objet
à
un
conteneur
,
on
utilise
une
méthode
add
.

Cette
méthode
prend
en
général
un
deuxième
argument
qui
spécifie
la
mise
en
page
.

Exemple
:
//
import
javax.swing.*
;
frame
=
new
JFrame(
.

.

.
)
;
pane
=
new
JPanel()
;
button
=
new
JButton(
.

.

.
)
;
label
=
new
JLabel(
.

.

.
)
;
pane.add(button)
;
pane.add(1abel)
;
frame.getContentPane().add(pane
,
BorderLayout.CENTER
)
;
frame.pack()
;
//
size
at
or
above
preferred
size
frame.setVisible(true)
;
//
l'
objet
frame
ainsi
créé
a
pour
hiérarchie
:
JFrame
ContentPane
JPanel
JButton
JLabel
Exemple
:
import
javax.swing.JApplet
;
public
class
AppletExample
extends
JApplet
{
public
void
init
)
{
JPanel
pane
=
new
JPanel()
;
pane.add(new
JLabel("Hello
,
World
!

"
)
;
this.setContentPane(pane)
;
11.3
Gestion
de
la
mise
en
page
La
mise
en
page
(
layout
)
consiste
à
fixer
la
taille
et
la
position
du
composants
.

Tout
conteneur
possède
un
gestionnaire
de
mise
en
page
par
défaut
.

si
il
ne
convient
pas
,
on
peut
le
remplacer
.

Les
composants
peuvent
solliciter
une
taille
et
un
alignement
donnés
,
mais
,
in
fine
,
c'
est
le
gestionnaires
de
mise
en
page
du
conteneur
qui
conserve
la
décision
finale
.

Il
existe
6
gestionnaires
de
mise
en
page
:
+
BorderLayout
:
gestionnaire
de
mise
en
page
par
défaut
pour
tout
ContentPane
;
définit
5
zones
de
placement
:
NORTH
,
SOUTH
,
EAST
,
WEST
,
CENTER
p
FlowLayout
:
gestionnaire
de
mise
en
page
par
défaut
pour
tout
JPanel
;
positionne
simplement
les
composants
de
gauche
à
droite
,
passant
à
une
nouvelle
ligne
si
nécessaire
p
BoxLayout
:
gestionnaire
de
mise
en
page
très
flexible
;
positionne
les
composants
sur
une
seule
ligne
ou
colonne
en
respectant
les
attentes
de
composants
en
matière
de
taille
maximale
et
de
alignement
p
GridLayout
:
gestionnaire
de
mise
en
page
très
simple
;
crée
un
ensemble
de
composants
de
même
taille
et
les
affiche
dans
le
nombre
de
lignes
et
de
colonnes
spécifié
p
GridBagLayout
:
gestionnaire
de
mise
en
page
le
plus
sophistiqué
et
le
plus
flexible
;
aligne
les
composants
en
les
plaçant
dans
une
grille
de
cellules
,
permettant
à
certains
de
s'
étendre
sur
plusieurs
cellules
(
les
largeurs
du
rangées
et
les
hauteurs
du
colonnes
,
respectivement
,
peuvent
être
différentes
)
p
CardLayout
:
gestionnaire
de
mise
en
page
pour
usage
spécial
;
permet
de
implémenter
une
zone
qui
contient
différents
composants
à
différents
moments
;
utilisé
en
combinaison
avec
d'
autres
gestionnaires
de
mise
en
page
Exemple
de
changement
du
gestionnaire
de
mise
en
page
par
défaut
:
JPanel
pane
à
new
JPanel()
;
pane.setLayout(new
BorderLayout())
;
La
taille
et
l'
alignement
de
un
composant
peut
être
spécifié
par
les
méthodes
suivantes
:
setMinimumSize
,
setPreferredSize
,
setMaximumSize
,
setAlignmentX
,
setAlignmentY
.

11.4
Gestion
du
événements
11.4.1
Notion
de
événement
à
chaque
foi
que
l'
utilisateur
agit
sur
le
clavier
ou
la
souris
,
un
événement
survient
,
un
objet
événement
est
généré
.

Un
objet
événement
est
un
objet
contenant
des
informations
sur
la
source
et
la
nature
de
l'
événement
survenu
.

Swing
offre
des
interfaces
(
au
sens
Java
)
appelées
"
écouteurs
de
événements
"
(
event
listeners
)
qui
permettent
de
capter
les
événements
de
façon
sélective
afin
de
pouvoir
les
traiter
.

Event
Source
Event
object
Event
listener
Event
listener
Event
listener
Exemple
de
événement
Type
de
Listener
Clic
de
un
bouton
graphique
ou
enfoncement
de
la
touche
return
ActionListener
lors
de
une
saisie
dans
un
champ
texte
Fermeture
de
une
fenêtre
WindowListener
graphique
(
frame
)
Clic
de
la
souris
lors
du
passage
du
curseur
sur
un
composant
MouseListener
graphique
Afin
de
faciliter
le
travail
du
programmeur
,
Swing
associe
généralement
à
chaque
interface
Listener
une
classe
adaptateur
(
Adapter
)
.

si
cet
adaptateur
existe
,
c'
est
avec
lui
que
l'
on
travaille
.

Exemple
de
interface
Listener
Classe
Adapter
associée
ActionListener
None
WindowListener
WindowAdapter
MouseListener
MouseAdapter
KeyListener
KeyAdapter
11.4.2
Réaliser
un
gestionnaire
de
événement
Réaliser
un
gestionnaire
de
événement
(
event
handler
)
requiert
trois
éléments
de
code
:
+
déclarer
une
classe
gestionnaire
de
événement
:
cette
classe
doit
implémenter
une
interface
Listener
ou
étendre
une
classe
Adapter
Exemple
:
import
java.awt.event.*
;
public
class
MyClass
implements
ActionListener
{
.

.

.

à
p
définir
dans
cette
classe
gestionnaire
de
événement
les
méthodes
de
l'
interface
Listener
Exemple
:
public
void
actionPerformed(ActionEvent
e
)
{
.
.
.

}
p
définir
une
instance
de
cette
classe
gestionnaire
de
événement
et
l'
enregistrer
sur
le(s)
composant(s)
concerné(s)
Exemple
:
someComponent.addActionListener(instanceOfMyClass)
;
Le
type
ActionListener
permet
de
définir
les
gestionnaires
de
événement
les
plus
simples
et
les
plus
communs
.

Lorsqu'
un
événement
de
ce
type
est
généré
(
clic
de
un
bouton
graphique
ou
enfoncement
de
la
touche
return
lors
de
une
saisie
dans
un
champ
texte
)
,
un
message
actionPerformed
est
envoyé
à
tous
les
écouteurs
de
événements
qui
sont
enregistrés
sur
le
composant
concerné
.

Une
classe
gestionnaire
de
événement
est
généralement
implantée
sous
la
forme
de
une
classe
interne
(
inner
class
)
au
sein
de
une
classe
graphique
.

Exemple
:
//
Ecriture
de
un
MouseListener
public
class
myClass
extends
JPanel
{
...
someObject.addMouseListener
(
new
MyAdapter())
;
...
class
MyAdapter
extends
MouseAdapter
{
public
void
mouseClicked(MouseEvent
e
)
{
...
}
}
}
Typiquement
,
une
classe
gestionnaire
de
événement
est
implantée
sous
la
forme
de
une
classe
interne
anonyme
.

Exemple
(
solution
équivalente
à
celle
de
l'
exemple
précédent
)
:
//
Ecriture
de
un
MouseListener
public
class
myClass
extends
JPanel
{
...
someObject.addMouseListener(new
MouseAdapter()
{
public
void
mouseClicked(MouseEvent
e
)
{
...
}
}
)
;
...
}
11.5
Affichage
/
fermeture
de
une
fenêtre
graphique
L'
affichage
/
le
masquage
de
une
fenêtre
graphique
de
type
JFrame
se
commande
par
la
méthode
setVisible
.

Quand
l'
utilisateur
ferme
une
fenêtre
graphique
de
type
JFrame
,
cette
fenêtre
n'
est
en
fait
,
par
défaut
,
que
masquée
.

Quoiqu'
invisible
,
l'
objet
graphique
existe
toujours
et
le
programme
peut
à
nouveau
le
rendre
visible
.

si
l'
on
désire
un
comportement
différent
,
il
est
nécessaire
:
-
soit
de
enregistrer
sur
cet
objet
graphique
un
gestionnaire
de
événement
de
type
WindowListener
et
de
capter
le
message
windowClosing
-
soit
de
spécifier
le
comportement
par
défaut
en
utilisant
la
méthode
setDefaultCloseOperation
.

Le
comportement
est
indiqué
en
argument
par
une
constante
(
définie
dans
l'
interface
WindowConstants
)
.

Exemple
de
argument
:
DISPOSE_ON_CLOSE
11.6
Architecture
du
composants
Swing
Objectif
:
des
applications
facilement
adaptables
.

L'
architecture
du
composants
Swing
est
basée
sur
une
adaptation
de
la
très
renommée
architecture
MVC
(
"
Modèle-Vue-Contrôleur
"
;
voir
section
13.2
)
.

Dans
la
communauté
Swing
,
elle
est
appelée
"
Architecture
à
modèle
séparable
"
:
La
partie
Modèle
de
un
composant
Swing
(
partie
qui
représente
les
données
de
l'
application
)
est
traitée
comme
un
élément
séparé
,
tout
comme
le
préconise
la
conception
MVC
;
mais
Swing
fusionne
les
parties
Vue
(
qui
prend
en
charge
la
représentation
visuelle
du
données
)
et
Contrôleur
(
qui
traite
les
entrées
utilisateur
)
de
chaque
composant
en
un
seul
objet
interface
utilisateur
(
User
Interface
Object
)
.

Il
est
en
général
considéré
comme
une
bonne
pratique
de
centrer
l'
architecture
de
une
application
autour
de
ses
données
plutôt
que
autour
de
son
interface
utilisateur
.

Pour
supporter
ce
paradigme
[
1
]
,
Swing
définit
une
interface
Modèle
séparée
pour
chaque
composant
.

Cette
séparation
fournit
au
programme
de
application
la
possibilité
de
connecter
facilement
des
composants
Swing
dans
son
implémentation
modèle
propre
.

La
table
suivante
montre
les
interfaces
Modèles
offertes
par
les
composants
Swing
:
Component
Model
Interface
Model
Type
JButton
ButtonModel
Gui
JToggleButton
ButtonModel
GUI/data
JCheckBox
ButtonModel
GUI/data
JRadioButton
ButtonModel
GUI/data
JMenu
ButtonModel
Gui
JMenuItem
ButtonModel
Gui
JCheckBoxMenuItem
ButtonModel
GUI/data
JRadioButtonMenuItem
ButtonModel
GUI/data
JComboBox
ComboBoxModel
Data
JProgressBar
BoundedRangeModel
GUI/data
JScrollBar
BoundedRangeModel
GUI/data
Slider
BoundedRangeModel
GUI/data
Component
Model
Interface
Model
Type
JTabbedPane
SingleSelectionModel
Gui
JList
ListModel
Data
JList
ListSelectionModel
Gui
JTable
TableModel
Data
JTable
TableColumnModel
Gui
JTree
TreeModel
Data
JTree
TreeSelectionModel
Gui
JEditorPane
Document
Data
JTextPane
Document
Data
JTextArea
Document
Data
JTextField
Document
Data
JPasswordField
Document
Data
Les
interfaces
Modèles
fournies
par
Swing
relèvent
de
deux
grandes
catégories
:
les
types
"
Etat
de
l'
interface
graphique
"
(
Gui
)
,
qui
définissent
le
statut
visuel
du
commandes
de
l'
interface
graphique
;
et
les
types
"
Données
de
application
"
(
Data
)
,
qui
représentent
des
données
quantifiables
ayant
sens
pour
l'
application
.

Certains
modèles
relèvent
de
types
partagés
(
GUI/data
)
.

Il
est
recommandé
de
utiliser
la
catégorie
"
Données
de
application
"
(
Data
)
du
modèles
de
Swing
car
ils
renforcent
grandement
l'
adaptabilité
et
la
modularité
du
applications
sur
le
long
terme
.

[
1
]
Un
paradigme
est
une
vision
du
monde
qui
repose
sur
un
modèle
.

11.7
Applets
Java
permet
de
créer
deux
types
de
programmes
:
-
du
applications
,
qui
s'
exécutent
directement
sous
le
contrôle
de
la
machine
virtuelle
Java
-
du
appliquettes
(
ou
applettes
;
en
anglais
:
applets
)
destinées
à
être
exécutées
par
un
navigateur
Web
Pour
réaliser
une
applette
,
le
minimum
consiste
à
:
-
créer
une
sous-classe
de
la
classe
JApplet
(
voir
section
11.2
)
-
y
créer
la
méthode
init()
,
qui
sera
lancée
par
le
navigateur
-
référencer
cette
classe
dans
la
balise
<APPLET
Codeë
...
>
de
un
fichier
HTML
Syntaxe
:
import
javax.swing.JApplet
;
public
class
AppletClassName
extends
JApplet
à
//
...
Fields
...
public
void
init
)
{
;
...
}
}
Syntaxe
:
<APPLET
CODE="AppletClassName.class
"
WIDTH=anint
HEIGHT=anint
>
</APPLET>
12
ANNEXE
2
-
THREADS
Références
:
Programmation
concurrente
,
processus
,
threads
java.sun.com/docs/books/tutorial/essential/concurrency/procthread.html
Les
threads
permettent
de
programmer
des
tâches
qui
,
à
l'
intérieur
de
un
même
programme
,
s'
exécuteront
concurremment
.

Ce
sont
des
processus
légers
.

La
tâche
à
exécuter
par
un
thread
doit
être
implémentée
dans
une
méthode
run(
)
.

Il
existe
deux
façons
de
fournir
la
méthode
run()
:
-
définir
une
sous-classe
de
la
classe
Thread
et
y
redéfinir
la
méthode
run()
-
définir
une
classe
qui
implémente
l'
interface
Runnable
et
y
définir
la
méthode
run()
12.1
Créer
un
thread
par
extension
de
la
classe
Thread
Exemple
:
//
Example
of
defining
a
thread
as
extending
Thread
public
class
SimpleThread
extends
Thread
{
public
SimpleThread(String
threadName
)
{
super
(
threadName
)
;
}
//
The
task
of
this
thread
is
to
print
10
times
its
name
//
at
a
random
rate
public
void
run()
à
for
(
int
i
=
0
;
i
<
10
;
iu
)
{
System.out.println(i
p
"
"
p
getName())
;
try
{
sleep((long)
(
Math.random()
*
1000
)
)
;
}
catch
(
InterruptedException
e
)
{
}
à
System.out.println("DONE
!

"
"
+
getName())
;
}
}
//
end
class
SimpleThread
//
Example
of
running
two
threads
concurrently
.

//
"
Jamaica
"
and
"
fiji
"
Will
be
printed
randomly
10
times
.

public
static
void
main
(
String[
]
args
)
{
new
SimpleThread("Jamaica").start()
;
new
SimpleThread("Fiji").start()
;
}
12.2
Créer
un
thread
par
implémentation
de
l'
interface
Runnable
Cette
façon
de
faire
s'
impose
lorsque
la
classe
à
créer
doit
sous-classer
une
classe
quelconque
(
le
cas
typique
étant
une
Applet
)
,
parce
que
Java
ne
supporte
pas
l'
héritage
multiple
.

Exemple
:
//
Example
of
defining
a
thread
as
implementing
Runnable
public
class
SimpleThread
implements
Runnable
{
String
threadName
;
public
SimpleThread(String
threadName
)
{
this.threadName
=
threadName
;
}
//
The
task
of
this
thread
is
to
print
10
times
its
name
//
at
a
random
rate
public
void
run()
à
for
(
int
i
=
0
;
i
<
10
;
iu
)
{
System.out.println(i
p
"
"
p
threadName
)
;
try
{
Thread.sleep((long)
(
Math.random()
*
1000
)
)
;
}
catch
(
InterruptedException
e
)
{
}
à
System.out.println("DONE
!

"
p
threadName
)
;
}
}
//
end
class
SimpleThread
//
Example
of
running
two
threads
concurrently
//
(
"
Jamaica
"
and
"
fiji
"
Will
be
printed
randomly
10
times
)
public
static
void
main
(
String[
]
args
)
{
new
Thread(new
SimpleThread("Jamaica")).start()
;
new
Thread(new
SimpleThread("Fiji")).start()
;
}
12.3
Synchronisation
et
communication
entre
threads
12.3.1
Sections
critiques
et
synchronisation
Dans
un
programme
,
des
segments
de
code
qui
accèdent
à
une
même
donnée
depuis
des
threads
concurrents
sont
appelés
sections
critiques
.

Lorsque
deux
threads
concurrents
invoquent
des
méthodes
qui
opèrent
sur
une
même
donnée
partagée
(
méthodes
critiques
)
,
il
est
nécessaire
que
Java
puisse
synchroniser
ces
méthodes
afin
de
garantir
un
accès
sûr
à
l'
information
.

à
cette
fin
,
chacune
de
ces
méthodes
doit
être
déclarée
avec
le
modificateur
synchronized
.

à
l'
exécution
,
l'
accès
à
la
donnée
partagée
sera
ainsi
automatiquement
verrouillé
tant
que
elle
sera
utilisée
par
une
méthode
critique
.

Exemple
:
get
et
put
sont
supposées
deux
méthodes
critiques
de
l'
objet
partagé
.

public
synchronized
int
get()
{
...
}
public
synchronized
void
put(int
value
)
{
...
}
12.3.2
Communication
entre
threads
Pour
que
deux
threads
,
processus
indépendants
qui
se
déroulent
de
façon
asynchrone
,
puissent
se
communiquer
des
données
,
il
est
nécessaire
que
ils
sachent
se
synchroniser
autour
de
un
sas
de
communication
.

Le
thread
émetteur
de
la
donnée
est
appelé
producteur
;
le
thread
destinataire
de
la
donnée
est
appelé
consommateur
.

Le
thread
producteur
de
la
donnée
doit
être
capable
de
:
-
attendre
que
l'
espace
de
stockage
du
sas
de
communication
soit
libre
;
-
pui
y
déposer
une
nouvelle
donnée
;
-
pui
informer
les
threads
consommateurs
de
la
mise
à
disposition
de
la
donnée
.

de
façon
symétrique
,
le
thread
consommateur
de
la
donnée
doit
être
capable
de
:
-
attendre
que
la
donnée
soit
mise
à
disposition
dans
l'
espace
de
stockage
du
sas
de
communication
;
-
pui
lire
cette
donnée
;
-
pui
informer
les
threads
producteurs
de
la
disponibilité
du
sas
de
communication
ou
leur
accuser
réception
.

C'
est
au
sas
de
communication
qu'
on
confie
la
charge
de
ces
synchronisations
.

La
mise
en
attente
se
réalise
par
la
méthode
wait()
,
la
notification
au
autres
threads
par
les
méthodes
notify()
ou
notifyAll(
)
.

Ces
méthodes
sont
toutes
deux
définies
dans
la
classe
Object(
)
.

Exemple
de
classe
définissant
un
sas
de
communication
de
un
seul
élément
de
type
entier
(
attribut
contents
)
.

y
noter
en
particulier
la
sécurisation
apportée
par
l'
usage
de
un
while
et
non
de
un
if
afin
de
prévenir
de
faux
réveils
éventuels
.

public
class
CubbyHole
à
private
int
contents
;
private
boolean
available
=
false
;
public
synchronized
int
get()
{
//
called
by
Consumer
while
(
available
==
false
)
{
try
à
wait()
;
//
wait
for
Producer
to
put
value
à
catch
(
InterruptedException
e
)
(
)
{
}
}
available
=
false
;
notifyAll()
;
return
contents
;
}
public
synchronized
void
put(int
x
)
{
//
called
by
Producer
while
(
available
çù
true
)
{
try
à
wait()
;
//
wait
for
Consumer
to
get
value
à
catch
(
InterruptedException
e
)
(
)
{
}
}
contents
=
x
;
available
=
true
;
notifyAll()
;
}
13
ANNEXE
3
-
CONCEPTION
ET
DEVELOPPEMENT
EN
Java
Références
:
Architecture
Modèle-Vue-Contrôleur
:
java.sun.com/blueprints/guidelines/designing_enterprise_applications_2e/app-arch/app-arch2.html
Développement
de
tests
unitaires
avec
le
cadre
de
applications
JUnit
:
junit.sourceforge.net/doc/cookbook/cookbook.htm
JavaBeans
:
java.sun.com/products/javabeans/
java.sun.com/docs/books/tutorial/javabeans/index.html
Design
patterns
:
Cette
section
va
au-delà
du
langage
Java
pour
aborder
quelques
aspects
de
la
conception
et
du
développement
de
programmes
Java
.

13.1
Conseils
généraux
pour
une
bonne
conception
du
classes
RECHERCHER
UN
COUPLAGE
FAIBLE
.

Le
couplage
décrit
l'
interconnectivité
entre
les
classes
.

Le
couplage
est
faible
quand
chaque
classe
est
largement
indépendante
du
autres
et
communique
avec
elles
via
une
interface
petite
et
bien
définie
(
l'
interface
de
une
classe
est
la
partie
visible
publique
de
cette
classe
:
elle
se
définit
typiquement
par
la
liste
du
membres
(
attributs
,
constructeurs
,
méthodes
)
non
privés
associés
à
leurs
commentaires
de
documentation
)
.

RECHERCHER
UNE
COHESION
FORTE
.

La
cohésion
décrit
l'
adéquation
entre
une
unité
de
code
et
une
entité
ou
tâche
logique
.

La
cohésion
est
forte
quand
chaque
unité
de
code
(
méthode
,
classe
,
module
,
...
.
.
)
est
responsable
de
une
entité
ou
tâche
très
bien
définie
.

UTILISER
au
Maximum
L'
ENCAPSULATION
.

L'
encapsulation
est
une
technique
de
base
pour
réduire
le
couplage
.

Elle
contribue
à
séparer
le
quoi
et
le
comment
,
la
vue
et
l'
implémentation
,
la
définition
et
l'
utilisation
.

Principe
de
base
:
rendre
les
attributs
privés
et
utiliser
des
méthodes
de
accès
.

DECOUPLER
ENTREES
,
TRAITEMENTS
ET
SORTIES
.

Voir
en
particulier
section
13.2
ADOPTER
UNE
CONCEPTION
DIRIGEE
PAR
LES
RESPONSABILITÉS
.

L'
attribution
du
bonnes
responsabilités
au
bonnes
classes
est
l'
un
du
problèmes
les
plus
délicats
de
la
conception
orientée
objet
.

La
programmation
dirigée
par
les
responsabilités
est
un
processus
de
conception
de
classes
par
attribution
de
responsabilités
bien
définies
à
chaque
classe
.

Cette
approche
peut
être
utilisée
pour
déterminer
quelle
classe
devrait
implémenter
telle
fonctionnalité
.

Une
conception
dirigée
par
les
responsabilités
contribue
à
réduire
le
couplage
.

EVITER
LA
DUPLICATION
de
Code
.

Eviter
que
un
même
segment
de
code
ne
se
retrouve
plus
de
une
foi
dans
une
application
.

UTILISER
L'
HERITAGE
à
BON
ESCIENT
.

L'
héritage
est
une
relation
"
est_un
"
,
pas
une
relation
"
a_un
"
.

Dans
une
hiérarchie
de
héritage
,
les
objets
doivent
avoir
une
relation
"
est_un
"
avec
leur
classe
de
base
,
afin
que
l'
héritage
de
tous
les
attributs
,
propriétés
et
méthodes
de
la
classe
de
base
garde
sens
(
même
si
la
sous-classe
en
spécialise
ou
les
complète
)
.

Les
objets
ne
relevant
pas
strictement
de
une
relation
"
est_un
"
doivent
se
traduire
par
des
classes
ou
interfaces
sans
relation
de
héritage
entre
elles
.

LIMITER
LA
TAILLE
ET
COMPLEXITE
.

Ne
pas
mettre
trop
de
choses
dans
une
méthode
:
une
méthode
est
trop
longue
si
elle
fait
plus
de
une
tâche
logique
.

Ne
pas
tout
mettre
dans
une
seule
classe
:
une
classe
est
trop
complexe
si
elle
représente
plus
de
une
entité
logique
.

CHERCHER
à
FACILITER
du
CHANGEMENTS
LOCALISES
.

Réaliser
des
changements
dans
une
classe
ne
devrait
avoir
qu'
un
minimum
de
impact
sur
les
autres
classes
.

La
localisation
du
changements
est
l'
un
du
buts
recherchés
de
une
bonne
conception
de
classe
.

Elle
est
le
produit
de
un
couplage
faible
et
de
une
cohésion
forte
.

13.2
Architecture
de
une
application
interactive
:
le
modèle
MVC
L'
architecture
Modèle-Vue-Contrôleur
(
Model-View-Controller
,
MVC
)
est
un
modèle
de
architecture
logicielle
recommandé
-
et
largement
utilisé
-
pour
la
conception
de
applications
interactives
.

Ce
modèle
vise
à
minimiser
le
degré
de
couplage
entre
les
objets
de
l'
application
en
découplant
structurellement
entrées
,
traitements
et
sorties
.

Le
point
essentiel
consiste
à
séparer
les
objets
relevant
de
l'
interface
utilisateur
du
objets
métier
,
afin
de
pouvoir
les
faire
évoluer
indépendamment
et
les
réutiliser
.

MVC
organise
une
application
interactive
en
trois
grandes
composantes
:
le
Modèle
,
la
vue
et
le
Contrôleur
,
et
découple
leurs
responsabilités
respectives
:
p
Le
MODELE
encapsule
la
fonctionnalité
et
les
données
coeur
de
l'
application
.

Il
est
indépendant
de
représentations
de
sortie
spécifiques
ou
de
un
comportement
de
entrée
.

Il
a
à
charge
la
représentation
interne
du
données
de
l'
application
et
la
logique
de
gestion
de
ces
données
.

Il
notifie
à
la
composante
Vue
les
changements
de
données
et
lui
permet
de
l'
interroger
sur
son
état
.

Il
fournit
au
contrôleur
la
possibilité
de
accéder
à
certaines
fonctionnalités
applicatives
encapsulées
dans
le
Modèle
.

p
La
VUE
affiche
les
informations
à
l'
utilisateur
.

Elle
récupère
du
Modèle
les
données
à
présenter
à
l'
utilisateur
,
spécifie
leur
présentation
externe
et
met
à
jour
l'
information
affichée
.

Elle
relaie
aussi
au
contrôleur
les
entrées
utilisateur
et
l'
autorise
à
sélectionner
les
vue
.

La
séparation
du
modèle
de
une
part
et
de
la
vue
et
du
contrôleur
de
autre
part
permet
des
vue
multiples
de
un
même
modèle
.

Quand
il
y
a
plusieurs
vue
du
modèle
,
chaque
vue
a
alors
un
contrôleur
associé
.

p
Le
CONTROLEUR
gère
les
entrées
utilisateur
.

Il
reçoit
les
entrées
,
généralement
sous
forme
de
événements
encodant
un
mouvement
de
la
souris
,
l'
activation
de
un
bouton
,
ou
une
entrée
clavier
(
ou
bien
,
si
il
s'
agit
de
une
application
web
,
les
requêtes
HTTP
GET
et
POST
)
.

Les
événements
sont
traduits
en
requêtes
de
service
pour
le
Modèle
ou
la
vue
.

Une
application
a
typiquement
un
contrôleur
pour
chaque
ensemble
de
fonctionnalités
apparentées
.

Une
application
peut
avoir
un
contrôleur
séparé
par
type
de
client
si
les
interactions
utilisateurs
varient
selon
les
types
de
client
.

L'
utilisateur
interagit
avec
le
système
uniquement
au
travers
du
contrôleurs
.

L'
ensemble
Vue
p
Contrôleur
compose
l'
interface
utilisateur
.

Modèle
Interrogation
de
état
Notification
de
changement
Changement
de
état
Vue
Requête
utilisateur
Sélection
de
vue
Contrôleur
invocation
de
méthodes
Evènements
En
pratique
,
ce
schéma
de
principe
laisse
place
à
une
grande
variété
de
implémentations
possibles
.

Une
du
difficultés
pour
une
implémentation
idéale
en
Java
réside
notamment
dans
le
fait
que
les
composants
graphiques
Swing
fusionnent
les
parties
Vues
et
Contrôleur
(
cf
section
11.6
)
.

Pour
les
petits
programmes
tout
particulièrement
,
la
vue
et
le
Contrôleur
sont
souvent
combinés
,
mais
dans
tous
les
cas
le
Modèle
doit
être
séparé
.

Exemple
de
implémentation
de
une
architecture
MVC
:
import
java.util.Observable
;
import
java.util.Observer
;
import
javax.swing.JApplet
;
import
javax.swing.JPanel
;
import
java.awt.event.ActionListener
;
import
java.awt.event.ActionEvent
;
public
class
Controller
extends
JApplet
implements
ActionListener
à
private
View
view
;
private
Model
model
;
public
void
init()
{
model
=
new
Mode1()
;
view
=
new
View(model
,
this
)
;
model.addObserver(view)
;
this.setContentPane
(
view
)
;
}
public
void
actionPerformed(ActionEvent
e
)
à
//
Process
the
events
à
}
public
class
View
extends
JPanel
implements
Observer
à
private
Model
model
;
//
Declare
here
the
JPanel
components
.

public
View(Model
m
,
ActionListener
listener
)
{
model
=
m
;
makeContentPane(listener)
;
}
public
void
update(Observable
o
,
Object
arg
)
{
//
Automatically
called
when
observer
is
notified
.

//
Update
the
view
.

à
public
void
makeContentPane(ActionListener
listener
)
{
//
Create
and
initialize
the
JPanel
components
and
,
//
when
need
be
,
attach
them
the
event
listener
.

//
Define
the
layout
.

}
}
public
class
Model
extends
Observable
à
//
Wherever
the
value
of
an
attribute
interesting
the
//
View
is
changed
,
insert
these
two
statements
//
setChanged()
;
//
notifyObservers()
;
or
notifyObservers(arg)
;
à
Chercher
à
découpler
les
traitements
du
entrées-sorties
est
classique
en
programmation
.

Dans
cet
esprit
,
on
peut
noter
en
particulier
que
le
modèle
MVC
a
une
certaine
similitude
avec
la
classique
architecture
trois-tiers
(
three-tiers
)
du
systèmes
distribués
.

Une
architecture
trois-
tiers
est
une
architecture
logicielle
client-serveur
dans
laquelle
l'
interface
utilisateur
,
la
logique
de
traitement
et
les
données
sont
trois
modules
indépendants
:
l'
interface
utilisateur
est
stockée
dans
le
client
,
le
gros
de
la
logique
de
l'
application
est
stocké
dans
le
ou
les
serveurs
de
application
,
et
les
données
sont
stockées
dans
un
serveur
de
base
de
données
.

Exemple
.

Pour
des
applications
web
professionnelles
reposant
sur
une
solution
Java
Ee
(
voir
chapitre
16
)
,
le
Modèle
est
assuré
par
des
Ejb
et/ou
du
JavaBeans
,
le
Contrôleur
est
assuré
par
des
servlets
,
et
la
vue
par
des
Jsp
(
glossaire
en
chapitre
17
)
.

13.3
Tests
unitaires
13.3.1
Définitions
Le
test
est
une
activité
qui
consiste
à
déterminer
si
un
segment
de
code
(
méthode
,
classe
ou
programme
)
produit
bien
le
résultat
attendu
.

On
définit
classiquement
trois
niveaux
de
tests
,
qui
sont
mis
en
oeuvre
successivement
:
p
Le
test
unitaire
(
unit
testing
)
:
il
s'
agit
de
tester
chaque
composante
individuelle
(
méthode
,
classe
)
de
l'
application
.

p
le
test
de
intégration
(
integration
testing
)
:
il
s'
agit
de
tester
des
groupes
de
classes
en
interrelations
pui
toute
l'
application
dans
son
ensemble
.

Les
tests
appliqués
suivent
généralement
un
plan
de
test
(
i.e.
une
approche
systématique
et
méthodique
)
.

p
le
test
système
(
system
testing
)
:
il
s'
agit
de
tester
l'
application
intégrée
dans
son
environnement
de
utilisation
complet
.

Ces
tests
entrent
dans
la
catégorie
du
tests
boîtes
noires
,
et
,
en
tant
que
tels
,
ne
devraient
pas
nécessiter
de
connaissance
de
la
conception
interne
du
code
ou
de
sa
logique
.

Les
considérations
suivantes
se
limiteront
essentiellement
au
tests
unitaires
.

Un
cas
de
test
est
un
ensemble
de
conditions
ou
variables
à
partir
desquelles
un
testeur
déterminera
si
une
exigence
requise
est
complètement
ou
partiellement
satisfaite
.

Un
cas
de
test
est
caractérisé
par
une
entrée
connue
(
pré-condition
)
et
une
sortie
attendue
(
post-
condition
)
.

De
nombreux
cas
de
tests
peuvent
être
nécessaires
pour
vérifier
une
exigence
donnée
.

On
distingue
généralement
deux
types
de
cas
de
test
:
-
les
cas
de
test
positifs
,
qui
consistent
à
tester
des
cas
censés
faire
réussir
la
fonctionnalité
.

Ces
tests
doivent
nous
convaincre
que
l'
élément
de
code
testé
fonctionne
bien
comme
espéré
.

-
les
cas
de
test
négatifs
,
qui
consistent
à
tester
des
cas
censés
mettre
en
échec
la
fonctionnalité
.

Ce
sont
toutes
les
situations
de
valeurs
hors
limites
,
de
erreurs
,
...
.

Exemples
:
entrer
une
valeur
hors
plage
,
lire
un
ensemble
vide
,
...
.

Dans
de
tels
cas
,
nous
devons
nous
attendre
à
ce
que
le
programme
traite
l'
erreur
de
une
façon
contrôlée
et
appropriée
.

La
simple
correction
du
erreurs
détectées
par
un
test
devrait
systématiquement
améliorer
la
qualité
du
programme
.

Malheureusement
,
l'
expérience
montre
que
tout
changement
dans
le
programme
peut
introduire
,
de
façon
inattendue
,
d'
autres
erreurs
.

En
particulier
du
erreurs
de
régression
(
regression
bug
)
:
une
erreur
de
régression
survient
quand
une
fonctionnalité
qui
fonctionnait
précédemment
ne
fonctionne
plus
suite
à
une
modification
du
programme
.

Une
méthode
courante
de
test
de
non-régression
(
non-regression
testing
)
consiste
à
réexécuter
les
tests
réalisés
antérieurement
et
voir
si
des
défauts
apparaissent
voire
réapparaissent
.

Les
tests
devant
donc
être
appliqués
non
pas
une
seule
foi
mais
à
chaque
modification
du
logiciel
,
il
est
souhaitable
de
disposer
de
une
batterie
de
tests
programmés
afin
de
permettre
une
automatisation
du
test
.

Il
s'
agit
donc
de
programmer
des
cas
de
test
pour
chaque
méthode
non
triviale
,
en
veillant
à
ce
que
chaque
cas
de
test
soit
bien
séparé
du
autres
.

13.3.2
JUnit
JUnit
,
développé
par
la
communauté
open
source
,
offre
un
cadre
de
applications
(
framework
)
pour
la
programmation
de
tests
de
régression
.

Il
est
utilisé
pour
implémenter
des
tests
unitaires
en
Java
.

La
classe
TestCase
permet
de
définir
un
cas
de
test
;
la
classe
Assert
fournit
un
ensemble
de
méthodes
facilitant
la
gestion
du
erreurs
détectées
;
la
classe
TestSuite
permet
de
exécuter
une
suite
de
tests
;
la
classe
TestRunner
est
un
outil
de
exploitation
permettant
de
définir
une
suite
de
tests
à
exécuter
et
de
afficher
les
résultats
.

Exemple
de
cas
de
test
:
/**
*
à
test
case
for
the
class
MyClass
à
import
junit.framework.*
;
public
class
TestMyClass
extends
TestCase
à
/*
The
tests
need
to
run
against
the
background
of
à
known
*
set
of
objects
.

This
set
of
objects
is
called
à
test
*
fixture
.

*
Define
here
an
instance
variable
for
each
part
of
the
*
fixture
.

*/
private
MyClass
myObject
;
public
TestMyClass(String
name
)
à
super
(
name
)
;
}
/**
*
Sets
up
the
test
fixture
.

*
setUp()
is
called
before
every
test
case
method
.

*
Initializes
the
instance
variables
.

*/
protected
void
setUp()
{
myObject
=
new
MyClass(
.

.

.

)
;
}
/**
*
Tears
down
the
test
fixture
.

*
tearDown()
is
called
after
every
test
case
method
.

*
Releases
any
permanent
resources
allocated
in
setUp
*
(
example
:
closes
files
,
...
)
*/
protected
void
tearDown()
à
//
...
}
//
Once
the
fixture
is
in
place
,
as
many
Test
Cases
as
//
necessary
can
be
written
.

/**
*
Tests
the
method
methodX()
*/
public
void
testMethodX()
{
ArgumentType
argument
=
.

.

.

;
ResponseType
expectedResponse
=
.

.

.

;
String
errorMessage
=
"
.

.

.

"
;
assertTrue(errorMessage
,
expectedResponse.equals(MethodX(argument))
;
}
}
//
end
class
TestMyClass
JUnit
détermine
le
succès
où
l'
échec
de
un
test
via
des
instructions
de
assertion
.

Une
assertion
est
simplement
une
procédure
de
comparaison
entre
une
valeur
espérée
et
une
valeur
effective
et
qui
génère
un
échec
en
cas
de
différence
.

Les
procédures
de
assertion
disponibles
sont
définies
dans
la
classe
junit.framework.Assert
.

Exemples
de
instructions
de
assertion
:
assertTrue(
errorMessage
,
booleanCondition
)
;
assertFalse(
errorMessage
,
booleanCondition
)
;
assertEquals(
errorMessage
,
expectedValue
,
actualValue
)
;
assertEquals(
errorMessage
,
doubleExpected
,
doubleActual
,
doubleDelta
)
;
Pour
exécuter
le
test
,
créer
une
instance
de
cette
classe
avec
en
paramètre
le
nom
de
la
méthode
de
test
.

Exemple
new
TestMyClass("testMethodX")
;
JUnit
est
intégré
dans
certains
outils
de
développement
.

De
tels
outils
offrent
alors
des
fonctionnalités
qui
permettent
de
créer
facilement
des
tests
.

13.4
Java
Beans
Un
Java
Bean
(
"
grain
java
"
)
est
défini
par
Sun
comme
"
un
composant
réutilisable
Java
destiné
à
être
manipulé
par
un
outil
de
développement
graphique
visuel
"
.

Les
Java
Beans
sont
des
composants
Java
(
i.e.
des
classes
)
respectant
certains
critères
afin
de
pouvoir
être
facilement
développés
,
assemblés
et
réutilisés
pour
créer
des
applications
sophistiquées
.

Par
exemple
,
la
technologie
Java
Beans
est
l'
architecture
du
composants
dans
la
plate-forme
Java
SE
.

Les
obligations
que
doit
respecter
un
Java
Bean
sont
nombreuses
mais
l'
enjeu
est
de
importance
:
disposer
de
composants
"
Write
One
,
Run
Anywhere
"
(
WORA
)
réutilisables
.

Les
Java
Beans
sont
des
classes
publiques
concrètes
qui
ont
pour
caractéristiques
communes
de
:
p
supporter
des
"
propriétés
"
:
les
propriétés
sont
les
attributs
discrets
nommés
de
un
Java
Bean
qui
peuvent
affecter
son
apparence
ou
son
comportement
.

Les
propriétés
sont
pour
les
Java
Beans
l'
équivalent
du
champs
pour
les
objets
.

Par
exemple
,
un
bouton
graphique
pourrait
avoir
une
propriété
nommée
"
label
"
qui
représenterait
le
texte
affiché
dans
le
bouton
.

Les
méthodes
de
accès
au
propriétés
doivent
respecter
des
conventions
de
nommage
particulières
,
par
exemple
:
-
pour
les
propriétés
simples
(
il
en
existe
d'
autres
:
liées
,
contraintes
,
indexées
,
...
)
:
PropertyType
getPropertyName()
;
//
simple
getter
void
setPropertyName(PropertyType)
;
//
simple
setter
-
pour
les
propriétés
booléennes
,
on
utilise
typiquement
is
au
lieu
de
get
p
communiquer
entre
eux
par
événements
:
en
pratique
,
on
utilise
la
technique
Swing
du
"
listeners
"
(
voir
section
11.4
)
;
p
supporter
l'
introspection
:
à
l'
exécution
et
dans
l'
environnement
de
développement
,
on
doit
être
capable
de
déterminer
et
de
analyser
les
propriétés
,
les
événements
et
les
méthodes
que
supporte
un
Java
Bean
.

à
noter
que
cette
propriété
de
introspection
est
déjà
présente
dans
les
objets
Java
puisque
un
objet
peut
être
analysé
grâce
au
classes
Class
,
Method
,
Field
,
p
supporter
la
personnalisation
(
"
customization
"
)
:
les
outils
de
développement
doivent
permettre
de
modifier
l'
apparence
et
le
comportement
de
un
Java
Bean
en
phase
de
conception
;
p
supporter
la
persistance
:
la
persistance
de
un
objet
est
la
capacité
de
le
sauvegarder
sur
un
support
de
stockage
et
de
le
restaurer
à
l'
identique
afin
que
le
programme
puisse
se
terminer
sans
que
cet
objet
soit
perdu
.

Exemple
de
persistance
:
que
un
objet
puisse
prétendre
à
être
un
document
Excel
à
l'
intérieur
de
un
document
Word
.

Le
mécanisme
qui
rend
possible
la
persistance
est
appelé
"
sérialisation
"
(
serialization
)
.

à
cette
fin
,
un
Java
Bean
doit
implémenter
l'
interface
Serializable
ou
Externalizable
.

Exemple
de
Java
Bean
:
package
sunw.demo.simple
;
import
java.awt.*
;
import
java.io.Serializable
;
éùà
*
SimpleBean
wis
be
displayed
with
a
green
*
centered
rectangle
,
but
its
color
may
be
changed
1ater
.

*/
public
class
SimpleBean
extends
Canvas
implements
Serializable
à
private
Color
color
=
Color.green
;
//
Property
getter
method
.

public
Color
getColor(){
return
color
;
}
//
Property
setter
method
.

//
Sets
new
SimpleBean
color
and
repaints
.

public
void
setColor(Color
newColor
)
à
color
à
newColor
;
repaint()
;
}
public
void
paint(Graphics
g
)
à
g.setColor(color)
;
g.fillRect(20
,
5
,
20
,
30
)
;
}
//
Constructor
sets
inherited
properties
public
SimpleBean()
{
setSize(60,40)
;
setBackground(Color.red)
;
}
}
//
end
class
SimpleBean
Pour
être
reconnu
par
un
outil
de
développement
,
un
Java
Bean
doit
être
conditionnné
dans
une
fichier
de
archive
au
format
jar
.

Bien
que
ce
ne
soit
pas
obligatoire
,
il
est
souhaitable
que
les
Java
Beans
soient
des
paquetages
(
évite
notamment
les
conflits
en
cas
de
homonymie
du
beans
)
.

13.5
Design
patterns
Cette
section
n'
est
qu'
une
toute
première
introduction
au
modèles
de
conception
(
design
patterns
)
[
1
]
.

Le
développement
orienté
objet
de
applications
professionnelles
conduit
généralement
à
rencontrer
des
problèmes
de
conception
types
qui
sont
familiers
à
la
communauté
du
développeurs
confirmés
et
pour
lesquels
des
solutions
éprouvées
existent
.

Il
ne
s'
agit
pas
ici
de
solutions
théoriques
(
algorithmes
)
mais
de
solutions
orientées
objet
empiriques
dont
la
solidité
et
l'
efficacité
ont
fait
leur
preuve
en
pratique
.

Ces
solutions
sont
appelées
modèles
de
conception
(
design
patterns
)
.

Un
développeur
expérimenté
se
doit
de
les
connaître
et
de
disposer
de
un
"
panier
"
de
modèles
de
conception
qu'
il
appliquera
aussi
systématiquement
que
possible
.

Les
modèles
de
conception
sont
des
stratégies
de
résolution
de
grands
types
de
problèmes
de
conception
orientée
objet
.

Ils
décrivent
des
formes
génériques
de
organisation
de
classes
.

Ils
sont
indépendants
du
langage
de
programmation
objet
mis
en
oeuvre
.

à
titre
illustratif
,
l'
architecture
MVC
,
décrite
à
la
section
13.2
,
est
un
exemple
de
modèle
de
conception
de
architecture
logicielle
(
architectural
design
pattern
)
.

Les
plus
connus
du
modèles
de
conception
de
base
sont
les
23
modèles
fondamentaux
décrits
par
les
quatre
auteurs
qui
furent
appelés
collectivement
"
The
Gang
of
Four
"
(
"
La
bande
du
quatre
"
)
ou
tout
simplement
Gof
[
2
]
.

On
distingue
habituellement
3
grandes
familles
de
modèles
de
conception
:
[
1
]
L'
expression
design
pattern
est
souvent
traduite
aussi
par
patron
de
conception
.

[
2
]
-
Les
modèles
de
construction
ont
pour
but
de
organiser
la
création
de
objets
de
façon
à
gagner
en
abstraction
.

Exemple
présenté
ci-après
:
le
modèle
Singleton
.

-
Les
modèles
de
structuration
facilitent
l'
organisation
de
la
hiérarchie
du
classes
et
de
leurs
relations
.

Exemple
présenté
ci-après
:
le
modèle
Decorator
.

-
Les
modèles
de
comportement
proposent
des
solutions
pour
organiser
les
interactions
et
pour
répartir
les
traitements
entre
les
objets
.

Ils
tentent
de
répartir
les
responsabilités
entre
chaque
classe
.

Exemple
:
le
modèle
Chain
of
Responsibility
permet
de
créer
une
chaîne
de
objets
tels
que
,
si
l'
un
de
eux
ne
peut
pas
répondre
à
une
requête
,
il
puisse
la
transmettre
à
son
successeur
jusque
à
ce
que
l'
un
de
entre
eux
y
réponde
.

13.5.1
Exemple
:
le
modèle
Singleton
Le
modèle
de
conception
Singleton
permet
de
assurer
que
une
classe
ne
possédera
qu'
une
instance
au
plus
et
de
offrir
une
méthode
unique
retournant
cette
instance
.

Exemple
de
implémentation
(
cas
où
toutes
les
informations
nécessaires
à
la
création
du
singleton
sont
disponibles
au
moment
du
chargement
de
la
classe
en
mémoire
)
public
final
class
MySingleton
{
//
Creating
at
the
class
loading
private
static
MySingleton
singleInstance
à
new
MySingleton()
;
//
Private
constructor
.

Can't
be
used
outside
this
class
private
MySingleton()
{
...
}
/**
Get
a
singleton
of
this
class
*/
public
static
MySingleton
getInstance()
à
return
singleInstance
;
}
}
//
Creation
of
a
singleton
MySingleton
singleton
=
MySingleton.getInstance()
;
13.5.2
Exemple
:
le
modèle
Decorator
Le
modèle
de
conception
Decorator
permet
de
ajouter
dynamiquement
des
fonctionnalités
à
un
objet
.

Ceci
se
réalise
en
créant
une
nouvelle
classe
Decorator
enveloppant
la
classe
originale
.

Le
modèle
de
conception
Decorator
est
une
alternative
à
l'
approche
par
création
de
une
sous-
classe
de
la
classe
originale
.

Il
s'
impose
notamment
à
une
approche
par
extension
de
la
classe
originale
dans
les
cas
suivants
:
la
classe
originale
ne
peut
pas
être
étendue
par
héritage
;
le
nombre
de
sous-classes
permettant
de
définir
toutes
les
combinaisons
possibles
de
fonctionnalités
est
trop
important
;
l'
ajout
du
fonctionnalités
ne
peut
pas
être
statique
(
i.e.
réalisé
à
la
compilation
)
mais
doit
être
dynamique
(
.e
.

réalisé
à
l'
exécution
)
.

Exemple
[
Wikipedia
]
.

Considérons
des
fenêtres
de
affichage
instances
de
une
classe
Window
et
supposons
que
cette
classe
n'
offre
pas
la
possibilité
de
ajouter
des
barres
de
défilement
.

Créons
un
décorateur
qui
puisse
ajouter
dynamiquement
cette
fonctionnalité
à
des
objets
Window
existants
.

//
An
interface
common
to
the
decorator
and
the
decorated
public
interface
Window
{
public
void
draw()
;
}
//
The
original
class
,
the
instance
of
which
can
be
decorated
public
class
SimpleWindow
implements
Window
public
void
draw()
{
...
}
}
//
The
abstract
decorator
public
abstract
class
WindowDecorator
implements
Window
{
protected
Window
decoratedWindow
;
public
WindowDecorator(
Window
decoratedWindow
)
{
this.decoratedWindow
=
decoratedWindow
;
}
}
//
à
first
concrete
decorator
public
class
VerticalScrollBarDecorator
extends
WindowDecorator
à
public
VerticalScrollBarDecorator(
Window
decoratedWindow
)
{
super
(
decoratedWindow
)
;
}
public
void
draw()
à
drawVerticalScrollBar()
;
decoratedWindow.draw()
;
}
public
void
drawVerticalScrollBar()
{
...
}
}
//
à
second
concrete
decorator
public
class
HorizontalScrollBarDecorator
extends
WindowDecorator
à
public
HorizontalScrollBarDecorator(
Window
decoratedWindow
)
{
super
(
decoratedWindow
)
;
}
public
void
draw()
à
drawHorizontalScrollBar()
;
decoratedWindow.draw()
;
}
public
void
drawHorizontalScrollBar()
{
...
}
}
//
Example
:
creation
of
a
fully
decorated
Window
instance
.

Window
decoratedWindow
=
new
HorizontalScrollBarDecorator(
new
VerticalScrollBarDecorator(
new
SimpleWindow()
)
)
;
14
ANNEXE
4
--
MACHINE
VIRTUELLE
Java
(
Jvm
)
Les
objectifs
premiers
de
ce
chapitre
sont
:
-
comprendre
comment
s'
opère
le
chargement
dynamique
du
classes
en
mémoire
lors
de
l'
exécution
de
un
programme
Java
;
-
comprendre
le
traitement
du
champs
et
blocs
static
au
chargement
de
la
classe
.

Une
machine
virtuelle
Java
(
Jvm
)
est
un
interpréteur
de
code
Java
compilé
(
bytecode
)
permettant
de
exécuter
un
programme
Java
sur
une
machine
cible
.

L'
espace
mémoire
de
la
Jvm
comporte
plusieurs
zones
,
notamment
:
-
la
Zone
du
méthodes
:
contient
le
code
du
méthodes
et
constructeurs
ainsi
que
du
informations
sur
la
structure
de
chaque
classe
(
notamment
sa
table
du
symboles
)
;
-
la
pile
:
espace
propre
à
chaque
thread
,
mémorise
dynamiquement
les
contextes
de
exécution
(
variables
locales
notamment
)
du
méthodes
en
cours
de
exécution
;
-
le
tas
:
contient
les
objets
créés
par
new
(
instances
de
classe
et
tableaux
)
(
cf
chapitre
4
)
.

C'
est
la
demande
de
exécution
de
un
programme
Java
qui
lance
la
machine
virtuelle
Java
.

La
Jvm
réalise
alors
les
grandes
étapes
suivantes
:
-
chargement
de
la
classe
principale
spécifiée
(
main
class
)
et
du
classes
dont
elle
dépend
immédiatement
(
au
premier
rang
desquelles
toutes
ses
sur-classes
)
:
o
création
du
champs
static
,
création
de
la
table
du
méthodes
,
...
o
traitement
du
champs
(
initialisation
)
et
blocs
(
exécution
)
static
-
exécution
de
la
méthode
main
de
la
classe
principale
.

Durant
l'
exécution
de
un
code
Java
,
les
classes
(
leur
bytecode
)
sont
chargées
dans
la
Jvm
au
fur
et
à
mesure
du
besoins
.

Dans
une
hiérarchie
de
héritage
,
le
chargement
du
classes
est
opéré
par
ordre
hiérarchique
descendant
(
i.e
de
la
super-classe
racine
vers
la
classe
courante
)
.

Exemple
:
public
class
ClassA
à
static
à
System.out.println("Start
loading
ClassA
"
)
;
}
public
static
final
int
C
;
private
static
int
n
=
100
;
static
{
C
=
29979
;
}
static
{
System.out.println("C
=
"
p
C
)
;
System.out.println("n
=
"
p
n
)
;
}
public
ClassA()
{
System.out.println("Start
ClassA()")
;
n
=
n
p
1
;
System.out.println("End
ClassA()")
;
}
public
int
getN
(
)
à
return
n
;
}
static
{
System.out.println("End
loading
ClassA
"
)
;
}
}
//
end
ClassA
public
class
ClassB
extends
ClassA
à
static
{
System.out.println("Start
loading
ClassB
"
)
;
}
private
int
x
=
5
;
public
ClassB()
{
System.out.println("Start
ClassB()")
;
x
=
x
p
getN()
;
System.out.println(x)
;
System.out.println("End
ClassB()")
;
}
static
{
System.out.println("End
loading
ClassB
"
)
;
}
}
//
end
ClassB
public
class
Class()
à
static
à
System.out.println("Start
loading
Class0
"
)
;
}
private
static
int
y
=
initY()
;
private
static
int
initY()
{
System.out.println("Init
y
"
)
;
return
256
;
}
public
static
void
main(String[
]
args
)
à
System.out.println("Start
main
Class0
"
)
;
ClassB
b
=
new
ClassB()
;
System.out.println("End
main
Class0
"
)
;
}
static
{
System.out.println("End
loading
Class0
"
)
;
}
}
//
end
Class0
Après
compilation
de
ces
trois
classes
,
l'
exécution
de
la
commande
:
java
Class0
affichera
(
commentaires
ajoutés
en
marge
)
:
Start
loading
Class0
Init
y
End
loading
Class0
Start
main
Class0
Start
loading
ClassA
//
Sur-classes
de
ClassB
d'abord
C
=
29979
n
=
100
End
loading
ClassA
Start
loading
ClassB
//
pui
enfin
ClassB
.

End
loading
ClassB
Start
ClassA()
//
Car
super()
d'abord
.

End
ClassA()
Start
ClassB()
106
//
100
p
1
ClassA()
p
5
ClassB()
End
ClassB()
End
main
Class0
15
ANNEXE
5
-
COMMUNICATION
ENTRE
Java
ET
C
(
JNI
)
Références
:
"
The
Java
Native
Interface
:
Programmer
'
s
guide
and
Specification
"
java.sun.com/docs/books/jni/
Tutoriel
:
java.sun.com/docs/books/jni/html/jniTOC.html
"
Java
Native
Interface
Specification
v1.5
"
java.sun.com/j2se/1.5.0/docs/guide/jni/spec/jniTOC.html
"
Javah
-
C
Header
and
Stub
File
Generator
"
java.sun.com/javase/6/docs/technotes/tools/windows/javah.html
On
se
pose
le
problème
de
appeler
un
sous-programme
C
depuis
une
méthode
Java
dans
un
environnement
Unix
.

La
solution
met
en
oeuvre
l'
interface
de
programmation
JNI
(
Java
Native
Interface
)
offert
par
la
plate-forme
Java
.

JNI
est
un
ensemble
de
fonctionnalités
qui
permet
à
un
programme
Java
fonctionnant
sur
la
machine
virtuelle
Java
(
Jvm
)
de
appeler
ou
de
être
appelé
par
un
programme
écrit
dans
un
autre
langage
(
typiquement
en
C
,
C++
ou
assembleur
)
.

En
permettant
l'
interfaçage
avec
des
applications
ou
bibliothèques
natives
[
1
]
,
la
mise
en
oeuvre
de
JNI
accroît
l'
interopérabilité
du
applications
Java
,
mais
évidemment
au
détriment
de
leur
portabilité
.

Une
bonne
architecture
de
l'
application
devrait
donc
minimiser
le
nombre
de
classes
faisant
référence
à
une
méthode
native
.

Par
la
suite
,
on
supposera
que
le
fichier
Java
appelant
le
sous-programme
C
se
nomme
MyClass.java
,
et
que
le
fichier
C
implémentant
ce
sous-programme
se
nomme
MyRoutines.c
Le
développement
de
l'
application
complète
comporte
6
étapes
:
1
)
Ecrire
le
programme
Java
et
le
compiler
:
javac
MyClass.java
2
)
Produire
le
fichier
de
en-tête
MyClass.h
pour
le
programme
C
:
javah
MyClass
3
)
Ecrire
le
sous-programme
C
et
le
compiler
:
gcc
o
MyRoutines
-c
MyRoutines.c
-pedantic
w
-Wal1l
-Idir
où
dir
est
le
répertoire
de
installation
par
le
Jdk
du
fichiers
de
include
du
JNI
.

Par
exemple
(
ces
fichiers
étant
répartis
dans
deux
répertoires
)
:
gcc
o
MyRoutines
-c
MyRoutines.c
-pedantic
w
-Wall
-I/usr/lib/jdk1.5.0v11/include
-I/usr/lib/jdk1.5.0v11/include/linux
[
1
]
Une
application
ou
une
bibliothèque
de
sous-programmes
est
dite
en
code
natif
si
elle
est
dépendante
de
un
environnement
hôte
(
système
de
exploitation
ou
jeu
de
instructions
du
processeur
)
particulier
.

Par
exemple
,
un
programme
C
compilé
sur
un
système
de
exploitation
donné
est
en
code
natif
car
il
ne
fonctionnera
pas
sur
un
autre
système
de
exploitation
.

4
)
Produire
une
bibliothèque
partagée
(
lib*.so
)
qui
sera
chargeable
par
le
programme
Java
:
gcc
-Wall
-shared
o
libMyRoutines.so
MyRoutines.o
5
)
Avant
la
toute
première
exécution
,
spécifier
à
la
machine
virtuelle
Java
le
chemin
de
accès
à
cette
bibliothèque
:
setenv
LD_LIBRARY_PATH
path
où
path
désigne
le
chemin
de
accès
.

En
supposant
que
celui
-ci
soit
le
répertoire
courant
,
la
commande
sera
:
setenv
LD_LIBRARY_PATH
.

6
)
Exécuter
le
programme
Java
:
java
MyClass
La
façon
de
écrire
le
programme
Java
et
de
implémenter
le
sous-programme
C
associé
est
illustrée
ci-après
.

15.1
Appel
de
une
procédure
C
On
considèrera
de
bout
en
bout
le
même
exemple
.

15.1.1
Déclaration
et
appel
java
Exemple
de
classe
java
public
class
MyClass
{
//
Declaration
of
an
extern
class
procedure
native
public
static
void
procedure1()
;
//
Declaration
of
an
extern
instance
procedure
native
public
void
procedure2()
;
//
Test
procedure
public
static
void
main(String[
]
argv
)
à
MyClass.procedure1()
;
MyClass
o
=
new
MyClasse()
;
o.procedure2()
;
}
//
Load
the
library
libMyRoutines
static
{
System.loadLibrary("MyRoutines")
;
}
}
Commentaires
:
-
Le
modificateur
native
indique
que
il
s'
agit
de
une
procédure
externe
non
écrite
en
java
.

Le
nom
de
la
procédure
est
arbitraire
.

-
La
méthode
loadLibrary
va
charger
la
bibliothèque
libMyRoutines.so
;
le
mot
clé
static
qui
encapsule
le
bloc
de
instructions
dans
lequel
l'
appel
est
réalisé
permet
de
exécuter
ce
bloc
dès
le
chargement
de
la
classe
MyClass
sans
avoir
besoin
de
passer
par
l'
appel
de
une
méthode
intermédiaire
.

15.12
Prototype
C
Le
fichier
MyClass.h
produit
par
javah
(
cf
étape
2
précédente
)
spécifie
les
prototypes
que
devront
respecter
les
sous-programmes
C
à
écrire
.

Contenu
(
expurgé
)
du
fichier
MyClass.h
produit
par
javah
/*
Do
NOT
EDIT
THIS
FILE
-
it
is
machine
generated
*/
/*
Header
for
class
MYClass
*/
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
(
JNIEnv
*
,
jclass
)
;
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
(
JNIEnv
*
,
jobject
)
;
Commentaires
:
-
JNIEXPORT
et
JNICALL
sont
deux
macros
prédéfinies
par
JNI
pour
faire
communiquer
java
et
C
-
void
spécifie
que
il
s'
agit
de
une
procédure
-
Java_MyClass_procedure1
est
le
nom
imposé
que
devra
porter
la
procédure
C
correspondant
à
la
méthode
de
nom
procedure1
déclarée
dans
le
programme
java
;
idem
pour
procedure2
-
Deux
paramètres
sont
systématiquement
introduits
en
tête
de
la
liste
du
paramètres
:
o
le
premier
,
de
type
JNIEnv
*
,
est
un
pointeur
vers
l'
environnement
JNIEnv
qui
est
lui-même
un
pointeur
vers
une
structure
contenant
des
fonctions
de
interface
avec
la
machine
virtuelle
Java
(
Jvm
)
;
o
le
second
,
de
type
jclass
si
il
s'
agit
de
une
méthode
de
classe
ou
jobject
si
il
s'
agit
de
une
méthode
de
instance
,
est
un
pointeur
vers
un
descripteur
de
la
classe
ou
de
l'
objet
(
une
sorte
de
this
)
de
appel
15.1.3
implémentation
C
Exemple
de
fichier
MyRoutines.c
#include
<stdio.h>
#include
"
MyClass.h
"
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
(
JINIEnv
*
penv
,
jclass
cla
)
{
printf("Routine
procedure1\n
"
)
;
}
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
(
JINIEnv
*
penv
,
jobject
obj
)
{
printf("Routine
procedure2\n
"
)
;
}
15.2
Echange
de
données
entre
Java
et
C
L'
échange
de
données
entre
l'
application
java
et
le
sous-programme
C
(
par
les
paramètres
ou
le
résultat
de
la
fonction
)
suppose
une
compatibilité
du
types
correspondants
.

Or
il
n'
y
a
pas
de
correspondance
systématique
naturelle
entre
les
types
du
langage
Java
et
les
types
du
langage
C
(
un
caractère
,
par
exemple
,
est
codé
sur
16
bits
en
Java
et
sur
8
bits
en
C
)
.

Le
JNI
définit
donc
un
ensemble
de
types
en
C
(
de
noms
jä
)
qui
correspondent
au
types
de
Java
.

Le
JNI
traite
les
types
primitifs
et
les
types
objets
différemment
.

La
correspondance
du
types
primitifs
est
directe
(
voir
tableau
ci-après
)
,
car
elle
repose
sur
une
représentation
machine
du
données
identique
,
mais
ce
n'
est
pas
le
cas
pour
les
types
objets
.

La
transmission
de
une
chaîne
de
caractères
,
de
un
tableau
,
a
fortiori
de
une
instance
quelconque
de
classe
,
n'
est
pas
directe
et
nécessite
du
conversions
de
type
.

Un
paramètre
java
de
type
objet
est
ainsi
transmis
au
sous-
programme
C
sous
forme
de
un
pointeur
sur
une
structure
de
données
interne
à
la
machine
virtuelle
Java
.

L'
organisation
interne
de
cette
structure
est
masquée
au
programmeur
mais
celui
-ci
peut
néanmoins
accéder
au
composantes
sous-jacentes
via
les
fonctions
utilitaires
offertes
par
le
JNI
dans
l'
environnement
JNIEnv
.

Type
primitif
Java
Type
primitif
côté
C
Description
boolean
jboolean
unsigned
8
bits
byte
jbyte
signed
8
bits
char
jchar
unsigned
16
bits
short
jshort
signed
16
bits
int
jint
signed
32
bits
long
jlong
signed
64
bits
float
jfloat
32
bits
double
jdouble
64
bits
Par
la
suite
,
on
considèrera
de
bout
en
bout
le
même
exemple
.

15.2.1
Déclaration
et
appel
java
Exemple
de
classe
java
public
class
MyClass
{
//
Declaration
of
an
extern
instance
function
native
public
String
getMessage(int
id
,
String
prompt
)
;
//
Test
procedure
public
static
void
main(String[
]
argv
)
à
MyClass
o
=
new
MyClasse()
;
System.out.println(o.getMessage(10
,
"
Name
:
"
)
)
;
}
//
Load
the
library
libMyRoutines
static
{
System.loadLibrary("libMyRoutines")
;
}
}
15.22
Prototype
C
Contenu
(
expurgé
)
du
fichier
MyClass.h
produit
par
javah
/*
Do
NOT
EDIT
THIS
FILE
-
it
is
machine
generated
*/
/*
Header
for
class
MYClass
*/
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
(
INIEnv
*
,
jobject
,
jint
,
jstring
)
;
15.2.3
implémentation
C
Exemple
de
fichier
MyRoutines.c
#include
<stdio.h>
#include
"
MyClass.h
"
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
(
JINIEnv
*
penv
,
jobject
obj
,
jint
jid
,
jstring
jprompt
)
;
{
const
char
*
str
;
char
buf[128
]
;
/*
Get
the
C
string
from
the
java
string
*/
str
=
(*penv)->GetStringUTFChars(penv
,
jprompt
,
NULL
)
;
printf("%d
-
-s
"
,
jid
,
str
)
;
/*
Don't
forget
this
line
!

!
!

*/
(*penv)->ReleaseStringUTFChars(penv
,
jprompt
,
str
)
;
/*
Assume
the
user
doesn't
type
more
than
127
char
*/
scanf("%s
"
,
buf
)
;
return
(*penv)->NewStringUTF(penv
,
buf
)
;
}
Commentaires
:
-
Les
représentations
physiques
du
chaînes
de
type
jstring
et
de
type
char*
ne
sont
pas
identiques
.

Une
conversion
doit
être
réalisée
.

C'
est
le
rôle
du
fonctions
GetStringUTFChars
et
NewStringUTF
.

à
noter
que
,
dans
tous
les
cas
,
la
conversion
du
caractères
non
codables
en
ASCII
7
bits
(
lettres
accentuées
,
...
)
posera
problème
.

-
La
fonction
GetStringUTFChars
réalisant
une
allocation
mémoire
dynamique
,
une
désallocation
doit
être
obligatoirement
réalisée
avant
la
fin
du
sous-
programme
:
c'
est
le
rôle
de
la
fonction
ReleaseStringUTFChars
16
ANNEXE
6
-
PLATES-FORMES
Java
Références
:
Java
Platform
,
Standard
Edition
6
,
Api
Specification
:
java.sun.com/javase/6/docs/api/
New
features
and
Enhancements
Jise
5.0
:
java.sun.com/j2se/1.5.0/docs/relnotes/features.html
Java
Platform
,
Standard
Edition
:
java.sun.com/javase/
Java
Platform
,
Enterprise
Edition
:
java.sun.com/javaee/
Java
Platform
,
Micro
Edition
:
java.sun.com/javame/
jdk
Tools
and
Utilities
:
java.sun.com/javase/6/docs/technotes/tools/
Sun
Microsystems
fournit
trois
plates-formes
Java
permettant
le
développement
et
l'
exécution
de
programmes
Java
:
Java
se
(
le
standard
de
base
)
,
Java
Ee
et
Java
me
.

à
noter
que
ces
noms
sont
ceux
employés
pour
les
versions
sorties
depuis
2006
:
antérieurement
,
ces
plates-
formes
étaient
nommées
respectivement
Jise
,
Jiee
et
J2ME
.

Java
Platform
,
Standard
Edition
(
Java
se
)
.

Cette
plate-forme
est
le
framework
Java
de
base
permettant
de
développer
ou/et
exécuter
des
programmes
Java
.

La
dernière
version
nommée
Jise
est
la
version
5.0
et
porte
le
nom
Jise
5.0
:
il
est
à
souligner
que
cette
version
apportait
une
mise
à
jour
majeure
par
rapport
à
la
précédente
.

La
version
actuelle
la
plus
récente
date
de
décembre
2006
:
c'
est
la
version
6
et
elle
porte
le
nom
Java
SE
6
.

La
version
7
(
Java
SE
7
)
est
annoncée
comme
nouvelle
mise
à
jour
majeure
mais
,
à
mi
2010
,
est
toujours
attendue
.

La
plate-forme
Java
SE
délivre
deux
produits
logiciels
principaux
:
Java
SE
Runtime
Environment
(
ou
plus
communément
JRE
)
,
qui
fournit
les
librairies
,
la
machine
java
virtuelle
et
d'
autres
composantes
nécessaires
pour
exécuter
des
programmes
Java
.

Java
SE
Development
Kit
(
ou
plus
communément
Jdk
)
,
qui
inclut
le
JRE
plus
des
outils
de
développement
,
tels
que
compilateur
et
débogueur
,
nécessaires
ou
utiles
pour
développer
des
programmes
Java
.

à
noter
que
le
terme
Jdk
,
bien
que
très
populaire
,
est
devenu
imprécis
car
d'
autres
plates-formes
Java
(
Java
ee
par
exemple
)
comportent
elles
aussi
leur
propre
kit
de
développement
.

Java
Platform
,
Enterprise
Edition
(
Java
Ee
)
.

Cette
plate-forme
est
un
framework
Java
plus
particulièrement
destiné
au
applications
de
entreprises
.

Elle
offre
un
cadre
standard
pour
développer
des
applications
distribuées
.

Java
Platform
,
Micro
Edition
(
Java
me
)
.

Cette
plate-forme
est
un
framework
Java
spécialisé
dans
les
applications
mobiles
.

Des
plates-formes
Java
compatibles
avec
J2ME
sont
embarquées
dans
de
nombreux
téléphones
mobiles
et
Pda
.

de
façon
plus
spécifique
,
on
pourrait
aussi
citer
les
plateformes
Java
Card
(
qui
fournit
un
environnement
pour
le
développement
de
applications
sur
cartes
à
puce
)
et
Javafx
(
pour
créer
des
Rich
Internet
Applications
)
.

17
ANNEXE
7
-
GLOSSAIRE
On
trouve
facilement
sur
le
web
de
excellentes
définitions
en
anglais
du
termes
,
sigles
,
et
même
produits
de
référence
,
informatiques
.

Parmi
les
sources
possibles
,
citons
par
exemple
:
-
parmi
les
encyclopédies
:
www.wikipedia.org
(
la
version
anglaise
étant
la
plus
complète
)
-
parmi
les
moteurs
spécialisés
dans
la
recherche
dans
les
encyclopédies
,
dictionnaires
et
glossaires
:
www.answers.com
Voici
un
glossaire
de
quelques
termes
et
sigles
généraux
courants
:
Sigle
/
terme
Définition
Commentaire
Api
Application
Programming
Bibliothèque
de
fonctionnalités
communes
,
Interface
courantes
et
de
bas
niveau
.

Constitue
une
interface
entre
couches
basses
et
couches
applicatives
de
plus
haut
niveau
.

Exemple
:
java.sun.com/javase/6/docs/api/
spécifie
les
api
standard
de
Java
fournies
dans
le
Jdk
6
.

Framework
Cadre
de
applications
Ensemble
cohérent
de
classes
(
généralement
abstraites
)
et
de
interfaces
permettant
le
développement
rapide
de
applications
.

Fournit
suffisamment
de
briques
logicielles
pour
pouvoir
produire
une
application
aboutie
.

Typiquement
spécialisé
pour
un
type
de
application
.

gui
Graphical
User
Interface
Interface
homme-machine
graphique
,
par
opposition
à
interface
en
ligne
de
commande
.

IDE
Integrated
Development
Programme
regroupant
un
ensemble
de
utilitaires
Environment
logiciels
pour
le
développement
de
programmes
(
éditeur
de
texte
,
compilateur
,
débogueur
,
gestionnaire
de
versions
,
aide
à
la
production
de
interfaces
,
...
)
.

Généralement
dédié
à
un
seul
langage
de
programmation
.

Jdk
Java
Development
Kit
(
voir
chapitre
16
)
JFC
Java
Foundation
Classes
Cadre
de
applications
graphiques
.

Ensemble
de
classes
Java
permettant
de
construire
des
interfaces
utilisateur
graphiques
portables
.

Contient
notamment
les
composants
Swing
.

JRE
Java
Runtime
Environment
(
voir
chapitre
16
)
Jiee
Java
2
Platform
,
Enterprise
(
voir
chapitre
16
)
Edition
Java
SE
Java
Platform
,
Enterprise
J2ME
Java
2
Platform
,
Micro
(
voir
chapitre
16
)
Edition
Java
me
Java
Platform
,
Micro
Edition
Jise
Java
2
Platform
,
Standard
(
voir
chapitre
16
)
Edition
Java
SE
Java
Platform
,
Standard
Edition
Et
plus
spécifiquement
dans
le
cadre
de
applications
professionnelles
Java
distribuées
:
Sigle
/
terme
Définition
Commentaire
Ejb
Enterprise
JavaBeans
Technologie
Java
,
offerte
par
la
plateforme
Java
Ee
,
permettant
de
créer
des
composants
distribués
hébergés
dans
un
serveur
de
applications
.

Dans
une
architecture
MVC
,
utilisé
pour
réaliser
le
Modèle
.

java.sun.com/products/ejb/
Jsp
Java
Server
Pages
Technologie
Java
,
offerte
par
la
plateforme
Java
Ee
,
permettant
de
créer
des
page
Web
dynamiques
.

Dans
une
architecture
MVC
,
utilisé
pour
réaliser
la
vue
.

java.sun.com/products/jsp/
Servlet
Technologie
Java
,
offerte
par
la
plateforme
Java
Ee
,
permettant
de
étendre
la
fonctionnalité
de
un
serveur
Web
(
accès
à
des
base
de
données
,
transactions
de
e-commerce
,
...
...
)
.

Dans
une
architecture
MVC
,
utilisé
pour
réaliser
le
Contrôleur
.

java.sun.com/products/servlet/

