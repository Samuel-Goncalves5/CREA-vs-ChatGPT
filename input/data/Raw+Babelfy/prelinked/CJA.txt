LANGAGE
JAVA
Petit
mémento
syntaxe
&
éléments
programmation
SITES
REFERENCE
site
officiel
Java
java.sun.com
peut
notamment
consulter
intérêt
-
tutoriels
java.sun.com/docs/books/tutorial/
-
grande
collection
petits
exemples
programmes
java.sun.com/developer/codesamples/examplets/
-
recommandations
style
java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html
-
descriptif
tous
paquetages
classes
méthodes
standard
java.sun.com/javase/6/docs/api/
-
mode
d'emploi
générateur
documentation
javadoc
java.sun.com/j2se/javadoc/index.jsp
-
préparation
certification
programmeur
Java
java.sun.com/docs/books/tutorial/extra/certification/
SOMMAIRE
1
LANGAGE
PROGRAMMATION
ORIENTÉS
OBJETS
7
2
PROGRAMME
JAVA
....
8
2.1
Style
programmation
8
2.2
Identificateurs
8
2.3
Commentaires
8
2.3.1
Commentaires
documentation
8
2.3.2
Commentaires
d'implémentation
9
2.4
Fichier
JAVA
9
24.1
Nom
contenu
d'un
fichier
java
9
24.2
Compilation
exécution
génération
documentation
10
2.5
Paquetages
10
2.5.1
Paquetages
standard
10
2.5.2
Affectation
d'une
classe
paquetage
10
2.5.3
Importation
d'une
classe
d'un
paquetages
11
3
CLASSES
INTERFACES
......
12
3.1
Classes
standard
12
3.2
Classes
abstraites
sous-classes
13
3.2.1
Classes
abstraites
13
3.2.2
Sous-classe
14
3.3
Interfaces
15
3.3.1
Interface
16
3.3.2
Classe
implantant
interface
16
3.4
Enumération
...............
16
3.5
Classes
imbriquées
Nested
classes
17
3.6
Contrôle
d'accès
modificateurs
18
4
INSTANCE
CLASSE
20
5
TYPES
DONNEES
....
21
5.1
Types
primitifs
21
5.2
Types
objet
types
référence
..
22
5.2.1
Classes
enveloppes
..
22
5.2.2
Chaîne
caractères
non
modifiable
String
23
5.2.3
Chaîne
caractères
modifiable
StringBuffer
..........................
23
5.2.4
Tableau
23
5.2.5
Collection
25
5.3
Transtypage
27
6
OPERATEURS
EXPRESSIONS
29
6.1
Opérateurs
expressions
arithmétiques
29
6.2
Opérateurs
expressions
booléennes
30
6.3
Opérateurs
relationnels
30
7
METHODES
31
7.1
Définition
appel
d'une
méthode
ordinaire
31
7.2
Constructeur
32
7.3
Méthode
main
................
33
8
INSTRUCTIONS
34
8.1
Instruction
d'affectation
34
8.2
Instructions
contrôle
34
8.2.1
Instructions
sélection
34
8.2.2
Instructions
boucle
36
8.3
Instructions
d'entrée
/
sortie
38
8.3.1
Notion
flux
38
8.3.2
Entrée
/
sortie
terminal
38
8.3.3
Entrée
/
sortie
fichier
39
8.3.4
Lecture
d'une
chaîne
caractères
formatée
40
9
HERITAGE
.......
42
9.1
Notion
d'héritage
42
9.2
Qu'hérite
sous-classe
43
9.3
Redéfinir
méthode
43
9.4
Type
statique
/
dynamique
-
Liaison
statique
/
dynamique
46
9.4.1
Type
statique
/
dynamique
-
Transtypage
.....................
46
9.4.2
Liaison
statique
/
dynamique
47
9.5
Polymorphisme
48
9.6
Classes
méthodes
particulières
49
9.7
Interfaces
49
10
EXCEPTIONS
50
10.1
Exceptions
contrôlées
non
contrôlées
50
10.2
Classes
d'exception
standard
51
10.2.1
hiérarchie
Error
51
10.2.2
hiérarchie
Exception
51
10.23
hiérarchie
RuntimeException
..........
51
10.3
Lancement
d'une
exception
51
10.4
Capture
d'une
exception
.........
52
10.4.1
Clause
throws
52
10.4.2
Instruction
try
..
catch
..............
iii
52
10.5
Définir
nouvelle
classe
d'exception
54
11
ANNEXE
1
-
PROGRAMMATION
GRAPHIQUE
55
111
SWING
..
55
11.2
Conteneurs
composants
56
11.3
Gestion
mise
page
57
11.4
Gestion
événements
58
11.4.1
Notion
d'événement
58
11.4.2
Réaliser
gestionnaire
d'événement
............
59
11.5
Affichage
/
fermeture
d'une
fenêtre
graphique
60
11.6
Architecture
composants
Swing
......
60
11.7
Applets
61
12
ANNEXE
2
-
THREADS
63
12.1
Créer
thread
extension
classe
Thread
63
12.2
Créer
thread
implémentation
l'interface
Runnable
.......................
64
12.3
Synchronisation
communication
entre
threads
64
12.3.1
Sections
critiques
synchronisation
64
12.3.2
Communication
entre
threads
64
13
ANNEXE
3
-
CONCEPTION
DEVELOPPEMENT
JAVA
66
13.1
Conseils
généraux
bonne
conception
classes
66
13.2
Architecture
d'une
application
interactive
modèle
MVC
67
13.3
Tests
unitaires
70
13.3.1
Définitions
70
13.32
JUnit
..........
71
13.4
Java
Beans
72
13.5
Design
patterns
74
13.5.1
Exemple
modèle
Singleton
75
13.5.2
Exemple
modèle
Decorator
.................
75
14
ANNEXE
4
-
MACHINE
VIRTUELLE
JAVA
JVM
77
15
ANNEXE
5
-
COMMUNICATION
ENTRE
JAVA
JNI
..................
79
15.1
Appel
d'une
procédure
80
15.1.1
Déclaration
appel
java
80
15.1.2
Prototype
81
15.1.3
Implémentation
81
15.2
Echange
données
entre
Java
82
15.2.1
Déclaration
appel
java
82
15.2.2
Prototype
83
15.2.3
Implémentation
83
16
ANNEXE
6
-
PLATES-FORMES
JAVA
84
17
ANNEXE
7
-
GLOSSAIRE
85
1
LANGAGE
PROGRAMMATION
ORIENTÉS
OBJETS
Java
1
langage
programmation
orienté
objets
objet
représentation
simplifiée
d'une
entité
monde
réel
entité
concrète
ex
voiture
non
ex
date
d'aujourd'hui
objet
caractérise
état
comportement
objet
stocke
état
variables
appelées
champs
attributs
présente
comportement
travers
fonctionnalités
appelées
méthodes
Exemple
d'objet
maVoiture
=
{
valeur
attributs
Fiat
grise
6
/100km
....
méthodes
démarrer
arrêter
accélérer
....
}
Typiquement
l'état
encapsulé
coeur
l'objet
n'est
accessible
depuis
l'extérieur
l'objet
consultation
modification
via
méthodes
offertes
objet
Exemple
l'objet
maVoiture
getCouleur
setCouleur
démarrer
arrêter
accélérer
Fiat
grise
6
interagit
objet
envoyant
message
demande
d'activation
d'une
méthodes
Exemple
d'envoi
d'un
message
objet
maVoiture.accélérer
méthode
particulière
appelée
constructeur
permet
d'initialiser
l'état
l'objet
création
classe
sert
regrouper
sous
catégorie
nom
générique
objets
partageant
type
d'état
comportement
classe
type
d'objet
dit
réciproquement
qu'un
objet
instance
classe
Exemple
classe
Automobile
=
{
attributs
marque
couleur
consommation
....
méthodes
démarrer
arrêter
accélérer
....
}
classes
peuvent
être
organisées
hiérarchies
Chaque
classe
hérite
alors
attributs
méthodes
classes
situées
ligne
hiérarchique
ascendante
Réaliser
programme
langage
orienté
objets
c'est
-
modéliser
classes
objets
l'on
manipuler
-
écrire
classes
langage
programmation
orienté
objets
-
créer
objets
instances
classes
-
communiquer
objets
invoquant
leurs
méthodes
1
Java
né
1995
l'entreprise
californienne
Sun
Microsystems
conçu
James
GOSLING
&
al
2
PROGRAMME
JAVA
2.1
Style
programmation
largement
admis
respect
syntaxe
programme
fonctionne
critères
qualité
suffisants
programme
L'expérience
programmation
ainsi
conduit
établir
recommandations
style
respecter
n'est
techniquement
obligatoire
contribue
améliorer
lisibilité
programmes
conventions
visent
fait
finalité
économique
contribuer
produire
programmes
plus
facilement
maintenables
pendant
toute
durée
vie
chapitres
suivants
exemples
respectent
conventions
style
préconisées
java.sun.com
2.2
Identificateurs
Quelques
règles
recommandations
nommer
identificateurs
+
caractère
minuscule-majuscule
caractères
discriminant
règle
langage
Java
+
identificateurs
d'objets
champs
méthodes
commencent
toujours
minuscule
convention
+
identificateurs
classe
d'interface
commencent
toujours
majuscule
convention
+
identificateurs
constantes
tout
majuscules
convention
+
identificateurs
méthode
commencent
verbe
recommandation
2.3
Commentaires
2.3.1
Commentaires
documentation
commentaires
documentation
visent
décrire
spécification
code
sans
considération
d'implémentation
destinés
développeurs
utilisateurs
n'auraient
nécessairement
codes
sources
sous
main
commentaires
peuvent
être
automatiquement
extraits
l'utilitaire
javadoc
constituer
fichier
documentation
HTML
documentation
d'une
classe
devrait
inclure
minima
-
nom
classe
fonctionnalité
grandes
caractéristiques
auteur
version
-
documentation
chaque
constructeur
chaque
méthode
documentation
d'une
méthode
devrait
inclure
minima
-
nom
méthode
fonctionnalité
description
chaque
paramètre
valeur
retournée
exceptions
susceptibles
d'être
lancées
méthode
Syntaxe
/
*
*
*
commentaires
*
/
/
*
*
commentaire
*
/
Principales
balises
commentaires
prédéfinies
author
version
param
return
see
throws
2.3.2
Commentaires
d'implémentation
commentaires
d'implémentation
visent
expliciter
sans
paraphraser
code
choix
d'implémentation
choix
identificateurs
clarté
programmation
devrait
permettre
minimiser
nombre
tels
commentaires
Syntaxe
/
*
*
commentaires
*
/
/
*
commentaire
*
/
//
commentaire
2.4
Fichier
JAVA
2.4.1
Nom
contenu
d'un
fichier
java
+
Chaque
fichier
source
java
contient
seule
classe
publique
L'organisation
recommandée
suivante
1
commentaires
début
C'est
commentaire
documentation
comprenant
typiquement
l'intitulé
classe
descriptif
sommaire
fonction
l'auteur
version
2
instructions
paquetage
3
instructions
d'import
4
déclarations
classes
+
fichier
devrait
contenir
moins
2000
lignes
lignes
moins
80
caractères
voire
70
commentaires
documentation
recommandation
+
fichier
Java
porte
nom
classe
publique
qu'il
contient
fichiers
source
Java
suffixe
.java
fichiers
Java
compilés
suffixe
.class
convention
suffixes
.java
.class
imposés
outils
2.4.2
Compilation
exécution
génération
documentation
Depuis
ligne
commande
+
Compilation
javac
fileName.java
+
Exécution
java
fileName
//
fichier
main
+
Génération
documentation
javadoc
*
java
avoir
documentation
``
programmeur
``
complète
compris
membres
privés
toutes
classes
interaction
faut
lancer
commande
l'option
-
private
2.5
Paquetages
paquetage
package
anglais
bibliothèque
classes
organisées
façon
hiérarchique
nom
d'un
paquetage
nécessairement
nom
répertoire
nom
d'un
paquetage
toujours
lettres
minuscules
convention
Différents
paquetages
peuvent
être
rassemblés
compactés
fichier
d'archive
.zip
.jar
2.5.1
Paquetages
standard
variable
d'environnement
CLASSPATH
indique
machine
virtuelle
Java
trouver
classes
bibliothèques
classes
besoin
Hiérarchie
partielle
paquetages
standard
java
applet
awt
io
lang
util
event
Paquetages
plus
immédiatement
utiles
Paquetage
Contenu
java.io
Classes
relatives
entrées/sorties
java.lang
Classes
fondamentales
types
basiques
classes
enveloppes
String
StringBuffer
......
classe
Math
java.util
Classes
utilitaires
diverses
collections
ArrayList
Vector
classe
Random
gestion
dates
heures
2.5.2
Affectation
d'une
classe
paquetage
qu'une
classe
appartienne
paquetage
faut
déclarer
paquetage
d'appartenance
tête
fichier
source
Syntaxe
package
packageName
2.5.3
Importation
d'une
classe
d'un
paquetage
utiliser
classe
définie
paquetage
autre
celui
classe
d'utilisation
classe
doit
être
importée
tête
fichier
source
Syntaxe
import
packageName.CTassName
import
packageName
*
//
forme
déconseillée
car
peu
informative
Exemples
import
java.util.ArrayList
import
java.util.lterator
import
java.io
*
//
forme
déconseillée
car
peu
informative
paquetage
java.lang
importé
automatiquement
3
CLASSES
INTERFACES
3.1
Classes
standard
Syntaxe
public
class
ClassName
{
Fields
Constructors
Methods
//
accessor
methods
//
mutator
methods
}
Exemple
/
*
*
*
Class
RationalNumber
-
Represents
rational
number
num
/
den
*
*
author
AM
*
version
1.0
*
*
/
public
class
RationalNumber
{
//
FIELDS
private
int
numerator
private
int
denominator
private
boolean
reduced
//
CONSTRUCTORS
/
*
*
Construct
rational
number
initialized
to
0/1
*
/
public
RationalNumber
{
numerator
=
0
denominator
=
1
reduced
=
true
}
//
METHODS
-
ACCESSORS
/
*
*
Get
the
numerator
of
this
rational
number
*
/
public
int
getNumerator
{
return
numerator
}
/
*
*
Get
the
denominator
of
this
rational
number
*
/
public
int
getDenominator
{
return
denominator
}
/
*
*
Return
true
iff
the
numerator/denominator
form
is
irreducible
*
/
public
boolean
isReduced
{
return
reduced
}
//
METHODS
-
MUTATORS
/
*
*
Set
this
rational
number
to
_numerator/_denominator
*
/
public
void
setNumber
int
_numerator
int
_denominator
{
numerator
=
_numerator
denominator
=
_denominator
reduced
=
false
}
/
*
*
Set
this
rational
number
to
irreducible
*
numerator/denominator
form
*
/
public
void
reduce
{
int
divisor
=
greatestCommonDivisor
numerator
denominator
numerator
=
numerator
/
divisor
denominator
=
denominator
/
divisor
reduced
=
true
}
//
METHODS
-
UTILITIES
/
*
*
Return
the
greatest
common
divisor
of
the
two
integers
*
x
and
*
/
private
int
greatestCommonDivisor
int
x
int
{
int
divisor
//
implémenter
return
divisor
}
}
//
end
class
RationalNumber
3.2
Classes
abstraites
sous-classes
classe
possède
moins
méthode
abstraite
i.e
sans
corps
abstraite
doit
être
déclarée
modificateur
abstract
classes
abstraites
peuvent
être
instanciées
pouvoir
créer
objets
faut
créer
sous-classe
laquelle
toutes
méthodes
abstraites
définies
sous-
classe
non
abstraite
pourra
alors
être
instanciée
3.2.1
Classes
abstraites
Syntaxe
public
abstract
class
ClassName
{
Fields
Constructors
Methods
}
Exemple
/
*
*
*
Abstract
Class
Progression
*
*
Represents
real
linear
progression
of
order
1
with
constant
*
coefficients
*
*
author
AM
*
version
1.0
*
/
public
abstract
class
Progression
{
//
FIELDS
private
double
u0
//
the
first
term
of
the
progression
//
CONSTRUCTORS
/
*
*
Define
progression
the
first
term
of
which
is
u0
*
/
public
Progression
double
u0
{
this.u0
=
u0
}
//
METHODS
/
*
*
Get
the
first
term
of
this
progression
*
/
public
double
getu0
{
return
u0
}
/
*
*
Given
current
term
u
return
the
next
term
u
n+1
*
/
public
abstract
double
nextTerm
double
/
*
*
Return
the
term
of
rank
*
/
public
double
termOfRank
int
{
double
u
=
u0
//
u
double
v
//
u
n+1
for
int
i
=
1
i
=
i++
{
v
=
nextTerm
u
u
=
v
}
return
u
}
}
//
end
class
Progression
3.2.2
Sous-classe
Syntaxe
public
class
SubclassName
extends
SuperclassName
{
Fields
Constructors
Methods
}
Exemple
/
*
*
*
Class
ArithGeomProgression
*
*
Represents
real
arithmetic-geometric
progression
with
constant
*
coefficients
u
n+1
=
*
u
+
b
*
*
author
AM
*
version
1.0
*
/
public
class
ArithGeomProgression
extends
Progression
{
//
FIELDS
private
double
//
multiplying
coefficient
private
double
b
//
additive
coefficient
//
CONSTRUCTORS
/
*
*
Define
an
arithmetic-geometric
progression
*
param
u0O
first
term
of
the
progression
*
param
multiplying
coefficient
*
param
b
additive
coefficient
*
/
public
ArithGeomProgression
double
u0
double
double
b
{
super
u0
this.a
=
this.b
=
b
}
//
METHODS
/
*
*
Given
current
term
u
return
the
next
term
u
n+1
*
/
public
double
nextTerm
double
u
{
return
*
u
+
b
}
}
//
end
class
ArithGeomProgression
3.3
Interfaces
Remarque
liminaire
terme
``
interface
``
sémantique
multiple
cadre
programmation
Java
peut
prendre
selon
contexte
trois
sens
distincts
conceptuellement
apparentés
-
sens
informatique
commun
interface
``
jonction
entre
deux
éléments
matériels
logiciels
permettant
l'échange
d'information
``
exemple
l'interface
homme-machine
-
sens
programmation
objet
l'interface
d'une
classe
partie
visible
publique
classe
définit
typiquement
liste
membres
attributs
constructeurs
méthodes
non
privés
associés
leurs
commentaires
documentation
-
sens
spécifique
Langage
Java
interface
sorte
classe
abstraite
possédant
caractéristiques
particulières
définit
protocole
comportement
c'est
sens
défini
section
C'est
contexte
d'utilisation
donne
sens
mot
interface
interfaces
sens
Langage
Java
sortes
classes
abstraites
sans
aucun
détail
d'implémentation
possèdent
degré
d'abstraction
supérieur
celui
classes
abstraites
interfaces
-
méthodes
toutes
implicitement
abstraites
elles
n'ont
corps
-
noter
qu'il
n'est
recommandé
d'ajouter
modificateur
abstract
puisqu'il
implicite
-
possèdent
champs
l'exception
éventuelle
constantes
classe
implicitement
static
final
assignées
-
membres
implicitement
publics
l'interface
publique
interface
spécifie
signature
minimale
d'une
classe
l'implémente
interface
contrat
respecter
Quand
classe
implémente
interface
s'engage
conformer
interface
classe
peut
implémenter
plusieurs
interfaces
classe
définit
type
implémentation
interface
définit
type
sans
implémentation
3.3.1
Interface
Syntaxe
public
interface
InterfaceName
{
constantAttributes
abstractMethods
}
Exemple
public
interface
Measurable
{
double
size
/
*
*
return
-1
0
1
if
this
is
=
or
than
x
*
/
int
isLargerThan
Measurable
x
}
3.3.2
Classe
implantant
interface
Syntaxe
public
class
ClassName
implements
InterfaceNamel
InterfaceName2
{
}
Exemple
public
class
Square
implements
Measurable
{
private
double
width
public
Square
double
_width
{
width
=
_width
}
public
double
size
{
return
width
*
width
}
public
int
isLargerThan
Measurable
x
{
if
this.size
x.size
{
return
-1
}
if
this.size
x.size
{
return
1
}
return
0
}
}
3.4
Enumération
classe
enum
permet
représenter
ensemble
constantes
nommées
type
classe
elle-même
classes
contribuent
accroître
lisibilité
programmes
Syntaxe
public
enum
EnumName
{
//
List
of
named
constants
//
Possibility
of
other
fields
and
methods.
}
Exemple
public
enum
Direction
{
NORTH
SOUTH
EAST
WEST
}
public
class
Test
{
private
Direction
dir
public
setDir
Direction
{
dir
=
}
public
boolean
isNorthSouth
{
return
dir
==
Direction.NORTH
||
dir
==
Direction.SOUTH
}
}
Sous
forme
plus
simple
classes
enum
souvent
utilisées
sous
forme
d'une
classe
interne
inner
class
Exemple
public
class
MyClass
{
private
Direction
dir
private
enum
Direction
{
NORTH
SOUTH
EAST
WEST
}
public
void
setNorth
{
dir
=
Direction.NORTH
}
}
-
possible
d'associer
chaque
constante
énumérée
valeur
d'un
type
quelconque
-
possible
d'utiliser
type
énuméré
instruction
switch
3.5
Classes
imbriquées
Nested
classes
concept
n'est
vital
débutant
classe
peut
être
définie
l'intérieur
d'une
autre
classe
parle
alors
classe
imbriquée
distingue
quatre
catégories
-
classes
membres
déclarées
static
static
nested
classes
membres
statiques
classe
englobante
-
classes
internes
inner
classes
membres
non
statiques
classe
englobante
-
classes
locales
local
classes
classes
définies
l'intérieur
d'une
méthode
-
classes
anonymes
anonymous
classes
classes
locales
sans
nom
Exemple
public
class
OuterClass
{
public
static
class
StaticNestedClass
{
}
private
class
InnerClass
{
}
}
//
Exemple
référence
classe
StaticNestedClass
//
OuterClass.StaticNestedClass
Quel
intérêt
peut-il
avoir
déclarer
classes
imbriquées
Potentiellement
regroupement
logique
encapsulation
accrue
code
plus
lisible
plus
facilement
maintenable
pratique
plupart
classes
imbriquées
classes
internes
Quant
classes
anonymes
elles
peuvent
rendre
code
difficile
lire
doivent
être
limitées
classes
très
petites
d'une
deux
méthodes
voir
exemple
typique
section
11.4.2
3.6
Contrôle
d'accès
modificateurs
contrôle
d'accès
membre
d'une
classe
peut
être
précisé
déclaration
mots-clés
appelés
modificateurs
modificateurs
permettent
spécifier
-
visibilité
champ
méthode
private
protected
public
-
lieu
stockage
classe
modificateur
static
l'objet
défaut
-
caractère
modifiable
défaut
non
modificateur
final
Modificateur
*
Commentaires
exemple
private
membre
déclaré
private
n'est
accessible
'
l'intérieur
classe
définition
Modificateur
d'accès
recommandé
champs
protected
membre
déclaré
protected
n'est
accessible
depuis
classe
déclaration
sous-classe
classe
paquetage
Modificateur
d'accès
recommandé
méthodes
super-
classes
public
membre
déclaré
public
accessible
depuis
n'importe
quelle
classe
Modificateur
d'accès
recommandé
méthodes
static
champ
déclaré
static
variable
classe
n'est
dupliqué
différentes
instances
champ
non
static
variable
d'instance
dupliqué
chaque
instance
méthode
déclarée
static
méthode
classe
invoquée
sans
référence
objet
particulier
faisant
référence
classe
méthode
non
static
méthode
d'instance
invoquée
objet
particulier
Voir
également
chapitre
14.
final
variable
déclarée
final
peut
plus
être
modifiée
après
qu'elle
initialisée
Cela
permet
particulier
déclarer
champs
constants
Exemple
final
int
SIZE
=
10
méthode
déclarée
final
peut
être
redéfinie
sous-classe
classe
déclarée
final
peut
être
sous-classée
*
Nota
défaut
modificateur
private
protected
public
visibilité
dite
package
access
``
membre
classe
visible
depuis
toutes
classes
paquetage
Exemple
public
static
final
double
GRAVITY
=
9.81
4
INSTANCE
CLASSE
Avant
pouvoir
être
utilisé
objet
-
instance
classe
-
doit
être
1
déclaré
ClassName
objectName
2
créé
puis
initialisé
objectName
=
new
constructorCall
Exemples
GregorianCalendar
cal
cal
=
GregorianCalendar
Timer
myTimer
=
new
Timer
déclaration
d'un
objet
crée
l'objet
uniquement
variable
pointeur
destinée
mémoriser
l'adresse
future
l'objet
création
l'objet
lui-même
i.e
l'instance
proprement
dite
réalisée
l'opérateur
new
L'appel
constructeur
suit
l'opérateur
new
rôle
d'initialiser
proprement
l'objet
ainsi
créé
In
fine
l'adresse
l'objet
ainsi
créé
initialisé
adresse
renvoyée
l'opérateur
new
stockée
grâce
l'opérateur
d'affectation
=
variable
préalablement
déclarée
Quelques
précisions
importantes
*
Déclaration
déclaration
ClassName
objectName
crée
variable
nom
objectName
type
référence
i.e
pointeur
l'initialise
automatiquement
null
null
constante
littérale
prédéfinie
Java
peut
être
assignée
toute
variable
type
référence
identifie
pointeur
nul
variable
valeur
null
pointe
vers
aucun
objet
Toute
tentative
référer
objet
partir
d'un
pointeur
null
engendre
erreur
compilation
d'exécution
selon
contexte
*
Gestion
dynamique
mémoire
L'opérateur
new
crée
l'instance
classe
zone
mémoire
générale
appelée
``
tas
``
contient
toutes
données
allouées
l'exécution
n'ayant
portée
locale
L'objet
ainsi
créé
conserve
portée
globale
reste
``
vivant
``
tant
qu'on
dispose
d'une
référence
i.e
pointeur
permettant
'
accéder
Quand
objet
n'est
plus
référencé
devient
définitivement
inaccessible
meurt
``
espace
mémoire
automatiquement
désalloué
récupération
automatique
espace
mémoire
réalisée
processus
appelé
ramasse-miettes
garbage
collector
façon
détruire
objet
d'assigner
valeur
null
variables
font
référence
directement
indirectement
5
TYPES
DONNEES
Java
connaît
deux
types
données
-
types
primitifs
données
type
primitif
stockées
directement
variables
sémantique
valeur
i.e
c'est
valeur
copiée
quand
variable
affectée
autre
variable
-
types
objet
types
référence
données
type
objet
stockées
sous
forme
référence
objet
non
tant
qu'objet
Quand
variable
type
objet
affectée
autre
variable
seule
référence
copiée
l'objet
lui-même
Java
utilise
système
Unicode-4
interne
coder
caractères
chaînes
caractères
identificateurs
Chaque
caractère
Unicode
codé
16
bits
permet
représenter
nombreux
alphabets
grec
cyrillique
hébreu
arabe
ainsi
symboles
mathématiques
techniques
Bien
qu'Unicode
utilisé
certains
systèmes
d'exploitation
Windows
NT
Vista
exemple
plupart
systèmes
d'exploitation
utilisent
systèmes
codage
8
bits
sorte
transcodages
nécessaires
problèmes
d'incompatibilité
peuvent
survenir
l'affichage
5.1
Types
primitifs
Type
Description
Exemples
littéraux
Nombres
entiers
Types
signés
byte
octet
entier
8
bits
127
-128
short
entier
court
16
bits
32767
-32768
int
entier
32
bits
2147483647
-2147483648
long
entier
long
64
bits
5123456789L
-55L
Nombres
réels
Types
signés
float
réel
simple
précision
43.889F
341.159E-2F
double
réel
double
précision
45.63
-2.4E107
Autres
types
Types
non
signés
char
caractère
seul
16
bits
'
'
'\u00F6'
boolean
valeur
booléenne
false
true
+
nombre
sans
point
décimal
interprété
comme
entier
type
int
immédiatement
converti
byte
short
long
lors
l'affection
peut
déclarer
littéral
type
long
l'affectant
suffixe
+
nombre
point
décimal
interprété
comme
réel
type
double
peut
déclarer
littéral
type
float
l'affectant
suffixe
F
+
caractère
littéral
peut
être
écrit
sous
forme
d'un
unique
caractère
Unicode
entre
apostrophes
d'une
valeur
Unicode
précédée
'\u
'
+
deux
littéraux
booléens
true
false
+
variables
d'un
type
primitif
référant
objets
elles
n'ont
méthodes
associées
5.2
Types
objet
types
référence
Tous
types
autres
types
primitifs
types
objet
incluent
classes
non
abstraites
bibliothèques
standard
Java
tels
type
String
exemple
ainsi
classes
définies
l'utilisateur
variable
d'un
type
objet
contient
référence
pointeur
objet
affectations
passages
paramètres
sémantique
référence
i.e
c'est
référence
copiée
non
l'objet
lui-même
Après
l'affectation
d'une
variable
autre
deux
variables
réfèrent
objet
s'agit
d'une
copie
surface
opposition
copie
profonde
dupliquerait
objets
deux
variables
alors
dites
alias
objet
5.2.1
Classes
enveloppes
classes
enveloppes
permettent
transformer
type
simple
objet
opération
appelée
anglais
boxing
Classe
enveloppe
Type
primitif
Boolean
boolean
Byte
byte
Character
char
Double
double
Float
float
Integer
int
Long
long
Short
short
Exemples
//
convert
primitive
type
wrapper
type
Integer
k
=
new
Integer
456
//
convert
wrapper
type
primitive
type
double
x
=
K.doubleValue
classes
enveloppes
utiles
quand
méthode
n'accepte
types
simples
requiert
objets
Toutefois
depuis
plate-forme
5.0
voir
chapitre
16
valeurs
type
primitif
cas
besoin
implicitement
converties
l'objet
classe
enveloppe
correspondante
autoboxing
réciproquement
unboxing
Auparavant
conversion
devait
être
explicite
objets
telles
classes
immuables
immutable
c'est-à-dire
non
modifiables
fois
créés
conséquence
méthode
peut
avoir
paramètres
sortie
tels
types
classes
enveloppes
présentent
surtout
l'intérêt
d'offrir
méthodes
conversion
type
primitif
-
String
ainsi
utilitaires
données
type
primitif
Exemple
//
Convert
String
type
-
primitive
type
double
x
=
Double.parseDouble
``
3.14159
``
5.2.2
Chaîne
caractères
non
modifiable
String
Bien
chaînes
caractères
type
String
objets
n'est
nécessaire
d'avoir
recours
l'opérateur
new
créer
caractères
d'une
chaîne
caractères
chaine
indicés
0
chaine.length
-1
chaîne
caractères
littérale
notée
entre
apostrophes
L'opérateur
+
l'opérateur
concaténation
chaînes
produit
nouvelle
chaîne
sans
éléments
physiquement
partagés
opérandes
comparaison
deux
chaînes
caractère
caractère
nécessite
faire
appel
fonction
equals
l'opérateur
==
donnant
résultat
intuitivement
attendu
cas
particulier
objets
type
String
immuables
immutable
c'est-à-dire
non
modifiables
fois
créés
conséquence
méthode
peut
avoir
paramètres
sortie
type
String
classe
String
appartient
paquetage
java.lang
Exemple
String
chaine
=
``
Exemple
n°
+
1
+
``
chaine
littérale
System.out.println
``
Longueur
\
+
chaine
+
``
\
=
+
chaine.length
5.2.3
Chaîne
caractères
modifiable
StringBuffer
chaînes
caractères
contrairement
chaînes
type
String
peuvent
être
modifiées
L'opérateur
new
indispensable
créer
chaîne
type
StringBuffer
classe
StringBuffer
appartient
paquetage
java.lang
Exemple
StringBuffer
chaine
chaine
=
new
StringBuffer
``
Meeting
at
6
pm
chaine.setCharAt
11
'
5
'
//
meeting
at
5
and
not
6
System.out.println
chaine
5.2.4
Tableau
tableau
collection
taille
fixe
d'éléments
type
Chaque
élément
repéré
indice
permet
accès
direct
l'élément
tout
tableau
automatiquement
associée
classe
dérivée
d'Object
partagée
tous
tableaux
type
d'éléments
L'attribut
d'instance
length
champ
public
non
méthode
contient
nombre
d'éléments
tableau
éléments
d'un
tableau
array
indicés
0
array.length
-
1
Quand
tente
d'accéder
élément
l'indice
hors
plage
permise
exception
type
IndexOutOfBoundsException
levée
noter
qu'un
tableau
caractères
n'est
objet
type
Siring
réciproquement
Syntaxe
cas
d'un
tableau
mono-dimensionnel
//
Declaring
an
array
variable
TypeOfElements
arrayVariable
//
Creating
an
array
object
arrayVariable
=
new
TypeOfElements
numberOfElements
//
Referring
to
an
element
arrayVariable
integerIndex
Exemple
//
Declaring
an
array
variable
private
double
marks
//
Creating
an
array
object
static
final
int
NB_OF_STUDENTS
=
48
marks
=
new
double
NB_OF_STUDENTS
//
Using
an
array
object
for
int
1
=
0
1
marks.length
i++
{
marks
i
=
Math.random
*
20.0
System.out.println
``
marks
``
+
1
+
``
=
``
+
marks
i
}
Exemple
static
final
int
NROW
10
static
final
int
NCOL
=
20
String
matrix
=
new
String
NROW
NCOL
possible
créer
d'initialiser
tableau
déclaration
Exemple
int
=
{
150
-300
40
500
}
System.out.println
0
+
``
``
+
3
//
150
500
String
=
{
{
``
Mr
``
``
Mrs
``
``
Ms
``
}
//
row
0
{
``
Smith
``
Jones
}
//
row
1
}
System.out.print
0
2
+
1
1
//
Ms
Jones
classe
java.util.Arrays
offre
diverses
méthodes
utilitaires
applicables
tableaux
comparaison
tri
......
Depuis
plate-forme
5.0
voir
chapitre
16
Java
offre
boucle
For
simplifiée
parcourir
éléments
d'un
tableau
Exemple
//
for
each
element
of
my
array
of
doubles
print
this
element
for
double
e
myArrayOfDoubles
{
System.out.println
e
}
5.2.5
Collection
collection
objet
représentant
groupe
d'objets
collection
agrégat
regroupe
éléments
multiples
seule
entité
Aucune
hypothèse
n'est
faite
priori
type
éléments
l'ordre
éléments
possibilité
d'éléments
dupliqués
Plus
formellement
Java
collection
d'éléments
type
E
classe
implémente
l'interface
Collection
E
paquetage
standard
java.util
offre
variété
collections
collections
framework
répondent
besoins
plus
fréquents
exemple
ArrayList
E
Vector
E
LinkedList
E
Stack
E
Hashtable
K
V
5.2.5.1
Généricité
notion
n'existe
Java
depuis
plate-forme
5.0
voir
chapitre
16
version
5.0
introduit
révision
majeure
rapport
précédente
notamment
matière
gestion
collections
L'apparition
types
génériques
probablement
l'évolution
plus
marquante
généricité
permet
communiquer
compilateur
type
éléments
d'une
collection
moment
création
l'objet
non
fixant
priori
définition
classe
Exemple
classe
générique
//
Defining
generic
collection
//
The
formal
parameter
is
the
generic
type
of
the
elements
public
class
MyCollection
implements
List
{
//
can
be
used
here
any
type
}
//
Creating
collection
of
Integers
MyCollection
Integer
collectionOfIntegers
CollectionOfIntegers
=
new
MyCollection
Integer
//
Creating
collection
of
Strings
MyCollection
String
collectionOfStrings
CollectionOfStrings
=
new
MyCollection
String
Tout
comme
déclarations
type
peuvent
être
génériques
déclarations
méthodes
peuvent
être
aussi
génériques
c'est-à-dire
paramétrisées
plusieurs
paramètres
Exemple
méthode
générique
//
Defining
public
static
void
fromArrayToCollection
Collection
{
for
o
{
c.add
o
}
}
//
Using
it
String
a1
=
{
``
datal
``
data2
``
data3
``
data4
``
data5
}
Collection
Object
c1
=
new
ArrayList
String
fromArrayToCollection
a1
c1
Nota
signaler
tableaux
génériques
font
encore
bon
ménage
Exemple
Vector
Integer
sheets
=
new
Vector
Integer
NBOFSHEETS
produit
l'erreur
classique
``
Generic
array
creation
exemple
solution
pourrait
consister
passer
classe
intermédiaire
simplement
définie
class
VectorOfIntegers
extends
Vector
Integer
{
}
type
appelé
type
joker
wildcard
type
permet
représenter
tout
type
Exemple
public
void
printAll
Collection
{
for
Object
o
{
System.out.println
o
}
}
possible
borner
type
joker
caractère
joker
borne
supérieure
spécifié
extends
Type
représente
tous
sous-types
Type
caractère
joker
borne
inférieure
spécifié
super
Type
représente
tous
types
super-types
Type
5.2.5.2
Exemple
collection
ArrayList
objet
type
ArrayList
E
collection
taille
variable
d'éléments
type
E.
Chaque
élément
repéré
indice
permet
accès
direct
l'élément
liste-tableau
supporte
principales
fonctionnalités
suivantes
-
ajout
d'un
élément
fin
tableau
méthode
add
E
-
accès
élément
d'indice
donné
méthodes
get
int
add
int
E
-
suppression
d'un
élément
d'indice
donné
méthode
remove
int
-
consultation
nombre
d'éléments
méthode
size
éléments
d'un
objet
collection
type
ArrayList
E
indicés
0
collection.size
-
1
classe
ArrayList
E
doit
être
importée
paquetage
java.util
import
java.util.ArrayList
Exemple
ArrayList
Integer
myCollectionOfIntegers
myCollectionOfIntegers
=
new
ArrayList
Integer
for
int
1
=
0
1
10
i++
{
listOfintegers.add
i
0
}
5.2.5.3
Parcours
d'une
collection
Itérateur
parcours
d'une
collection
l'opération
consiste
explorer
collection
élément
élément
Deux
façons
faire
parcourir
collection
-
utiliser
itérateur
itérateur
objet
type
Iterator
E
trois
fonctionnalités
plus
utiles
créer
gérer
itérateur
méthodes
iterator
classe
Collection
hasNext
next
classe
Iterator
noter
suppression
d'éléments
collection
cours
parcours
relève
méthode
remove
l'itérateur
non
celle
collection
classe
Iterator
E
doit
être
importée
paquetage
java.util
import
java.util.Iterator
itérateurs
façon
faire
historique
parcourir
collection
Depuis
version
5.0
génériques
-
utiliser
boucle
for
généralisée
telle
boucle
permet
s'affranchir
itérateurs
parcourir
très
simplement
collection
quelconque
n'est
offerte
depuis
version
5.0
Exemple
parcours
itérateur
Iterator
Integer
it
=
myCollectionOfIntegers.iterator
while
it.hasNext
{
//
call
it.next
to
get
the
next
object
of
the
collection
//
and
do
something
with
that
object
}
Exemple
parcours
sans
itérateur
//
for
each
element
of
my
collection
of
Integers
print
it
for
Integer
v
myCollectionOfIntegers
{
System.out.println
v
}
5.3
Transtypage
transtypage
anglais
cast
/
casting
opération
consiste
convertir
type
d'une
expression
conversion
type
réalise
faisant
précéder
l'expression
type
cible
entre
parenthèses
proposition
s'applique
certains
types
primitifs
types
objets
liés
relation
d'héritage
conversions
incorrectes
provoquent
erreur
compilation
l'exécution
noter
qu'un
transtypage
change
type
variables
concernées
type
d'une
variable
défini
fois
toute
dès
création
l'opération
transtypage
simplement
changement
point
vue
qu'on
demande
compilateur
Syntaxe
newType
expression
Exemple
int
=
87
char
=
char
/
2
certaines
classes
offrent
méthodes
spécifiques
plus
adéquates
notamment
°
conversions
réel
-
entier
-
méthode
Math
round
realValue
permet
convertir
réel
l'entier
plus
proche
-
méthode
Math.floor
realValue
associée
conversion
entier
fournit
plus
grand
entier
inférieur
égal
l'argument
Exemple
int
Math.floor
15.7
vaut
15
-
méthode
Math.ceil
realValue
associée
conversion
entier
fournit
plus
petit
entier
supérieur
égal
l'argument
Exemple
int
Math.cei1
15.7
vaut
16
°
conversions
partir
String
-
méthode
toString
hérite
tout
objet
permet
convertir
objet
String
-
méthode
valueOf
primitiveTypeExpression
classe
String
renvoie
représentation
String
valeur
argument
-
méthode
valueOf
string
dispose
toute
classe
enveloppe
renvoie
instance
classe
enveloppe
contenant
valeur
représentée
l'argument
type
String
Exemples
//
Convert
String
type
-
primitive
type
double
x
=
Double.parseDouble
``
3.14159
//
Convert
String
type
-
wrapped
type
Double
pi
=
Double.valueOf
``
3.14159
//
Convert
wrapped
type
-
primitive
type
int
k
=
Integer.valueOf
``
1789
.intValue
//
Convert
primitive
type
-
String
type
String
piStr
=
String.valueOf
3.14159
//
Convert
primitive
type
-
String
type
Double
pi
=
new
Double
3.14159
String
=
pi.toString
Autoboxing
/
unboxing
Depuis
plate-forme
5.0
voir
chapitre
16
valeurs
type
primitif
cas
besoin
implicitement
converties
l'objet
classe
enveloppe
correspondante
autoboxing
réciproquement
unboxing
Auparavant
conversion
devait
être
explicite
6
OPERATEURS
EXPRESSIONS
Java
possède
nombre
considérable
d'opérateurs
arithmétiques
logiques
expressions
constituées
d'opérandes
d'opérateurs
opérandes
peuvent
être
différentes
natures
variable
constante
appel
fonction
expression
tous
opérateurs
doivent
être
explicites
Quand
plus
d'un
opérateur
apparaît
seule
expression
alors
règles
précédence
utilisées
déterminer
l'ordre
d'application
S'il
nécessaire
d'altérer
l'ordre
normal
d'évaluation
parenthèses
peuvent
être
utilisées
précédences
égales
l'expression
évaluée
gauche
droite
Recommandations
style
+
Utiliser
parenthèses
isoler
sous-expressions
afin
d'éviter
problèmes
précédence
d'opérateur
rendre
code
plus
lisible
tout
programmeur
+
Insérer
espace
avant
après
chaque
opérateur
autre
point
6.1
Opérateurs
expressions
arithmétiques
Quelques
opérateurs
arithmétiques
binaires
Opérateur
Fonction
Champ
d'application
/
division
réelle
Réels
/
division
entière
Entiers
#
modulo
reste
division
entière
*
Entiers
*
Nota
1
Java
comme
plupart
langages
programmation
B
toujours
signe
alors
qu'en
mathématiques
reste
division
euclidienne
toujours
positif
quotient
calculant
conséquence
Java
A/B
=
sgn
*
sgn
B
*
|A|/|B|
B
=
A-
A/B
*
B
-7
5
-7
/
5
java
-2
-1
math
3
-2
*
Nota
2
Java
l'opérateur
modulo
peut
aussi
être
appliqué
réels
résultat
alors
reste
obtenu
après
soustraction
l'opérande
droit
l'opérande
gauche
nombre
entier
fois
Toutefois
cause
arrondis
calculs
résultat
n'est
toujours
celui
qu'on
attendrait
exemple
64.5
6.45
donne
6.449999999999998
non
0.0
Grande
prudence
opérateur
appliqué
réels
Quelques
opérateurs
arithmétiques
unaires
Opérateur
Fonction
Champ
d'application
++
Incrémentation
Entiers
réels
décrémentation
Entiers
réels
6.2
Opérateurs
expressions
booléennes
Quelques
opérateurs
booléens
binaires
Opérateur
Fonction
&
&
logique
conditionnel
*
||
logique
conditionnel
*
^
logique
exclusif
*
opérateurs
l'évaluation
l'expression
logique
s'arrête
dès
qu'il
possible
d'inférer
valeur
finale
l'expression
tous
opérandes
nécessairement
évalués
Opérateur
booléen
unaire
Opérateur
Fonction
Négation
logique
6.3
Opérateurs
relationnels
Quelques
opérateurs
relationnels
comparaison
Opérateur
Fonction
==
égal
=
non
égal
inférieur
=
inférieur
égal
supérieur
=
supérieur
égal
7
METHODES
7.1
Définition
appel
d'une
méthode
ordinaire
Définition
d'une
procédure
Définition
d'une
fonction
public
void
procName
formalParams
public
fctlype
fctName
formalParams
{
{
declarations
declarations
statements
statements
}
return
expression
}
Appel
d'une
procédure
Appel
d'une
fonction
Appel
interne
classe
définition
Appel
interne
classe
définition
procName
actualParams
variable
=
fctName
actualParams
Appel
externe
classe
définition
Appel
externe
classe
définition
-
méthode
d'instance
-
méthode
d'instance
objectName.procName
actualParams
variable
=
objectName.fctName
actualParams
-
méthode
classe
-
méthode
classe
ClassName.procName
actualParams
variable
=
ClassName
fctName
actualParams
Déclaration
d'un
paramètre
formel
Spécification
d'un
paramètre
effectif
formal
parameter
actual
parameter
Paramètre
d'entrée
type
primitif
objet
Paramètre
d'entrée
type
primitif
objet
parameterType
parameterName
Expression
Paramètre
sortie
type
primitif
Paramètre
sortie
type
primitif
Impossible
utiliser
fonction
passer
Impossible
paramètre
type
objet
Paramètre
sortie
type
objet
Paramètre
sortie
type
objet
parameterType
parameterName
objectName
+
paramètres
spécifiés
définition
d'une
méthode
appelés
paramètres
formels
doivent
être
précédés
type
paramètres
apparaissant
forme
d'appel
appelés
paramètres
effectifs
S'il
plusieurs
paramètres
séparés
virgules
+
Tous
paramètres
type
primitif
passés
valeur
c'est
copie
argument
transmise
méthode
dispose
l'original
Tous
paramètres
type
objet
passés
référence
c'est
référence
i.e
pointeur
transmis
méthode
l'objet
lui-même
+
défaut
méthodes
méthodes
d'instance
elles
invoquées
instance
classe
existe
aussi
méthodes
classe
peuvent
être
invoquées
sans
instance
spécifie
méthode
classe
déclarant
static
+
signature
1
d'une
méthode
constituée
nom
liste
types
paramètres
classe
deux
méthodes
peuvent
avoir
signature
elles
peuvent
toutefois
porter
nom
cela
s'appelle
surcharge
+
toute
méthode
d'instance
constructeur
peut
référer
l'objet
courant
i.e
l'objet
méthode
constructeur
cours
d'appel
mot
clé
this
peut
ainsi
référer
tout
membre
champ
méthode
l'objet
courant
identifiant
forme
this.membre
7.2
Constructeur
constructeur
méthode
particulière
l'invocation
explicitement
associée
création
d'une
instance
classe
finalité
d'initialiser
proprement
l'état
objet
lors
création
définition
d'un
constructeur
suit
règles
syntaxiques
spécifiques
nom
d'un
constructeur
obligatoirement
nom
classe
d'appartenance
l'en-tête
définition
spécifie
type
Syntaxe
définition
d'un
constructeur
d'une
classe
nom
ClassName
public
ClassName
formalParameters
{
//
Fields
initializations
}
constructeur
typiquement
utilisé
association
l'opérateur
new
Exemple
syntaxe
d'utilisation
d'un
constructeur
d'une
classe
nom
ClassName
ClassName
object
=
new
ClassName
actualParameters
classe
peut
comporter
plusieurs
constructeurs
sous
condition
qu'ils
n'aient
mêmes
paramètres
cas
éviter
duplication
code
constructeur
peut
appeler
autre
syntaxe
this
actualParameters
Exemple
public
class
Point
{
private
int
x
public
Pointe
int
x
int
{
//
first
constructor
this.x
=
X
this.y
=
}
public
Point
{
//
second
constructor
this
0
0
}
//
}
1
noter
définition
adoptée
Java
prend
considération
type
méthode
sens
``
signature
``
correspond
parfois
appelé
ailleurs
``
profil
``
méthode
7.3
Méthode
main
méthode
main
comme
C++
point
d'entrée
d'une
application
lancement
l'exécution
Syntaxe
public
static
void
main
String
args
{
}
L'argument
args
capte
éventuels
arguments
ligne
commande
premier
argument
ligne
commande
stocké
args
0
non
args
1
comme
C/C++
Exemple
Considérons
application
classe
principale
-
celle
contenant
méthode
main
-
s'appelle
Game
Supposons
l'application
dépende
deux
paramètres
valeurs
doivent
être
fournies
lancement
Supposons
également
fichier
source
Game
java
compilé
fichier
exécutable
Game.class
lancement
l'application
commande
java
Game
Daniel
20
attribuera
args
tableau
{
``
Daniel
``
20
}
8
INSTRUCTIONS
plan
syntaxique
instructions
statements
peuvent
être
regroupées
3
grandes
catégories
-
instructions
simples
instructions
d'affectation
instructions
d'entrée
/
sortie
instructions
d'appel
procédure
instruction
simple
termine
toujours
point-virgule
point-virgule
seul
définit
instruction
vide
-
instructions
contrôle
instructions
sélection
instructions
boucle
instructions
rupture
séquence
-
blocs
d'instructions
bloc
d'instructions
-
aussi
appelé
instruction
composée
-
séquence
d'instructions
enserrée
entre
accolades
bloc
{
}
définit
instruction
vide
8.1
Instruction
d'affectation
Syntaxe
variable
=
expression
symbole
=
l'opérateur
d'affectation
valeur
l'expression
située
partie
droite
affectée
variable
spécifiée
partie
gauche
type
l'expression
doit
s'apparier
type
variable
L'impact
physique
différent
selon
l'expression
type
primitif
objet
voir
chapitre
5
8.2
Instructions
contrôle
8.2.1
Instructions
sélection
8.2.1.1
if-else
Première
forme
Deuxième
forme
if
expression
{
if
expression
{
statements
statements
}
}
else
{
statements
}
Exemple
if
field.size
==
0
{
System.out.println
``
The
field
is
empty
``
}
Exemple
if
number
0
{
reportError
}
else
{
processNumber
number
}
Exemple
if
0
{
handleNegative
}
else
if
==
0
{
handlezero
}
else
{
handlePositive
}
8.2.1.2
switch
Première
forme
Deuxième
forme
switch
expression
{
switch
expression
{
case
value1
case
value1
statements
/
*
falls
through
*
/
break
case
value2
case
value2
/
*
falls
through
*
/
statements
case
value3
break
statements
default
break
statements
case
value4
break
/
*
falls
through
*
/
}
case
value5
statements
break
default
statements
break
}
+
instruction
switch
peut
avoir
nombre
quelconque
labels
case
+
L'instruction
break
met
fin
l'instruction
switch
défaut
d'instruction
break
l'exécution
poursuit
instructions
labels
suivants
deuxième
forme
ci-
dessus
exploite
comportement
chacune
trois
premières
valeurs
conduira
l'exécution
partie
statements
associée
value3
chacune
deux
valeurs
suivantes
conduira
l'exécution
partie
statements
associée
value5
+
clause
default
optionnelle
recommandée
défaut
peut
qu'aucun
cas
conduise
exécution
Exemple
switch
day
{
case
1
dayString
=
``
Monday
break
case
2
dayString
=
``
Tuesday
break
case
3
dayString
=
``
Wednesday
break
case
4
dayString
=
``
Thursday
break
case
5
dayString
=
``
Friday
break
case
6
dayString
=
``
Saturday
break
case
7
dayString
=
``
Sunday
break
default
error
break
}
Exemple
switch
winterMonth
{
case
11
numberOfDays
=
30
break
case
12
/
*
falls
through
*
/
case
1
numberOfDays
=
31
break
case
2
if
isLeapYear
{
numberOfDays
=
29
}
else
{
numberOfDays
=
28
}
break
default
error
break
}
8.2.2
Instructions
boucle
8.2.2.1
while
boucle
while
exécute
bloc
d'instructions
aussi
longtemps
valeur
d'une
expression
donnée
true
L'expression
testée
avant
chaque
exécution
corps
boucle
bien
corps
boucle
peut
être
exécuté
0
fois
Syntaxe
while
expression
{
statements
}
Exemple
int
i
=
0
while
1
text.size
{
System.out.printl
text.get
i++
}
Exemple
while
iter.hasNext
{
processObject
iter.next
}
8.2.2.2
do-while
boucle
do-while
exécute
bloc
d'instructions
aussi
longtemps
valeur
d'une
expression
donnée
true
L'expression
testée
après
chaque
exécution
corps
boucle
bien
corps
boucle
toujours
exécuté
moins
1
fois
Syntaxe
do
{
statements
}
while
expression
Exemple
do
{
input
=
readInput
if
input
==
null
{
System.out.printl
``
Try
again
}
}
while
input
==
null
8.2.2.3
for
boucle
for
s'exécute
aussi
longtemps
qu'une
condition
s'évalue
true
Avant
boucle
démarre
instruction
d'initialisation
exécutée
exactement
1
fois
condition
évaluée
avant
chaque
exécution
corps
boucle
comme
boucle
while
instruction
mise
jour
variables
exécutée
après
chaque
exécution
corps
boucle
Syntaxe
for
initialization
condition
update
{
statements
}
Exemple
for
int
1
=
0
1
text.size
i++
{
System.out.println
text.get
}
8.2.2.4
foreach
Depuis
plate-forme
5.0
voir
chapitre
16
Java
offre
boucle
for
améliorée
parcourir
éléments
d'un
tableau
d'une
collection
reporter
sections
respectives
Syntaxe
//
for
each
element
of
the
collection
process
element
for
TypeOfElements
element
collectionOfElements
{
//
process
element
}
8.3
Instructions
d'entrée
/
sortie
Java
offre
nombre
considérable
fonctions
procédures
d'entrée
/
sortie
tant
mode
texte
graphique
limitons
section
principales
instructions
d'entrées/sorties
mode
texte
entrées/sorties
mode
graphique
voir
chapitre
11
méthodes
d'entrée
/
sortie
primaires
appartiennent
classes
paquetage
java
io
Depuis
plate-forme
5.0
voir
chapitre
16
classe
Scanner
paquetage
java.uti1
offre
-
fonctionnalités
base
lire
facilement
données
depuis
tout
flux
d'entrée
-
sorties
formatées
comme
complément
classe
java.util.Formatter
permet
spécifier
formats
d'entrée
sortie
8.3.1
Notion
flux
flux
flots
streams
anglais
généralisent
notion
périphérique
d'entrée
/
sortie
flux
peut
être
vu
comme
interface
intelligente
unidirectionnelle
reliant
machine
Java
périphérique
permet
lecture
aussi
bien
qu'en
écriture
s'affranchir
spécificités
périphérique
concerné
Réaliser
entrée
/
sortie
consiste
ainsi
1
créer
flux
type
approprié
sauf
s'il
existe
déjà
prédéfini
System.in
System.out
System.err
2
lire
écrire
selon
cas
flux
3
souvent
cas
d'une
lecture
convertir
donnée
lue
type
cible
souhaité
première
approche
limiterons
flux
accès
séquentiel
8.3.2
Entrée
/
sortie
terminal
solutions
suivantes
s'affranchissent
erreurs
saisie
gérer
type
d'erreur
reporter
chapitre
Exceptions
chapitre
10
8.3.2.1
Affichage
écran
Syntaxe
d'un
affichage
écran
mode
texte
System.out.print
string
System.out.println
string
System.out.print
primitiveTypeExpression
System.out.println
primitiveTypeExpresstion
8.3.2.2
Affichage
formaté
Depuis
plate-forme
5.0
Java
offre
également
méthode
printf
permettant
sorties
formatées
comme
voir
classe
java.util.Formatter
spécification
formats
Exemples
System.out.println
``
count
=
``
+
count
System.out.printf
``
5d
\n
user
total
Fonctionnement
printf
codes
formatage
printf
réclame
chaîne
caractères
premier
paramètre
chaîne
peut
être
suivie
variables
0
C'est
chaîne
peut
contenir
codes
formatage
imprimée
code
formatage
commence
caractère
chaque
fois
qu'un
code
formatage
rencontré
printf
imprime
variable
suivante
liste
paramètres
Principaux
codes
formatage
Commande
l'affichage
d'une
valeur
type
Caractère
Entier
e
Réel
notation
exposant
f
Réel
#
Chaîne
caractères
code
formatage
peut
inclure
spécification
format
champ
d'affichage
Exemples
codes
formatage
Champ
d'affichage
spécifié
paramètre
type
considéré
6d
Champ
6
caractères
-6d
Champ
6
caractères
justification
gauche
8.2f
Champ
8
caractères
2
droite
virgule
8.3.2.3
Lecture
clavier
Exemple
Scanner
input
=
new
Scanner
System.in
String
s1
=
input.next
//
read
string
word
String
s2
=
input.nextLine
//
read
the
rest
of
the
line
int
=
input.nextInt
//
read
an
integer
double
r
=
input.nextDouble
//
read
double
input.close
8.3.3
Entrée
/
sortie
fichier
Opérer
fichier
consiste
1
créer
flux
approprié
opérations
souhaitées
2
lire
écrire
fichier
3
fermer
fichier
solutions
suivantes
s'affranchissent
erreurs
d'entrée
/
sortie
gérer
type
d'erreur
reporter
chapitre
Exceptions
chapitre
10
8.3.3.1
Ecriture
fichier
Depuis
plate-forme
5.0
Java
offre
également
méthode
printf
permettant
sorties
formatées
comme
voir
classe
java.util.Formatter
spécification
formats
Exemple
d'écriture
fichier
texte
PrintWriter
out
=
new
PrintWriter
outputFileName
for
int
i=0
i
10
i++
out.printf
``
'\t
'
i
out.close
8.3.3.2
Lecture
fichier
Exemple
lecture
d'un
fichier
texte
mot
mot
Scanner
in
=
new
Scanner
new
File
inputFileName
String
while
in.hasNext
{
=
in.next
//
read
string
word
System.out.println
}
in.close
8.3.3.3
Contextes
particuliers
Cas1
Ouverture
lecture
d'un
fichier
texte
stocké
fichier
.jar
exécuté
import
java.io.InputStream
import
java.util.Scanner
ClassLoader
cl
=
ClassLoader.getSystemClassLoader
InputStream
is
=
cl.getResourceAsStream
inputFileName
Scanner
in
=
new
Scanner
is
Cas2
Ouverture
lecture
d'un
fichier
texte
distant
identifié
URL
import
java.net.URL
import
java.util.Scanner
URL
url
=
new
URL
``
http
//www.esiee.fr/
/inputFileName
Scanner
in
=
new
Scanner
url.openStream
Nota
Solution
non
applicable
depuis
applet
outre
bien
s'assurer
toutes
conditions
d'accessibilité
fichier
levées
d'interdiction
pare-feu
local
notamment
Cas3
Ouverture
d'une
nouvelle
page
html
depuis
applet
répertoire
import
java.net.URL
import
javax.swing.JApplet
URL
url
=
new
URL
getDocumentBase
``
myFile.html
getAppletContext
.showDocument
url
``
_blank
repaint
8.3.4
Lecture
d'une
chaîne
caractères
formatée
fréquent
d'avoir
lire
chaîne
caractères
connaît
format
quel
flux
d'entrée
terminal
fichier
Depuis
plate-forme
5.0
classe
Scanner
paquetage
java.util
offre
fonctionnalités
très
pratiques
Exemple
lecture
d'une
chaîne
caractères
formatée
String
str
=
``
1
XXX
2
XXX
yellow
XXX
blue
XXX
'
'
Scanner
in
=
new
Scanner
str
.useDelimiter
``
\\s
*
XXX\\s
*
System.out.println
in.nextInt
System.out.println
in.nextInt
System.out.println
in.next
System.out.println
in.next
in.close
//
Will
display
//
1
//
2
//
yellow
//
blue
9
HERITAGE
9.1
Notion
d'héritage
L'héritage
technique
offre
nombreux
avantages
-
évite
duplication
code
-
permet
réutilisation
code
autre
contexte
-
facilite
maintenance
programmes
-
facilite
l'extension
d'applications
existantes
L'héritage
inheritance
relation
``
est_un
``
non
``
a_un
``
permet
définir
classe
comme
l'extension
d'une
autre
Exemple
Classe
Astre
est_un
est_un
Classe
Etoile
Classe
Planète
étoile
astre
planète
astre
classe
Etoile
étend
classe
Astre
=
classe
Etoile
hérite
classe
Astre
super-classe
classe
étendue
d'autres
classes
sous-classe
classe
étend
hérite
autre
classe
hérite
l'état
comportement
tous
ancêtres
peut
aussi
redéfinir
classes
liées
relations
d'héritage
forment
hiérarchie
d'héritage
Exemple
hiérarchie
d'héritage
Astre
Etoile
Planète
Exoplanète
Planète
Solaire
Pégaside
Chtonienne
Tellurique
Habitable
constructeur
d'une
sous-classe
doit
toujours
invoquer
constructeur
super-classe
première
instruction
défaut
Java
essaiera
d'insérer
appel
automatique
forme
d'appel
suivante
super
actualParameters
Toute
classe
sans
super-classe
explicite
Object
comme
super-classe
Comme
hiérarchie
classes
types
forment
hiérarchie
types
type
défini
définition
d'une
sous-classe
sous-type
type
défini
super-classe
Exemple
Etoile
sous-type
type
Astre
variable
peut
contenir
-
objet
type
déclaré
variable
-
objet
tout
sous-type
type
déclaré
Exemple
Astre
al
=
new
Astre
//
correct
Astre
a2
=
new
Etoile
//
correct
transtypage
ascendant
Astre
a3
=
new
Planete
//
correct
transtypage
ascendant
Etoile
el
=
new
Astre
//
erreur
Etoile
e3
=
Etoile
a2
//
correct
transtypage
descendant
//
doit
être
explicite
objet
d'un
sous-type
peut-être
utilisé
partout
objet
d'un
super-type
attendu
Ceci
s'appelle
substitution
Java
permet
l'héritage
multiple
sous-classe
peut
hériter
directement
d'une
seule
super-classe
9.2
Qu'hérite
sous-classe
sous-classe
hérite
tous
membres
super-classe
accessibles
sauf
membre
attribut
méthode
redéfini
sous-classe
sous-classe
hérite
super-classe
-
membres
déclarés
public
protected
-
membres
déclarés
sans
modificateur
d'accès
sous-classe
paquetage
super-classe
sous-classe
n'hérite
super-classe
-
membres
redéfinis
sous-classe
-
constructeurs
Attention
choix
identificateurs
sous-classe
choix
peut
involontairement
masquer
membre
super-classe
C'est
particulièrement
cas
attributs
attribut
nom
qu'un
attribut
super-classe
masque
l'attribut
super-
classe
s'ils
types
différents
9.3
Redéfinir
méthode
redéfinir
méthode
sous-classe
faut
qu'elle
signature
type
retour
méthode
super-classe
méthode
redéfinie
peut
autoriser
accès
plus
large
moins
ex
méthode
déclarée
protected
super-
classe
peut
être
redéfinie
public
sous-classe
private
L'exemple
typique
méthode
toString
classe
Object
appliquée
objet
produit
chaîne
caractères
formée
nom
classe
code
hachage
méthode
peut
être
redéfinie
toute
classe
méthode
redéfinie
sous-classe
simplement
besoin
d'ajouter
quelques
fonctionnalités
complémentaires
celles
méthode
super-classe
n'est
besoin
réécrire
complètement
car
peut
appeler
méthode
super-classe
super.superclassMethodName
actualParameters
Quelques
règles
-
méthode
d'instance
peut
redéfinir
méthode
classe
réciproquement
-
méthode
d'instance
d'une
sous-classe
mêmes
signature
type
qu'une
méthode
d'instance
super-classe
redéfinit
méthode
super-classe
version
méthode
invoquée
instance
sous-classe
type
dynamique
car
liaison
dynamique
méthodes
d'instance
celle
sous-classe
-
méthode
classe
d'une
sous-classe
mêmes
signature
type
qu'une
méthode
classe
super-classe
masque
méthode
super-classe
version
méthode
invoquée
dépend
appelée
super-classe
sous-classe
car
liaison
statique
méthodes
classe
-
sous-classe
peut
redéfinir
méthodes
déclarées
final
super-classe
-
sous-classe
doit
redéfinir
méthodes
déclarées
abstract
super-classe
moins
sous-classe
elle-même
déclarée
abstract
Depuis
plate-forme
5.0
voir
chapitre
16
conseillé
d'utiliser
l'annotation
méta-donnée
Override
marquer
toute
méthode
supposée
redéfinir
méthode
héritée
d'une
classe
parent
Cela
permet
compilateur
signaler
immédiatement
erreur
jamais
redéfinition
n'est
avérée
cause
exemple
d'une
faute
frappe
nom
méthode
outre
signalant
méthodes
redéfinies
l'annotation
Override
permet
d'accroître
lisibilité
code
covariance
types
retour
autorisée
méthode
d'une
sous-classe
peut
retourner
objet
type
sous-classe
type
retourné
méthode
signature
super-classe
caractéristique
supprime
besoin
tests
conversions
types
excessifs
Exemple
Override
public
String
toString
{
//
}
Exemple
classe
Point
possédant
deux
attributs
x
classe
ColoredPoint
héritant
Point
possédant
attribut
spécifique
color
comment
écrire
méthode
equals
sans
duplication
code
/
*
In
the
class
Point
*
/
Override
public
boolean
equals
Object
o
{
if
o
==
null
return
false
//
case
null
if
this
==
o
return
true
//
reflexivity
if
this.getClass
=
o.getClass
return
false
//
symmetry
//
Now
this
and
o
having
the
same
class
compare
the
fields
Point
p
=
Point
o
return
this.x
==
p.x
&
&
this.y
==
p.y
}
/
*
In
the
class
ColoredPoint
extending
Point
*
/
Override
public
boolean
equals
Object
o
{
//
Verify
if
this
and
o
have
the
same
class
and
if
their
super
//
fields
are
equal
if
super.equals
o
return
false
//
Now
compare
the
specific
fields
ColoredPoint
cp
=
ColoredPoint
o
return
this.color.equals
cp.color
}
Exemple
public
class
MotherClass
{
public
void
normal
{
System.out.println
``
the
normal
method
in
MotherClass
}
public
static
void
hide
{
System.out.println
``
the
hide
method
in
MotherClass
}
public
void
override
{
System.out.println
``
the
override
method
in
MotherClass
}
}
//
end
MotherClass
public
class
DaughterClass
extends
MotherClass
{
Override
public
static
void
hide
{
System.out.println
``
the
hide
method
in
DaughterClass
}
Override
public
void
override
{
System.out.println
``
the
override
method
in
DaughterClass
}
public
static
void
main
String
args
{
DaughterClass
o1
=
new
DaughterClass
MotherClass
o2
o1
o1.normal
//
call
super.normal
o2.normal
//
call
super.normal
o1.hide
//
call
this.hide
o2.hide
//
call
super.hide
liaison
statique
o1.override
//
call
this.override
o2.override
//
call
this.override
Tiaison
dynamique
}
}
//
end
DaughterClass
méthode
main
affichera
the
normal
method
in
MotherClass
the
normal
method
in
MotherClass
the
hide
method
in
DaugterClass
the
hide
method
in
MotherClass
the
override
method
in
DaugterClass
the
override
method
in
DaugterClass
9.4
Type
statique
/
dynamique
-
Liaison
statique
/
dynamique
section
reprend
formalise
quelques
uns
importants
concepts
introduits
sections
précédentes
9.4.1
Type
statique
/
dynamique
-
Transtypage
type
statique
d'un
objet
type
spécifié
déclaration
C'est
type
déclaré
C'est
type
compilation
type
dynamique
d'un
objet
type
i.e
classe
d'appartenance
l'objet
instancié
C'est
type
constaté
C'est
type
effectif
l'exécution
type
dynamique
d'un
objet
toujours
type
statique
sous-type
type
statique
sauf
exceptions
dues
transtypages
Exemple
classe
classe
B
sous-classe
Considérons
code
suivant
if
myClass.booleanRandom
{
=
new
}
else
{
=
new
B
//
transtypage
ascendant
implicite
}
type
statique
type
dynamique
B
pourra
être
constaté
qu'après
condition
évaluée
transtypage
casting
appliqué
référence
n'est
possibilité
d'avoir
vue
spécifique
l'objet
pointé
change
rien
type
l'objet
sous-jacent
garde
bien
évidemment
tout
long
vie
type
lequel
créé
L'opération
transtypage
purement
syntaxique
fait
qu'indiquer
compilateur
point
vue
depuis
lequel
doit
voir
l'objet
transtypage
vers
sur-type
dit
ascendant
transtypage
ascendant
implicite
transtypage
vers
sous-type
dit
descendant
transtypage
descendant
doit
être
explicite
permet
forcer
compilation
garantit
nécessairement
l'absence
d'erreur
d'exécution
transtypage
n'est
garanti
correct
s'il
respecte
règle
suivante
T1
T2
deux
types
définis
o
objet
type
dynamique
T3
Considérons
déclaration
T1
obj
=
T2
o
transtypage
garanti
possible
tant
compilation
'
l'exécution
seulement
T3
sous-type
T2
T2
sous-type
T1
L'opérateur
instanceof
permet
tester
objet
d'un
type
dynamique
donné
tout
sous-type
type
donné
peut
permettre
vérifier
compatibilité
types
avant
d'opérer
transtypage
Exemple
Supposons
définies
public
class
Shape2D
{
}
public
class
Circle
extends
Shape2D
{
}
public
class
Triangle
extends
Shape2D
{
}
public
class
Date
{
}
déclarations
suivantes
génèreraient
erreur
incompatibilité
types
Shape2D
=
Shape2D
new
Date
//
erreur
compilation
Circle
=
new
Shape2D
//
erreur
compilation
Circle
=
Circle
new
Shape2D
//
erreur
d'exécution
Triangle
=
new
Triangle
Circle
=
Circle
//
erreur
d'exécution
déclarations
suivantes
saines
Shape2D
=
new
Circle
Circle
=
Circle
Shape2D
if
obj
instanceof
Shape2D
=
Shaped2D
obj
9.4.2
Liaison
statique
/
dynamique
Considérons
l'invocation
o.m
o
objet
type
statique
type
dynamique
'
message
attribut
méthode
envoyé
o.
message
exécuté
celui
code
accessible
depuis
classe
alors
liaison
l'objet
message
dite
statique
liaison
compilation
sinon
dite
dynamique
liaison
l'exécution
java
-
liaison
d'un
objet
variables
d'instance
statique
-
liaison
d'un
objet
méthodes
dynamique
sauf
méthode
static
final
Exemple
public
class
{
public
boolean
m1
{
return
true
}
public
boolean
m2
{
return
true
}
}
public
class
B
extends
{
public
boolean
m1
{
return
false
}
public
boolean
m3
{
return
false
}
public
static
void
main
String
args
{
=
new
B
System.out.prinln
a.m1
System.out.prinln
a.m2
//
System.out.prinln
a.m3
//
problème
}
}
méthode
main
affichera
false
true
Pourquoi
type
statique
type
dynamique
B.
C'est
m1
B
exécutée
Quant
méthode
m2
n'est
définie
B
super-classe
B
hérite
normalement
m2
m2
exécutée
dernière
instruction
System.out.prinln
a.m3
provoquerait
erreur
compilation
Pourquoi
Parce
compilateur
connaît
type
statique
i.e
type
déclaré
méthode
m3
n'étant
définie
classe
super-classes
compilateur
trouve
définition
m3
bien
B
génère
erreur
solution
transtypage
descendant
préalable
System.out.prinln
B
.m3
transtypage
correct
car
possède
déjà
création
tous
attributs
d'une
instance
B.
9.5
Polymorphisme
appel
méthode
peut
invoquer
méthodes
différentes
car
liaison
réalisée
dynamiquement
i.e
l'exécution
non
compilation
l'identification
type
l'objet
associé
l'appel
dynamique
Exemple
polymorphisme
d'héritage
public
class
Shape
{
public
void
draw
{
System.out.println
this
+
``
.draw
}
}
public
class
Circle
extends
Shape
{
Override
public
String
toString
{
return
``
circle
}
}
public
class
Square
extends
Shape
{
Override
public
String
toString
{
return
``
square
}
}
public
class
Picture
{
public
static
void
main
String
args
{
Vector
Shape
v
=
new
Vector
Shape
v.add
new
Circle
v.add
new
Square
for
Shape
v
{
System.out.prinln
s.draw
//
polymorphism
}
méthode
main
affichera
circle.draw
square.draw
9.6
Classes
méthodes
particulières
classe
déclarée
final
peut
être
sous-classée
méthode
déclarée
final
peut
être
redéfinie
sous-classe
classe
déclarée
abstract
représente
concept
abstrait
peut
être
instanciée
peut
être
sous-classée
méthode
déclarée
abstract
méthode
corps
n'est
spécifié
classe
abstraite
peut
contenir
méthodes
non
abstraites
toute
classe
contenant
méthode
abstraite
doit
être
déclarée
abstract
sous-classe
n'implémente
toutes
méthodes
abstraites
super-classe
doit
être
déclarée
abstract
9.7
Interfaces
interface
sens
langage
Java
cf
section
3.3
protocole
comportement
peut
être
implanté
toute
classe
interface
dehors
hiérarchie
classes
interface
différencie
principalement
d'une
classe
abstraite
caractéristiques
-
aucune
méthode
concrète
opposition
abstraite
peut
être
définie
interface
-
classe
peut
implémenter
plusieurs
interfaces
Tout
comme
peut
construire
hiérarchie
classes
peut
construire
hiérarchie
d'interfaces
alors
qu'une
classe
peut
étendre
directement
qu'une
seule
super-classe
d'héritage
multiple
interface
peut
étendre
directement
plusieurs
super-interfaces
héritage
multiple
possible
Exemple
public
interface
List
E
extends
Collection
E
{
}
Exemple
public
interface
Predator
{
boolean
chasePrey
Prey
p
}
public
interface
Prey
{
boolean
isChasedBy
Predator
p
}
public
interface
Venomous
{
}
public
interface
VenomousPredator
extends
Predator
Venomous
{
}
public
class
Pet
{
}
public
class
Cat
extends
Pet
implements
Predator
{
}
public
class
Frog
implements
Predator
Prey
{
}
10
EXCEPTIONS
exception
objet
fournissant
informations
relatives
défaillance
programme
exception
générée
chacune
situations
suivantes
-
condition
d'exécution
anormale
comme
exemple
tentative
division
zéro
mémoire
insuffisante
-
exécution
d'une
instruction
throw
paquetage
java
lang
définit
nombre
classes
d'exception
couvrent
cas
plus
courants
10.1
Exceptions
contrôlées
non
contrôlées
Toute
exception
instance
classe
Throwable
sous-classes
Object
Throwable
Error
Exception
MyCheckedException
RunTimeException
MyUncheckedException
Java
divise
classes
d'exception
deux
catégories
-
exceptions
non
contrôlées
unchecked
exceptions
concernent
cas
imprévus
``
c'est-à-dire
situations
devrait
avoir
défaillance
fonctionnement
normal
Elles
concernent
situations
pourraient
être
raisonnablement
évitées
exemple
indice
tableau
hors
limite
exceptions
indiquent
généralement
erreur
programme
Elles
normalement
vocation
conduire
arrêt
immédiat
définitif
programme
-
exceptions
contrôlées
checked
exceptions
concernent
cas
``
prévus
``
c'est-à-dire
situations
programmeur
devrait
s'attendre
qu'une
opération
puisse
échouer
Elles
concernent
situations
défaillance
delà
contrôle
programmeur
exemple
disque
devenu
plein
rendant
impossible
écriture
fichier
exceptions
normalement
vocation
être
récupérées
permettre
programme
poursuivre
normalement
gestion
d'une
exception
contrôlée
impose
l'utilisation
clause
throws
l'instruction
contrôle
try
..
catch
exceptions
non
contrôlées
classes
RuntimeException
Error
leurs
sous-
classes
toutes
autres
classes
sous-classes
exceptions
contrôlées
10.2
Classes
d'exception
standard
10.2.1
hiérarchie
Error
classe
Error
super-classe
d'une
hiérarchie
d'erreurs
graves
non
contrôlées
hiérarchie
habituellement
réservée
erreurs
d'exécution
système
Exemples
sous-
classes
prédéfinies
NoSuchMethodError
StackOverFlowError
OutOfMemoryError
IllegalAccessError
10.22
hiérarchie
Exception
classe
Exception
super-classe
d'une
hiérarchie
d'exceptions
exclusion
faite
sous-hiérarchie
RuntimeException
contrôlées
Exemples
sous-classes
d'exceptions
contrôlées
prédéfinies
DataFormatException
IOException
EOFException
FileNotFoundException
10.23
hiérarchie
RuntimeException
classe
RuntimeException
super-classe
d'une
hiérarchie
d'exceptions
non
contrôlées
Exemples
sous-classes
prédéfinies
ArithmeticException
IllegalArgumentException
NumberFormatException
IllegalStateException
IndexOutOfBoundsException
NullPointerException
10.3
Lancement
d'une
exception
L'instruction
throw
permet
lancer
exception
recommandé
l'appliquer
'
exceptions
non
contrôlées
Syntaxe
throw
new
ClassOfException
``
diagnostic
message
to
print
Exemple
if
key
==
null
{
throw
new
NullPointerException
``
null
key
found
in
method
x
}
Exemple
if
key
==
0
{
throw
new
IllegalArgumentException
``
empty
key
received
}
Exemple
constructeur
if
this.name.length
==
0
{
throw
new
IllegalStateException
``
name
must
be
provided
-
``
+
``
object
creation
aborted
}
Exemple
L'opération
remove
l'interface
Iterator
spécifiée
optionnelle
c'est-à-dire
implémentation
pourrait
être
cas
public
void
remove
{
throw
new
UnsupportedOperationException
}
10.4
Capture
d'une
exception
capture
d'une
exception
n'est
obligatoire
exceptions
l'on
veut
contrôler
cas
exceptions
contrôlées
compilateur
renforce
contrôles
fois
méthode
lance
telle
exception
l'appelant
méthode
10.41
Clause
throws
clause
throws
déclaration
ajoutée
l'en-tête
d'une
méthode
susceptible
lever
exception
contrôlée
déclare
exceptions
contrôlées
prendre
compte
cadre
méthode
Ceci
nécessaire
compilateur
puisse
savoir
quelles
exceptions
contrôler
convention
exceptions
non
contrôlées
devraient
être
incluses
clause
throws
Syntaxe
throws
ExceptionClass1
ExceptionClass2
Exemple
public
void
saveToFile
String
filename
throws
IOException
{
}
10.42
Instruction
try
..
catch
L'instruction
try
..
catch
permet
capturer
exception
générée
l'appel
d'une
méthode
Quand
exception
générée
contrôle
transféré
code
généré
l'exception
clause
catch
capturé
l'exception
clause
catch
doit
avoir
seul
paramètre
formel
type
paramètre
doit
être
classe
Throwable
sous-classes
instruction
try
peut
contenir
plusieurs
blocs
catch
cas
l'exception
plus
générale
doit
être
traitée
dernier
Syntaxe
try
{
//
protect
one
or
more
statement
here
}
catch
ExceptionClass
e
{
//
report
and
recover
from
the
exception
here
}
finally
{
//
in
fine
in
any
case
always
execute
these
statements
}
bloc
finally
optionnel
permet
souvent
d'éviter
duplication
code
Exemple
partir
plate-forme
5.0
//
Read
double
from
the
standard
input
stream
Scanner
input
=
new
Scanner
System.in
double
x
try
{
x
=
input.nextDouble
}
catch
InputMismatchException
e
{
System.err.println
``
Error
-
Double
waited
-
``
+
e
}
input.close
Exemple
partir
plate-forme
5.0
//
Create
copy
of
text
file
Scanner
in
=
null
PrintWriter
out
=
null
try
{
in
=
new
Scanner
new
File
inputFileName
out
=
new
PrintWriter
outputFileName
while
in.hasNext
{
out.println
in.nextLine
}
}
catch
Exception
e
{
System.err.println
``
Error
in
reading/writing
file
-
``
+
e
}
finally
{
if
in
=
null
in.close
if
out
=
null
out.close
}
Exemple
partir
plate-forme
5.0
//
Read
and
print
text
file
of
doubles
Scanner
in
=
null
try
{
in
=
new
Scanner
new
File
inputFileName
while
in.hasNext
{
System.out.println
Double.parseDouble
in.next
}
}
catch
FileNotFoundException
e
{
System.err.println
``
Unable
to
open
the
input
file
+
e
}
catch
NumberFormatException
e
{
System.err.println
``
token
is
not
double
+
e
}
catch
Exception
e
'
System.err.println
``
Problem
in
reading
the
file
``
+
e
}
finally
{
if
in
=
null
{
try
{
in.close
}
catch
Exception
e
{
System.err.println
``
Error
in
closing
the
file
+
e
}
}
10.5
Définir
nouvelle
classe
d'exception
principales
raisons
conduisant
définition
d'une
nouvelle
classe
d'exception
besoin
d'inclure
informations
complémentaires
l'objet
exception
afin
permettre
diagnostic
récupération
l'erreur
Toute
nouvelle
classe
d'exception
définie
comme
sous-classe
d'une
classe
d'exception
existante
hiérarchie
Exception
Exemple
public
class
WrongValueException
extends
Exception
{
private
String
key
public
WrongValueException
String
key
{
this.key
=
key
}
public
String
getKey
{
return
key
}
public
String
toString
{
return
``
Wrong
value
``
+
key
+
``
found
}
}
11
ANNEXE
1
-
PROGRAMMATION
GRAPHIQUE
Références
Bases
Swing
exemples
programmation
d'interfaces
graphiques
java.sun.com/docs/books/tutorial/uiswing/mini/index.html
Gestion
événements
exemples
programmation
java.sun.com/docs/books/tutorial/uiswing/events/api.html
Swing
Architecture
Overview
java.sun.com/products/jfc/isc/articles/architecture
chapitre
introduit
programmation
graphique
bibliothèque
javax.swing
11.1
Swing
existe
deux
grands
paquetages
d'utilitaires
Java
réaliser
interfaces
graphiques
-
AWT
Abstract
Window
Toolkit
paquetage
primitif
composants
paquetage
s'importent
import
java.awt
*
-
Swing
plus
récent
plus
évolué
construit
AWT
c'est
paquetage
recommandé
composants
paquetage
s'importent
import
javax.swing
*
deux
paquetages
Swing
plus
communément
utilisés
javax.swing
javax.swing.event
classes
javax.swing
plus
courantes
JFrame
JPanel
JLabel
JTextField
JButton
JOPtionPane
Exemple
saisie
/
affichage
boîte
dialogue
//
import
javax.swing.JOptionPane
//
use
method
showInputDialog
to
prompt
for
some
input
String
inputValue
=
JOptionPane.showInputDialog
``
Value
``
//
use
method
showMessageDialog
to
display
message
JOptionPane.showMessageDialog
null
message
11.2
Conteneurs
composants
Tout
objet
graphique
composé
différents
objets
conteneurs
containers
composants
atomiques
différents
constituants
organisés
hiérarchie
d'inclusion
Principales
catégories
conteneurs
composants
+
conteneurs
plus
haut
niveau
qu'un
objet
graphique
puisse
être
affiché
l'écran
hiérarchie
constituants
doit
nécessairement
avoir
racine
l'un
trois
conteneurs
suivants
Frame
classe
JFrame
conteneur
plus
général
fournit
fenêtre
principale
laquelle
autres
composants
Swing
pourront
dessiner
Dialog
classe
JDialog
plus
limité
qu'un
Frame
fournit
fenêtre
dialogue
classe
J0ptionPane
permet
créer
fenêtres
dialogue
simples
standard
classe
JDialog
permet
créer
fenêtres
dialogue
personnalisées
Applet
classe
JApplet
spécialisé
interfaces
web
fournit
fenêtre
affichée
navigateur
web
+
conteneurs
intermédiaires
notamment
Panel
classe
JPanel
simplifie
positionnement
objets
graphiques
atomiques
Tout
conteneur
haut
niveau
contient
conteneur
intermédiaire
spécial
appelé
ContentPane
C'est
conteneur
intermédiaire
principal
contient
typiquement
plusieurs
panels
+
composants
atomiques
exemple
Button
classe
JButton
Label
classe
JLabel
Text
field
classe
JTextField
Sauf
conteneurs
plus
haut
niveau
tous
composants
conteneur
intermédiaire
composant
atomique
commencent
héritent
classe
JComponent
ajouter
objet
conteneur
utilise
méthode
add
méthode
prend
général
deuxième
argument
spécifie
mise
page
Exemple
//
import
javax.swing
*
frame
=
new
JFrame
pane
=
new
JPanel
button
=
new
JButton
label
=
new
JLabel
pane.add
button
pane.add
1abel
frame.getContentPane
.add
pane
BorderLayout.CENTER
frame.pack
//
sizes
at
or
above
preferred
sizes
frame.setVisible
true
//
l'objet
frame
ainsi
créé
hiérarchie
JFrame
ContentPane
JPanel
JButton
JLabel
Exemple
import
javax.swing.JApplet
public
class
AppletExample
extends
JApplet
{
public
void
init
{
JPanel
pane
=
new
JPanel
pane.add
new
JLabel
``
Hello
World
this.setContentPane
pane
11.3
Gestion
mise
page
mise
page
layout
consiste
fixer
taille
position
composants
Tout
conteneur
possède
gestionnaire
mise
page
défaut
S'il
convient
peut
remplacer
composants
peuvent
solliciter
taille
alignement
donnés
in
fine
c'est
gestionnaires
mise
page
conteneur
conserve
décision
finale
existe
6
gestionnaires
mise
page
+
BorderLayout
gestionnaire
mise
page
défaut
tout
ContentPane
définit
5
zones
placement
NORTH
SOUTH
EAST
WEST
CENTER
+
FlowLayout
gestionnaire
mise
page
défaut
tout
JPanel
positionne
simplement
composants
gauche
droite
passant
nouvelle
ligne
nécessaire
+
BoxLayout
gestionnaire
mise
page
très
flexible
positionne
composants
seule
ligne
colonne
respectant
attentes
composants
matière
taille
maximale
d'alignement
+
GridLayout
gestionnaire
mise
page
très
simple
crée
ensemble
composants
taille
affiche
nombre
lignes
colonnes
spécifié
+
GridBagLayout
gestionnaire
mise
page
plus
sophistiqué
plus
flexible
aligne
composants
plaçant
grille
cellules
permettant
certains
s'étendre
plusieurs
cellules
largeurs
rangées
hauteurs
colonnes
respectivement
peuvent
être
différentes
+
CardLayout
gestionnaire
mise
page
usage
spécial
permet
d'implémenter
zone
contient
différents
composants
différents
moments
utilisé
combinaison
d'autres
gestionnaires
mise
page
Exemple
changement
gestionnaire
mise
page
défaut
JPanel
pane
=
new
JPanel
pane.setLayout
new
BorderLayout
taille
l'alignement
d'un
composant
peut
être
spécifié
méthodes
suivantes
setMinimumSize
setPreferredSize
setMaximumSize
setAlignmentX
setAlignmentY
11.4
Gestion
événements
11.4.1
Notion
d'événement
chaque
fois
l'utilisateur
agit
clavier
souris
événement
survient
objet
événement
généré
objet
événement
objet
contenant
informations
source
nature
l'événement
survenu
Swing
offre
interfaces
sens
Java
appelées
``
écouteurs
d'événements
``
event
listeners
permettent
capter
événements
façon
sélective
afin
pouvoir
traiter
Event
Source
Event
object
Event
listener
Event
listener
Event
listener
Exemple
d'événement
Type
Listener
Clic
d'un
bouton
graphique
enfoncement
touche
return
ActionListener
lors
d'une
saisie
champ
texte
Fermeture
d'une
fenêtre
WindowListener
graphique
frame
Clic
souris
lors
passage
curseur
composant
MouseListener
graphique
Afin
faciliter
travail
programmeur
Swing
associe
généralement
chaque
interface
Listener
classe
adaptateur
Adapter
adaptateur
existe
c'est
l'on
travaille
Exemple
d'interface
Listener
Classe
Adapter
associée
ActionListener
None
WindowListener
WindowAdapter
MouseListener
MouseAdapter
KeyListener
KeyAdapter
11.4.2
Réaliser
gestionnaire
d'événement
Réaliser
gestionnaire
d'événement
event
handler
requiert
trois
éléments
code
+
déclarer
classe
gestionnaire
d'événement
classe
doit
implémenter
interface
Listener
étendre
classe
Adapter
Exemple
import
java.awt.event
*
public
class
MyClass
implements
ActionListener
{
}
+
définir
classe
gestionnaire
d'événement
méthodes
l'interface
Listener
Exemple
public
void
actionPerformed
ActionEvent
e
{
..
}
+
définir
instance
classe
gestionnaire
d'événement
l'enregistrer
composant
concerné
Exemple
someComponent.addActionListener
instanceOfMyClass
type
ActionListener
permet
définir
gestionnaires
d'événement
plus
simples
plus
communs
Lorsqu'un
événement
type
généré
clic
d'un
bouton
graphique
enfoncement
touche
return
lors
d'une
saisie
champ
texte
message
actionPerformed
envoyé
tous
écouteurs
d'événements
enregistrés
composant
concerné
classe
gestionnaire
d'événement
généralement
implantée
sous
forme
d'une
classe
interne
inner
class
sein
d'une
classe
graphique
Exemple
//
Ecriture
d'un
MouseListener
public
class
myClass
extends
JPanel
{
someObject.addMouseListener
new
MyAdapter
class
MyAdapter
extends
MouseAdapter
{
public
void
mouseClicked
MouseEvent
e
{
}
}
}
Typiquement
classe
gestionnaire
d'événement
implantée
sous
forme
d'une
classe
interne
anonyme
Exemple
solution
équivalente
celle
l'exemple
précédent
//
Ecriture
d'un
MouseListener
public
class
myClass
extends
JPanel
{
someObject.addMouseListener
new
MouseAdapter
{
public
void
mouseClicked
MouseEvent
e
{
}
}
}
11.5
Affichage
/
fermeture
d'une
fenêtre
graphique
L'affichage
/
masquage
d'une
fenêtre
graphique
type
JFrame
commande
méthode
setVisible
Quand
l'utilisateur
ferme
fenêtre
graphique
type
JFrame
fenêtre
n'est
fait
défaut
masquée
Quoiqu'invisible
l'objet
graphique
existe
toujours
programme
peut
nouveau
rendre
visible
l'on
désire
comportement
différent
nécessaire
-
d'enregistrer
objet
graphique
gestionnaire
d'événement
type
WindowListener
capter
message
windowClosing
-
spécifier
comportement
défaut
utilisant
méthode
setDefaultCloseOperation
comportement
indiqué
argument
constante
définie
l'interface
WindowConstants
Exemple
d'argument
DISPOSE_ON_CLOSE
11.6
Architecture
composants
Swing
Objectif
applications
facilement
adaptables
L'architecture
composants
Swing
basée
adaptation
très
renommée
architecture
MVC
``
Modèle-Vue-Contrôleur
``
voir
section
13.2
communauté
Swing
appelée
``
Architecture
modèle
séparable
``
partie
Modèle
d'un
composant
Swing
partie
représente
données
l'application
traitée
comme
élément
séparé
tout
comme
préconise
conception
MVC
Swing
fusionne
parties
Vue
prend
charge
représentation
visuelle
données
Contrôleur
traite
entrées
utilisateur
chaque
composant
seul
objet
interface
utilisateur
User
Interface
Object
général
considéré
comme
bonne
pratique
centrer
l'architecture
d'une
application
autour
données
plutôt
qu'autour
interface
utilisateur
supporter
paradigme
1
Swing
définit
interface
Modèle
séparée
chaque
composant
séparation
fournit
programme
d'application
possibilité
connecter
facilement
composants
Swing
implémentation
modèle
propre
table
suivante
montre
interfaces
Modèles
offertes
composants
Swing
Component
Model
Interface
Model
Type
JButton
ButtonModel
GUI
JToggleButton
ButtonModel
GUI/data
JCheckBox
ButtonModel
GUI/data
JRadioButton
ButtonModel
GUI/data
JMenu
ButtonModel
GUI
JMenuItem
ButtonModel
GUI
JCheckBoxMenuItem
ButtonModel
GUI/data
JRadioButtonMenuItem
ButtonModel
GUI/data
JComboBox
ComboBoxModel
Data
JProgressBar
BoundedRangeModel
GUI/data
JScrollBar
BoundedRangeModel
GUI/data
Slider
BoundedRangeModel
GUI/data
Component
Model
Interface
Model
Type
JTabbedPane
SingleSelectionModel
GUI
JList
ListModel
Data
JList
ListSelectionModel
GUI
JTable
TableModel
Data
JTable
TableColumnModel
GUI
JTree
TreeModel
Data
JTree
TreeSelectionModel
GUI
JEditorPane
Document
Data
JTextPane
Document
Data
JTextArea
Document
Data
JTextField
Document
Data
JPasswordField
Document
Data
interfaces
Modèles
fournies
Swing
relèvent
deux
grandes
catégories
types
Etat
l'interface
graphique
``
GUI
définissent
statut
visuel
commandes
l'interface
graphique
types
``
Données
d'application
``
Data
représentent
données
quantifiables
sens
l'application
Certains
modèles
relèvent
types
partagés
GUI/data
recommandé
d'utiliser
catégorie
``
Données
d'application
``
Data
modèles
Swing
car
renforcent
grandement
l'adaptabilité
modularité
applications
long
terme
1
paradigme
vision
monde
repose
modèle
11.7
Applets
Java
permet
créer
deux
types
programmes
-
applications
s'exécutent
directement
sous
contrôle
machine
virtuelle
Java
-
appliquettes
applettes
anglais
applets
destinées
être
exécutées
navigateur
Web
réaliser
applette
minimum
consiste
-
créer
sous-classe
classe
JApplet
voir
section
11.2
-
créer
méthode
init
lancée
navigateur
-
référencer
classe
balise
APPLET
CODE=
d'un
fichier
HTML
Syntaxe
import
javax.swing.JApplet
public
class
AppletClassName
extends
JApplet
{
//
Fields
public
void
init
{
}
}
Syntaxe
APPLET
CODE=
AppletClassName.class
WIDTH=anint
HEIGHT=anint
/APPLET
12
ANNEXE
2
-
THREADS
Références
Programmation
concurrente
processus
threads
java.sun.com/docs/books/tutorial/essential/concurrency/procthread.html
threads
permettent
programmer
tâches
l'intérieur
d'un
programme
s'exécuteront
concurremment
processus
légers
tâche
exécuter
thread
doit
être
implémentée
méthode
run
existe
deux
façons
fournir
méthode
run
-
définir
sous-classe
classe
Thread
redéfinir
méthode
run
-
définir
classe
implémente
l'interface
Runnable
définir
méthode
run
12.1
Créer
thread
extension
classe
Thread
Exemple
//
Example
of
defining
thread
extending
Thread
public
class
SimpleThread
extends
Thread
{
public
SimpleThread
String
threadName
{
super
threadName
}
//
The
task
of
this
thread
is
to
print
10
times
its
name
//
at
random
rate
public
void
run
{
for
int
i
=
0
i
10
i++
{
System.out.println
i
+
``
``
+
getName
try
{
sleep
long
Math.random
*
1000
}
catch
InterruptedException
e
{
}
}
System.out.println
``
DONE
``
+
getName
}
}
//
end
class
SimpleThread
//
Example
of
running
two
threads
concurrently
//
``
Jamaica
and
``
Fiji
Will
be
printed
randomly
10
times
public
static
void
main
String
args
{
new
SimpleThread
``
Jamaica
.start
new
SimpleThread
``
Fiji
.start
}
12.2
Créer
thread
implémentation
l'interface
Runnable
façon
faire
s'impose
lorsque
classe
créer
doit
sous-classer
classe
quelconque
cas
typique
Applet
parce
Java
supporte
l'héritage
multiple
Exemple
//
Example
of
defining
thread
implementing
Runnable
public
class
SimpleThread
implements
Runnable
{
String
threadName
public
SimpleThread
String
threadName
{
this.threadName
=
threadName
}
//
The
task
of
this
thread
is
to
print
10
times
its
name
//
at
random
rate
public
void
run
{
for
int
i
=
0
i
10
i++
{
System.out.println
i
+
``
``
+
threadName
try
{
Thread.sleep
long
Math.random
*
1000
}
catch
InterruptedException
e
{
}
}
System.out.println
``
DONE
+
threadName
}
}
//
end
class
SimpleThread
//
Example
of
running
two
threads
concurrently
//
``
Jamaica
and
``
Fiji
Will
be
printed
randomly
10
times
public
static
void
main
String
args
{
new
Thread
new
SimpleThread
``
Jamaica
.start
new
Thread
new
SimpleThread
``
Fiji
.start
}
12.3
Synchronisation
communication
entre
threads
12.3.1
Sections
critiques
synchronisation
programme
segments
code
accèdent
donnée
depuis
threads
concurrents
appelés
sections
critiques
Lorsque
deux
threads
concurrents
invoquent
méthodes
opèrent
donnée
partagée
méthodes
critiques
nécessaire
Java
puisse
synchroniser
méthodes
afin
garantir
accès
sûr
l'information
fin
chacune
méthodes
doit
être
déclarée
modificateur
synchronized
l'exécution
l'accès
donnée
partagée
ainsi
automatiquement
verrouillé
tant
qu'elle
utilisée
méthode
critique
Exemple
get
put
supposées
deux
méthodes
critiques
l'objet
partagé
public
synchronized
int
get
{
}
public
synchronized
void
put
int
value
{
}
12.3.2
Communication
entre
threads
deux
threads
processus
indépendants
déroulent
façon
asynchrone
puissent
communiquer
données
nécessaire
qu'ils
sachent
synchroniser
autour
d'un
sas
communication
thread
émetteur
donnée
appelé
producteur
thread
destinataire
donnée
appelé
consommateur
thread
producteur
donnée
doit
être
capable
-
attendre
l'espace
stockage
sas
communication
libre
-
puis
déposer
nouvelle
donnée
-
puis
informer
threads
consommateurs
mise
disposition
donnée
façon
symétrique
thread
consommateur
donnée
doit
être
capable
-
attendre
donnée
mise
disposition
l'espace
stockage
sas
communication
-
puis
lire
donnée
-
puis
informer
threads
producteurs
disponibilité
sas
communication
accuser
réception
C'est
sas
communication
qu'on
confie
charge
synchronisations
mise
attente
réalise
méthode
wait
notification
autres
threads
méthodes
notify
notifyAll
méthodes
toutes
deux
définies
classe
Object
Exemple
classe
définissant
sas
communication
d'un
seul
élément
type
entier
attribut
contents
noter
particulier
sécurisation
apportée
l'usage
d'un
while
non
d'un
if
afin
prévenir
faux
réveils
éventuels
public
class
CubbyHole
{
private
int
contents
private
boolean
available
=
false
public
synchronized
int
get
{
//
called
by
Consumer
while
available
==
false
{
try
{
wait
//
wait
for
Producer
to
put
value
}
catch
InterruptedException
e
{
}
}
available
=
false
notifyAll
return
contents
}
public
synchronized
void
put
int
x
{
//
called
by
Producer
while
available
==
true
{
try
{
wait
//
wait
for
Consumer
to
get
value
}
catch
InterruptedException
e
{
}
}
contents
=
x
available
=
true
notifyAll
}
13
ANNEXE
3
-
CONCEPTION
DEVELOPPEMENT
JAVA
Références
Architecture
Modèle-Vue-Contrôleur
java.sun.com/blueprints/guidelines/designing_enterprise_applications_2e/app-arch/app-arch2.html
Développement
tests
unitaires
cadre
d'applications
JUnit
junit.sourceforge.net/doc/cookbook/cookbook.htm
JavaBeans
java.sun.com/products/javabeans/
java.sun.com/docs/books/tutorial/javabeans/index.html
Design
patterns
section
va
au-delà
langage
Java
aborder
quelques
aspects
conception
développement
programmes
Java
13.1
Conseils
généraux
bonne
conception
classes
RECHERCHER
COUPLAGE
FAIBLE
couplage
décrit
l'interconnectivité
entre
classes
couplage
faible
quand
chaque
classe
largement
indépendante
autres
communique
elles
via
interface
petite
bien
définie
l'interface
d'une
classe
partie
visible
publique
classe
définit
typiquement
liste
membres
attributs
constructeurs
méthodes
non
privés
associés
leurs
commentaires
documentation
RECHERCHER
COHESION
FORTE
cohésion
décrit
l'adéquation
entre
unité
code
entité
tâche
logique
cohésion
forte
quand
chaque
unité
code
méthode
classe
module
.....
responsable
d'une
entité
tâche
très
bien
définie
UTILISER
MAXIMUM
L'ENCAPSULATION
L'encapsulation
technique
base
réduire
couplage
contribue
séparer
quoi
comment
vue
l'implémentation
définition
l'utilisation
Principe
base
rendre
attributs
privés
utiliser
méthodes
d'accès
DECOUPLER
ENTREES
TRAITEMENTS
SORTIES
Voir
particulier
section
13.2
ADOPTER
CONCEPTION
DIRIGEE
RESPONSABILITÉS
L'attribution
bonnes
responsabilités
bonnes
classes
l'un
problèmes
plus
délicats
conception
orientée
objet
programmation
dirigée
responsabilités
processus
conception
classes
attribution
responsabilités
bien
définies
chaque
classe
approche
peut
être
utilisée
déterminer
quelle
classe
devrait
implémenter
telle
fonctionnalité
conception
dirigée
responsabilités
contribue
réduire
couplage
EVITER
DUPLICATION
CODE
Eviter
qu'un
segment
code
retrouve
plus
d'une
fois
application
UTILISER
L'HERITAGE
BON
ESCIENT
L'héritage
relation
``
est_un
``
relation
a_un
``
hiérarchie
d'héritage
objets
doivent
avoir
relation
``
est_un
``
classe
base
afin
l'héritage
tous
attributs
propriétés
méthodes
classe
base
garde
sens
sous-classe
spécialise
complète
objets
relevant
strictement
d'une
relation
``
est_un
``
doivent
traduire
classes
interfaces
sans
relation
d'héritage
entre
elles
LIMITER
TAILLE
COMPLEXITE
mettre
trop
choses
méthode
méthode
trop
longue
fait
plus
d'une
tâche
logique
tout
mettre
seule
classe
classe
trop
complexe
représente
plus
d'une
entité
logique
CHERCHER
FACILITER
CHANGEMENTS
LOCALISES
Réaliser
changements
classe
devrait
avoir
qu'un
minimum
d'impact
autres
classes
localisation
changements
l'un
buts
recherchés
d'une
bonne
conception
classe
produit
d'un
couplage
faible
d'une
cohésion
forte
13.2
Architecture
d'une
application
interactive
modèle
MVC
L'architecture
Modèle-Vue-Contrôleur
Model-View-Controller
MVC
modèle
d'architecture
logicielle
recommandé
-
largement
utilisé
-
conception
d'applications
interactives
modèle
vise
minimiser
degré
couplage
entre
objets
l'application
découplant
structurellement
entrées
traitements
sorties
point
essentiel
consiste
séparer
objets
relevant
l'interface
utilisateur
objets
métier
afin
pouvoir
faire
évoluer
indépendamment
réutiliser
MVC
organise
application
interactive
trois
grandes
composantes
Modèle
Vue
Contrôleur
découple
leurs
responsabilités
respectives
+
MODELE
encapsule
fonctionnalité
données
coeur
l'application
indépendant
représentations
sortie
spécifiques
d'un
comportement
d'entrée
charge
représentation
interne
données
l'application
logique
gestion
données
notifie
composante
Vue
changements
données
permet
l'interroger
état
fournit
contrôleur
possibilité
d'accéder
certaines
fonctionnalités
applicatives
encapsulées
Modèle
+
VUE
affiche
informations
l'utilisateur
récupère
Modèle
données
présenter
l'utilisateur
spécifie
présentation
externe
met
jour
l'information
affichée
relaie
aussi
contrôleur
entrées
utilisateur
l'autorise
sélectionner
vues
séparation
modèle
d'une
part
vue
contrôleur
d'autre
part
permet
vues
multiples
d'un
modèle
Quand
plusieurs
vues
modèle
chaque
vue
alors
contrôleur
associé
+
CONTROLEUR
gère
entrées
utilisateur
reçoit
entrées
généralement
sous
forme
d'événements
encodant
mouvement
souris
l'activation
d'un
bouton
entrée
clavier
bien
s'il
s'agit
d'une
application
web
requêtes
HTTP
GET
POST
événements
traduits
requêtes
service
Modèle
Vue
application
typiquement
contrôleur
chaque
ensemble
fonctionnalités
apparentées
application
peut
avoir
contrôleur
séparé
type
client
interactions
utilisateurs
varient
selon
types
client
L'utilisateur
interagit
système
uniquement
travers
contrôleurs
L'ensemble
Vue
+
Contrôleur
compose
l'interface
utilisateur
Modèle
Interrogation
d'état
Notification
changement
Changement
d'état
Vue
Requête
utilisateur
Sélection
vue
Contrôleur
invocation
méthodes
Evènements
pratique
schéma
principe
laisse
place
grande
variété
d'implémentations
possibles
difficultés
implémentation
idéale
Java
réside
notamment
fait
composants
graphiques
Swing
fusionnent
parties
Vues
Contrôleur
cf
section
11.6
petits
programmes
tout
particulièrement
Vue
Contrôleur
souvent
combinés
tous
cas
Modèle
doit
être
séparé
Exemple
d'implémentation
d'une
architecture
MVC
import
java.util.Observable
import
java.util.Observer
import
javax.swing.JApplet
import
javax.swing.JPanel
import
java.awt.event.ActionListener
import
java.awt.event.ActionEvent
public
class
Controller
extends
JApplet
implements
ActionListener
{
private
View
view
private
Model
model
public
void
init
{
model
=
new
Mode1
view
=
new
View
model
this
model.addObserver
view
this.setContentPane
view
}
public
void
actionPerformed
ActionEvent
e
{
//
Process
the
events
}
}
public
class
View
extends
JPanel
implements
Observer
{
private
Model
model
//
Declare
here
the
JPanel
components
public
View
Model
ActionListener
listener
{
model
=
makeContentPane
listener
}
public
void
update
Observable
o
Object
arg
{
//
Automatically
called
when
observer
is
notified
//
Update
the
view.
}
public
void
makeContentPane
ActionListener
listener
{
//
Create
and
initialize
the
JPanel
components
and
//
when
need
be
attach
them
the
event
listener
//
Define
the
layout.
}
}
public
class
Model
extends
Observable
{
//
Wherever
the
value
of
an
attribute
interesting
the
//
View
is
changed
insert
these
two
statements
//
setChanged
//
notifyObservers
or
notifyObservers
arg
}
Chercher
découpler
traitements
entrées-sorties
classique
programmation
esprit
peut
noter
particulier
modèle
MVC
certaine
similitude
classique
architecture
trois-tiers
three-tiers
systèmes
distribués
architecture
trois-
tiers
architecture
logicielle
client-serveur
laquelle
l'interface
utilisateur
logique
traitement
données
trois
modules
indépendants
l'interface
utilisateur
stockée
client
gros
logique
l'application
stocké
serveurs
d'application
données
stockées
serveur
base
données
Exemple
applications
web
professionnelles
reposant
solution
Java
EE
voir
chapitre
16
Modèle
assuré
EJB
et/ou
JavaBeans
Contrôleur
assuré
servlets
Vue
JSP
glossaire
chapitre
17
13.3
Tests
unitaires
13.3.1
Définitions
test
activité
consiste
déterminer
segment
code
méthode
classe
programme
produit
bien
résultat
attendu
définit
classiquement
trois
niveaux
tests
mis
oeuvre
successivement
+
test
unitaire
unit
testing
s'agit
tester
chaque
composante
individuelle
méthode
classe
l'application
+
test
d'intégration
integration
testing
s'agit
tester
groupes
classes
interrelations
puis
toute
l'application
ensemble
tests
appliqués
suivent
généralement
plan
test
i.e
approche
systématique
méthodique
+
test
système
system
testing
s'agit
tester
l'application
intégrée
environnement
d'utilisation
complet
tests
entrent
catégorie
tests
boîtes
noires
tant
tels
devraient
nécessiter
connaissance
conception
interne
code
logique
considérations
suivantes
limiteront
essentiellement
tests
unitaires
cas
test
ensemble
conditions
variables
partir
desquelles
testeur
déterminera
exigence
requise
complètement
partiellement
satisfaite
cas
test
caractérisé
entrée
connue
pré-condition
sortie
attendue
post-
condition
nombreux
cas
tests
peuvent
être
nécessaires
vérifier
exigence
donnée
distingue
généralement
deux
types
cas
test
-
cas
test
positifs
consistent
tester
cas
censés
faire
réussir
fonctionnalité
tests
doivent
convaincre
l'élément
code
testé
fonctionne
bien
comme
espéré
-
cas
test
négatifs
consistent
tester
cas
censés
mettre
échec
fonctionnalité
toutes
situations
valeurs
hors
limites
d'erreurs
....
Exemples
entrer
valeur
hors
plage
lire
ensemble
vide
tels
cas
devons
attendre
programme
traite
l'erreur
d'une
façon
contrôlée
appropriée
simple
correction
erreurs
détectées
test
devrait
systématiquement
améliorer
qualité
programme
Malheureusement
l'expérience
montre
tout
changement
programme
peut
introduire
façon
inattendue
d'autres
erreurs
particulier
erreurs
régression
regression
bugs
erreur
régression
survient
quand
fonctionnalité
fonctionnait
précédemment
fonctionne
plus
suite
modification
programme
méthode
courante
test
non-régression
non-regression
testing
consiste
réexécuter
tests
réalisés
antérieurement
voir
défauts
apparaissent
voire
réapparaissent
tests
devant
être
appliqués
non
seule
fois
chaque
modification
logiciel
souhaitable
disposer
d'une
batterie
tests
programmés
afin
permettre
automatisation
test
s'agit
programmer
cas
test
chaque
méthode
non
triviale
veillant
chaque
cas
test
bien
séparé
autres
13.3.2
JUnit
JUnit
développé
communauté
open
source
offre
cadre
d'applications
framework
programmation
tests
régression
utilisé
implémenter
tests
unitaires
Java
classe
TestCase
permet
définir
cas
test
classe
Assert
fournit
ensemble
méthodes
facilitant
gestion
erreurs
détectées
classe
TestSuite
permet
d'exécuter
suite
tests
classe
TestRunner
outil
d'exploitation
permettant
définir
suite
tests
exécuter
d'afficher
résultats
Exemple
cas
test
/
*
*
*
test
case
for
the
class
MyClass
*
/
import
junit.framework
*
public
class
TestMyClass
extends
TestCase
{
/
*
The
tests
need
to
run
against
the
background
of
known
*
set
of
objects
This
set
of
objects
is
called
test
*
fixture
*
Define
here
an
instance
variable
for
each
part
of
the
*
fixture
*
/
private
MyClass
myObject
public
TestMyClass
String
name
{
super
name
}
/
*
*
*
Sets
up
the
test
fixture
*
setUp
is
called
before
every
test
case
method
*
Initializes
the
instance
variables
*
/
protected
void
setUp
{
myObject
=
new
MyClass
}
/
*
*
*
Tears
down
the
test
fixture
*
tearDown
is
called
after
every
test
case
method
*
Releases
any
permanent
resources
allocated
in
setUp
*
example
closes
files
*
/
protected
void
tearDown
{
//
}
//
Once
the
fixture
is
in
place
many
Test
Cases
//
necessary
can
be
written
/
*
*
*
Tests
the
method
methodX
*
/
public
void
testMethodX
{
ArgumentType
argument
=
ResponseType
expectedResponse
=
String
errorMessage
=
``
``
assertTrue
errorMessage
expectedResponse.equals
MethodX
argument
}
}
//
end
class
TestMyClass
JUnit
détermine
succès
l'échec
d'un
test
via
instructions
d'assertion
assertion
simplement
procédure
comparaison
entre
valeur
espérée
valeur
effective
génère
échec
cas
différence
procédures
d'assertion
disponibles
définies
classe
junit.framework.Assert
Exemples
d'instructions
d'assertion
assertTrue
errorMessage
booleanCondition
assertFalse
errorMessage
booleanCondition
assertEquals
errorMessage
expectedValue
actualValue
assertEquals
errorMessage
doubleExpected
doubleActual
doubleDelta
exécuter
test
créer
instance
classe
paramètre
nom
méthode
test
Exemple
new
TestMyClass
``
testMethodX
JUnit
intégré
certains
outils
développement
tels
outils
offrent
alors
fonctionnalités
permettent
créer
facilement
tests
13.4
Java
Beans
Java
Bean
``
grain
java
``
défini
Sun
comme
``
composant
réutilisable
Java
destiné
être
manipulé
outil
développement
graphique
visuel
``
Java
Beans
composants
Java
i.e
classes
respectant
certains
critères
afin
pouvoir
être
facilement
développés
assemblés
réutilisés
créer
applications
sophistiquées
exemple
technologie
Java
Beans
l'architecture
composants
plate-forme
Java
obligations
doit
respecter
Java
Bean
nombreuses
l'enjeu
d'importance
disposer
composants
``
Write
One
Run
Anywhere
``
WORA
réutilisables
Java
Beans
classes
publiques
concrètes
caractéristiques
communes
+
supporter
``
propriétés
``
propriétés
attributs
discrets
nommés
d'un
Java
Bean
peuvent
affecter
apparence
comportement
propriétés
Java
Beans
l'équivalent
champs
objets
exemple
bouton
graphique
pourrait
avoir
propriété
nommée
``
label
``
représenterait
texte
affiché
bouton
méthodes
d'accès
propriétés
doivent
respecter
conventions
nommage
particulières
exemple
-
propriétés
simples
existe
d'autres
liées
contraintes
indexées
PropertyType
getPropertyName
//
simple
getter
void
setPropertyName
PropertyType
//
simple
setter
-
propriétés
booléennes
utilise
typiquement
is
lieu
get
+
communiquer
entre
événements
pratique
utilise
technique
Swing
``
listeners
``
voir
section
11.4
+
supporter
l'introspection
l'exécution
l'environnement
développement
doit
être
capable
déterminer
d'analyser
propriétés
événements
méthodes
supporte
Java
Bean
noter
propriété
d'introspection
déjà
présente
objets
Java
puisqu'un
objet
peut
être
analysé
grâce
classes
Class
Method
Field
+
supporter
personnalisation
``
customization
``
outils
développement
doivent
permettre
modifier
l'apparence
comportement
d'un
Java
Bean
phase
conception
+
supporter
persistance
persistance
d'un
objet
capacité
sauvegarder
support
stockage
restaurer
l'identique
afin
programme
puisse
terminer
sans
objet
perdu
Exemple
persistance
qu'un
objet
puisse
prétendre
être
document
Excel
l'intérieur
d'un
document
Word
mécanisme
rend
possible
persistance
appelé
``
sérialisation
``
serialization
fin
Java
Bean
doit
implémenter
l'interface
Serializable
Externalizable
Exemple
Java
Bean
package
sunw.demo.simple
import
java.awt
*
import
java.io.Serializable
/
*
*
*
SimpleBean
wi11
be
displayed
with
green
*
centered
rectangle
but
its
color
may
be
changed
1ater
*
/
public
class
SimpleBean
extends
Canvas
implements
Serializable
{
private
Color
color
=
Color.green
//
Property
getter
method
public
Color
getColor
{
return
color
}
//
Property
setter
method
//
Sets
new
SimpleBean
color
and
repaints
public
void
setColor
Color
newColor
{
color
=
newColor
repaint
}
public
void
paint
Graphics
g
{
g.setColor
color
g.fillRect
20
5
20
30
}
//
Constructor
sets
inherited
properties
public
SimpleBean
{
setSize
60,40
setBackground
Color.red
}
}
//
end
class
SimpleBean
être
reconnu
outil
développement
Java
Bean
doit
être
conditionnné
fichier
d'archive
format
jar
Bien
obligatoire
souhaitable
Java
Beans
paquetages
évite
notamment
conflits
cas
d'homonymie
beans
13.5
Design
patterns
section
n'est
qu'une
toute
première
introduction
modèles
conception
design
patterns
1
développement
orienté
objet
d'applications
professionnelles
conduit
généralement
rencontrer
problèmes
conception
types
familiers
communauté
développeurs
confirmés
lesquels
solutions
éprouvées
existent
s'agit
ici
solutions
théoriques
algorithmes
solutions
orientées
objet
empiriques
solidité
l'efficacité
fait
preuve
pratique
solutions
appelées
modèles
conception
design
patterns
développeur
expérimenté
doit
connaître
disposer
d'un
``
panier
``
modèles
conception
qu'il
appliquera
aussi
systématiquement
possible
modèles
conception
stratégies
résolution
grands
types
problèmes
conception
orientée
objet
décrivent
formes
génériques
d'organisation
classes
indépendants
langage
programmation
objet
mis
oeuvre
titre
illustratif
l'architecture
MVC
décrite
section
13.2
exemple
modèle
conception
d'architecture
logicielle
architectural
design
pattern
plus
connus
modèles
conception
base
23
modèles
fondamentaux
décrits
quatre
auteurs
appelés
collectivement
``
The
Gang
of
Four
``
``
bande
quatre
``
tout
simplement
GoF
2
distingue
habituellement
3
grandes
familles
modèles
conception
1
L'expression
design
pattern
souvent
traduite
aussi
patron
conception
2
-
modèles
construction
but
d'organiser
création
d'objets
façon
gagner
abstraction
Exemple
présenté
ci-après
modèle
Singleton
-
modèles
structuration
facilitent
l'organisation
hiérarchie
classes
leurs
relations
Exemple
présenté
ci-après
modèle
Decorator
-
modèles
comportement
proposent
solutions
organiser
interactions
répartir
traitements
entre
objets
tentent
répartir
responsabilités
entre
chaque
classe
Exemple
modèle
Chain
of
Responsibility
permet
créer
chaîne
d'objets
tels
l'un
d'eux
peut
répondre
requête
puisse
transmettre
successeur
jusqu
'
l'un
d'entre
réponde
13.5.1
Exemple
modèle
Singleton
modèle
conception
Singleton
permet
d'assurer
qu'une
classe
possédera
qu'une
instance
plus
d'offrir
méthode
unique
retournant
instance
Exemple
d'implémentation
cas
toutes
informations
nécessaires
création
singleton
disponibles
moment
chargement
classe
mémoire
public
final
class
MySingleton
{
//
Creating
at
the
class
loading
private
static
MySingleton
singleInstance
=
new
MySingleton
//
Private
constructor
Ca
n't
be
used
outside
this
class
private
MySingleton
{
}
/
*
*
Get
singleton
of
this
class
*
/
public
static
MySingleton
getInstance
{
return
singleInstance
}
}
//
Creation
of
singleton
MySingleton
singleton
=
MySingleton.getInstance
13.5.2
Exemple
modèle
Decorator
modèle
conception
Decorator
permet
d'ajouter
dynamiquement
fonctionnalités
objet
Ceci
réalise
créant
nouvelle
classe
Decorator
enveloppant
classe
originale
modèle
conception
Decorator
alternative
l'approche
création
d'une
sous-
classe
classe
originale
s'impose
notamment
approche
extension
classe
originale
cas
suivants
classe
originale
peut
être
étendue
héritage
nombre
sous-classes
permettant
définir
toutes
combinaisons
possibles
fonctionnalités
trop
important
l'ajout
fonctionnalités
peut
être
statique
i.e
réalisé
compilation
doit
être
dynamique
.e
réalisé
l'exécution
Exemple
Wikipedia
Considérons
fenêtres
d'affichage
instances
d'une
classe
Window
supposons
classe
n'offre
possibilité
d'ajouter
barres
défilement
Créons
décorateur
puisse
ajouter
dynamiquement
fonctionnalité
objets
Window
existants
//
An
interface
common
to
the
decorator
and
the
decorated
public
interface
Window
{
public
void
draw
}
//
The
original
class
the
instance
of
which
can
be
decorated
public
class
SimpleWindow
implements
Window
public
void
draw
{
}
}
//
The
abstract
decorator
public
abstract
class
WindowDecorator
implements
Window
{
protected
Window
decoratedWindow
public
WindowDecorator
Window
decoratedWindow
{
this.decoratedWindow
=
decoratedWindow
}
}
//
first
concrete
decorator
public
class
VerticalScrollBarDecorator
extends
WindowDecorator
{
public
VerticalScrollBarDecorator
Window
decoratedWindow
{
super
decoratedWindow
}
public
void
draw
{
drawVerticalScrollBar
decoratedWindow.draw
}
public
void
drawVerticalScrollBar
{
}
}
//
second
concrete
decorator
public
class
HorizontalScrollBarDecorator
extends
WindowDecorator
{
public
HorizontalScrollBarDecorator
Window
decoratedWindow
{
super
decoratedWindow
}
public
void
draw
{
drawHorizontalScrollBar
decoratedWindow.draw
}
public
void
drawHorizontalScrollBar
{
}
}
//
Example
creation
of
fully
decorated
Window
instance
Window
decoratedWindow
=
new
HorizontalScrollBarDecorator
new
VerticalScrollBarDecorator
new
SimpleWindow
14
ANNEXE
4
MACHINE
VIRTUELLE
JAVA
JVM
objectifs
premiers
chapitre
-
comprendre
comment
s'opère
chargement
dynamique
classes
mémoire
lors
l'exécution
d'un
programme
Java
-
comprendre
traitement
champs
blocs
static
chargement
classe
machine
virtuelle
Java
JVM
interpréteur
code
Java
compilé
bytecode
permettant
d'exécuter
programme
Java
machine
cible
L'espace
mémoire
JVM
comporte
plusieurs
zones
notamment
-
Zone
méthodes
contient
code
méthodes
constructeurs
ainsi
informations
structure
chaque
classe
notamment
table
symboles
-
pile
espace
propre
chaque
thread
mémorise
dynamiquement
contextes
d'exécution
variables
locales
notamment
méthodes
cours
d'exécution
-
tas
contient
objets
créés
new
instances
classe
tableaux
cf
chapitre
4
C'est
demande
d'exécution
d'un
programme
Java
lance
machine
virtuelle
Java
JVM
réalise
alors
grandes
étapes
suivantes
-
chargement
classe
principale
spécifiée
main
class
classes
dépend
immédiatement
premier
rang
desquelles
toutes
sur-classes
o
création
champs
static
création
table
méthodes
o
traitement
champs
initialisation
blocs
exécution
static
-
exécution
méthode
main
classe
principale
Durant
l'exécution
d'un
code
Java
classes
bytecode
chargées
JVM
fur
mesure
besoins
hiérarchie
d'héritage
chargement
classes
opéré
ordre
hiérarchique
descendant
i.e
super-classe
racine
vers
classe
courante
Exemple
public
class
ClassA
{
static
{
System.out.println
``
Start
loading
ClassA
}
public
static
final
int
private
static
int
=
100
static
{
=
29979
}
static
{
System.out.println
``
=
``
+
System.out.println
``
=
``
+
}
public
ClassA
{
System.out.println
``
Start
ClassA
=
+
1
System.out.println
``
End
ClassA
}
public
int
getN
{
return
}
static
{
System.out.println
``
End
loading
ClassA
}
}
//
end
ClassA
public
class
ClassB
extends
ClassA
{
static
{
System.out.println
``
Start
loading
ClassB
}
private
int
x
=
5
public
ClassB
{
System.out.println
``
Start
ClassB
x
=
x
+
getN
System.out.println
x
System.out.println
``
End
ClassB
}
static
{
System.out.println
``
End
loading
ClassB
}
}
//
end
ClassB
public
class
Class
{
static
{
System.out.println
``
Start
loading
Class0
}
private
static
int
=
initY
private
static
int
initY
{
System.out.println
``
Init
return
256
}
public
static
void
main
String
args
{
System.out.println
``
Start
main
Class0
ClassB
b
=
new
ClassB
System.out.println
``
End
main
Class0
}
static
{
System.out.println
``
End
loading
Class0
}
}
//
end
Class0
Après
compilation
trois
classes
l'exécution
commande
java
Class0
affichera
commentaires
ajoutés
marge
Start
loading
Class0
Init
End
loading
Class0
Start
main
Class0
Start
loading
ClassA
//
Sur-classes
ClassB
d'abord
=
29979
=
100
End
loading
ClassA
Start
loading
ClassB
//
puis
enfin
ClassB
End
loading
ClassB
Start
ClassA
//
Car
super
d'abord
End
ClassA
Start
ClassB
106
//
100
+
1
ClassA
+
5
ClassB
End
ClassB
End
main
Class0
15
ANNEXE
5
-
COMMUNICATION
ENTRE
JAVA
JNI
Références
The
Java
Native
Interface
Programmer
'
Guide
and
Specification
java.sun.com/docs/books/jni/
Tutoriel
java.sun.com/docs/books/jni/html/jniTOC.html
Java
Native
Interface
Specification
v1.5
java.sun.com/j2se/1.5.0/docs/guide/jni/spec/jniTOC.html
javah
-
Header
and
Stub
File
Generator
java.sun.com/javase/6/docs/technotes/tools/windows/javah.html
pose
problème
d'appeler
sous-programme
depuis
méthode
Java
environnement
Unix
solution
met
oeuvre
l'interface
programmation
JNI
Java
Native
Interface
offert
plate-forme
Java
JNI
ensemble
fonctionnalités
permet
programme
Java
fonctionnant
machine
virtuelle
Java
JVM
d'appeler
d'être
appelé
programme
écrit
autre
langage
typiquement
C++
assembleur
permettant
l'interfaçage
applications
bibliothèques
natives
1
mise
oeuvre
JNI
accroît
l'interopérabilité
applications
Java
évidemment
détriment
portabilité
bonne
architecture
l'application
devrait
minimiser
nombre
classes
faisant
référence
méthode
native
suite
supposera
fichier
Java
appelant
sous-programme
nomme
MyClass.java
fichier
implémentant
sous-programme
nomme
MyRoutines.c
développement
l'application
complète
comporte
6
étapes
1
Ecrire
programme
Java
compiler
javac
MyClass.java
2
Produire
fichier
d'en-tête
MyClass.h
programme
javah
MyClass
3
Ecrire
sous-programme
compiler
gcc
-o
MyRoutines
-c
MyRoutines.c
-pedantic
-W
-Wal1l
-Idir
dir
répertoire
d'installation
JDK
fichiers
d'include
JNI
exemple
fichiers
répartis
deux
répertoires
gcc
-o
MyRoutines
-c
MyRoutines.c
-pedantic
-W
-Wall
-I/usr/lib/jdk1.5.0v11/include
-I/usr/lib/jdk1.5.0v11/include/linux
1
application
bibliothèque
sous-programmes
dite
code
natif
dépendante
d'un
environnement
hôte
système
d'exploitation
jeu
d'instructions
processeur
particulier
exemple
programme
compilé
système
d'exploitation
donné
code
natif
car
fonctionnera
autre
système
d'exploitation
4
Produire
bibliothèque
partagée
lib
*
.so
chargeable
programme
Java
gcc
-Wall
-shared
-o
libMyRoutines.so
MyRoutines.o
5
Avant
toute
première
exécution
spécifier
machine
virtuelle
Java
chemin
d'accès
bibliothèque
setenv
LD_LIBRARY_PATH
path
path
désigne
chemin
d'accès
supposant
celui-ci
répertoire
courant
commande
setenv
LD_LIBRARY_PATH
6
Exécuter
programme
Java
java
MyClass
façon
d'écrire
programme
Java
d'implémenter
sous-programme
associé
illustrée
ci-après
15.1
Appel
d'une
procédure
considèrera
bout
bout
exemple
15.1.1
Déclaration
appel
java
Exemple
classe
java
public
class
MyClass
{
//
Declaration
of
an
extern
class
procedure
native
public
static
void
procedure1
//
Declaration
of
an
extern
instance
procedure
native
public
void
procedure2
//
Test
procedure
public
static
void
main
String
argv
{
MyClass.procedure1
MyClass
o
=
new
MyClasse
o.procedure2
}
//
Load
the
library
libMyRoutines
static
{
System.loadLibrary
``
MyRoutines
}
}
Commentaires
-
modificateur
native
indique
qu'il
s'agit
d'une
procédure
externe
non
écrite
java
nom
procédure
arbitraire
-
méthode
loadLibrary
va
charger
bibliothèque
libMyRoutines.so
mot
clé
static
encapsule
bloc
d'instructions
lequel
l'appel
réalisé
permet
d'exécuter
bloc
dès
chargement
classe
MyClass
sans
avoir
besoin
passer
l'appel
d'une
méthode
intermédiaire
15.12
Prototype
fichier
MyClass.h
produit
javah
cf
étape
2
précédente
spécifie
prototypes
devront
respecter
sous-programmes
écrire
Contenu
expurgé
fichier
MyClass.h
produit
javah
/
*
DO
NOT
EDIT
THIS
FILE
-
it
is
machine
generated
*
/
/
*
Header
for
class
MYClass
*
/
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
JNIEnv
*
jclass
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
JNIEnv
*
jobject
Commentaires
-
JNIEXPORT
JNICALL
deux
macros
prédéfinies
JNI
faire
communiquer
java
-
void
spécifie
qu'il
s'agit
d'une
procédure
-
Java_MyClass_procedure1
nom
imposé
devra
porter
procédure
correspondant
méthode
nom
procedure1
déclarée
programme
java
idem
procedure2
-
Deux
paramètres
systématiquement
introduits
tête
liste
paramètres
o
premier
type
JNIEnv
*
pointeur
vers
l'environnement
JNIEnv
lui-même
pointeur
vers
structure
contenant
fonctions
d'interface
machine
virtuelle
java
JVM
o
second
type
jclass
s'il
s'agit
d'une
méthode
classe
jobject
s'il
s'agit
d'une
méthode
d'instance
pointeur
vers
descripteur
classe
l'objet
sorte
this
d'appel
15.1.3
implémentation
Exemple
fichier
MyRoutines.c
#
include
stdio.h
#
include
``
MyClass.h
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
JINIEnv
*
penv
jclass
cla
{
printf
``
Routine
procedure1\n
}
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
JINIEnv
*
penv
jobject
obj
{
printf
``
Routine
procedure2\n
}
15.2
Echange
données
entre
Java
L'échange
données
entre
l'application
java
sous-programme
paramètres
résultat
fonction
suppose
compatibilité
types
correspondants
Or
'
correspondance
systématique
naturelle
entre
types
langage
Java
types
langage
caractère
exemple
codé
16
bits
Java
8
bits
JNI
définit
ensemble
types
noms
*
correspondent
types
Java
JNI
traite
types
primitifs
types
objets
différemment
correspondance
types
primitifs
directe
voir
tableau
ci-après
car
repose
représentation
machine
données
identique
n'est
cas
types
objets
transmission
d'une
chaîne
caractères
d'un
tableau
fortiori
d'une
instance
quelconque
classe
n'est
directe
nécessite
conversions
type
paramètre
java
type
objet
ainsi
transmis
sous-
programme
sous
forme
d'un
pointeur
structure
données
interne
machine
virtuelle
Java
L'organisation
interne
structure
masquée
programmeur
celui-ci
peut
néanmoins
accéder
composantes
sous-jacentes
via
fonctions
utilitaires
offertes
JNI
l'environnement
JNIEnv
Type
primitif
Java
Type
primitif
côté
Description
boolean
jboolean
unsigned
8
bits
byte
jbyte
signed
8
bits
char
jchar
unsigned
16
bits
short
jshort
signed
16
bits
int
jint
signed
32
bits
long
jlong
signed
64
bits
float
jfloat
32
bits
double
jdouble
64
bits
suite
considèrera
bout
bout
exemple
15.2.1
Déclaration
appel
java
Exemple
classe
java
public
class
MyClass
{
//
Declaration
of
an
extern
instance
function
native
public
String
getMessage
int
id
String
prompt
//
Test
procedure
public
static
void
main
String
argv
{
MyClass
o
=
new
MyClasse
System.out.println
o.getMessage
10
``
Name
``
}
//
Load
the
library
libMyRoutines
static
{
System.loadLibrary
``
libMyRoutines
}
}
15.22
Prototype
Contenu
expurgé
fichier
MyClass.h
produit
javah
/
*
DO
NOT
EDIT
THIS
FILE
-
it
is
machine
generated
*
/
/
*
Header
for
class
MYClass
*
/
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
INIEnv
*
jobject
jint
jstring
15.2.3
implémentation
Exemple
fichier
MyRoutines.c
#
include
stdio.h
#
include
``
MyClass.h
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
JINIEnv
*
penv
jobject
obj
jint
jid
jstring
jprompt
{
const
char
*
str
char
buf
128
/
*
Get
the
string
from
the
java
string
*
/
str
=
*
penv
-
GetStringUTFChars
penv
jprompt
NULL
printf
``
-
jid
str
/
*
Do
n't
forget
this
line
*
/
*
penv
-
ReleaseStringUTFChars
penv
jprompt
str
/
*
Assume
the
user
does
n't
type
more
than
127
char
*
/
scanf
``
buf
return
*
penv
-
NewStringUTF
penv
buf
}
Commentaires
-
représentations
physiques
chaînes
type
jstring
type
char
*
identiques
conversion
doit
être
réalisée
C'est
rôle
fonctions
GetStringUTFChars
NewStringUTF
noter
tous
cas
conversion
caractères
non
codables
ASCII
7
bits
lettres
accentuées
posera
problème
-
fonction
GetStringUTFChars
réalisant
allocation
mémoire
dynamique
désallocation
doit
être
obligatoirement
réalisée
avant
fin
sous-
programme
c'est
rôle
fonction
ReleaseStringUTFChars
16
ANNEXE
6
-
PLATES-FORMES
JAVA
Références
Java
Platform
Standard
Edition
6
API
Specification
java.sun.com/javase/6/docs/api/
New
features
and
Enhancements
J2SE
5.0
java.sun.com/j2se/1.5.0/docs/relnotes/features.html
Java
Platform
Standard
Edition
java.sun.com/javase/
Java
Platform
Enterprise
Edition
java.sun.com/javaee/
Java
Platform
Micro
Edition
java.sun.com/javame/
JDK
Tools
and
Utilities
java.sun.com/javase/6/docs/technotes/tools/
Sun
Microsystems
fournit
trois
plates-formes
Java
permettant
développement
l'exécution
programmes
Java
Java
standard
base
Java
EE
Java
noter
noms
ceux
employés
versions
sorties
depuis
2006
antérieurement
plates-
formes
nommées
respectivement
J2SE
J2EE
J2ME
Java
Platform
Standard
Edition
Java
plate-forme
framework
Java
base
permettant
développer
ou/et
exécuter
programmes
Java
dernière
version
nommée
J2SE
version
5.0
porte
nom
J2SE
5.0
souligner
version
apportait
mise
jour
majeure
rapport
précédente
version
actuelle
plus
récente
date
décembre
2006
c'est
version
6
porte
nom
Java
6
version
7
Java
7
annoncée
comme
nouvelle
mise
jour
majeure
mi
2010
toujours
attendue
plate-forme
Java
délivre
deux
produits
logiciels
principaux
Java
Runtime
Environment
plus
communément
JRE
fournit
librairies
machine
java
virtuelle
d'autres
composantes
nécessaires
exécuter
programmes
Java
Java
Development
Kit
plus
communément
JDK
inclut
JRE
plus
outils
développement
tels
compilateur
débogueur
nécessaires
utiles
développer
programmes
Java
noter
terme
JDK
bien
très
populaire
devenu
imprécis
car
d'autres
plates-formes
Java
Java
EE
exemple
comportent
elles
aussi
propre
kit
développement
Java
Platform
Enterprise
Edition
Java
EE
plate-forme
framework
Java
plus
particulièrement
destiné
applications
d'entreprises
offre
cadre
standard
développer
applications
distribuées
Java
Platform
Micro
Edition
Java
plate-forme
framework
Java
spécialisé
applications
mobiles
plates-formes
Java
compatibles
J2ME
embarquées
nombreux
téléphones
mobiles
PDA
façon
plus
spécifique
pourrait
aussi
citer
plateformes
Java
Card
fournit
environnement
développement
d'applications
cartes
puce
JavaFX
créer
Rich
Internet
Applications
17
ANNEXE
7
-
GLOSSAIRE
trouve
facilement
web
d'excellentes
définitions
anglais
termes
sigles
produits
référence
informatiques
Parmi
sources
possibles
citons
exemple
-
parmi
encyclopédies
www.wikipedia.org
version
anglaise
plus
complète
-
parmi
moteurs
spécialisés
recherche
encyclopédies
dictionnaires
glossaires
www.answers.com
Voici
glossaire
quelques
termes
sigles
généraux
courants
Sigle
/
terme
Définition
Commentaire
API
Application
Programming
Bibliothèque
fonctionnalités
communes
Interface
courantes
bas
niveau
Constitue
interface
entre
couches
basses
couches
applicatives
plus
haut
niveau
Exemple
java.sun.com/javase/6/docs/api/
spécifie
API
standard
Java
fournies
JDK
6
Framework
Cadre
d'applications
Ensemble
cohérent
classes
généralement
abstraites
d'interfaces
permettant
développement
rapide
d'applications
Fournit
suffisamment
briques
logicielles
pouvoir
produire
application
aboutie
Typiquement
spécialisé
type
d'application
GUI
Graphical
User
Interface
Interface
homme-machine
graphique
opposition
interface
ligne
commande
IDE
Integrated
Development
Programme
regroupant
ensemble
d'utilitaires
Environment
logiciels
développement
programmes
éditeur
texte
compilateur
débogueur
gestionnaire
versions
aide
production
d'interfaces
Généralement
dédié
seul
langage
programmation
JDK
Java
Development
Kit
voir
chapitre
16
JFC
Java
Foundation
Classes
Cadre
d'applications
graphiques
Ensemble
classes
Java
permettant
construire
interfaces
utilisateur
graphiques
portables
Contient
notamment
composants
Swing
JRE
Java
Runtime
Environment
voir
chapitre
16
J2EE
Java
2
Platform
Enterprise
voir
chapitre
16
Edition
Java
Java
Platform
Enterprise
J2ME
Java
2
Platform
Micro
voir
chapitre
16
Edition
Java
Java
Platform
Micro
Edition
J2SE
Java
2
Platform
Standard
voir
chapitre
16
Edition
Java
Java
Platform
Standard
Edition
plus
spécifiquement
cadre
d'applications
professionnelles
Java
distribuées
Sigle
/
terme
Définition
Commentaire
EJB
Enterprise
JavaBeans
Technologie
Java
offerte
plateforme
Java
EE
permettant
créer
composants
distribués
hébergés
serveur
d'applications
architecture
MVC
utilisé
réaliser
Modèle
java.sun.com/products/ejb/
JSP
Java
Server
Pages
Technologie
Java
offerte
plateforme
Java
EE
permettant
créer
pages
Web
dynamiques
architecture
MVC
utilisé
réaliser
Vue
java.sun.com/products/jsp/
Servlet
Technologie
Java
offerte
plateforme
Java
EE
permettant
d'étendre
fonctionnalité
d'un
serveur
Web
accès
bases
données
transactions
'
e-commerce
......
architecture
MVC
utilisé
réaliser
Contrôleur
java.sun.com/products/servlet/
