langage
java
Petit
mémento
de
syntaxe
&
élément
de
programmation
site
de
REFERENCE
site
officiel
de
java
être
:
dns-remplacer
.
pouvoir
consulter
avec
intérêt
:
-
tutoriel
:
dns-remplacer
/
doc
/
books
/
tutorial
/
-
grand
collection
de
petit
exemple
de
programme
:
dns-remplacer
/
developer
/
codesamples
/
examplet
/
-
recommandation
de
style
:
dns-remplacer
/
doc
/
codeconv
/
html
/
dns-remplacer
-
descriptif
de
paquetage
,
classe
méthode
standard
:
dns-remplacer
/
javase
/
/
doc
/
api
/
-
mode
de
emploi
générateur
de
documentation
javadoc
:
dns-remplacer
/
j2se
/
javadoc
/
dns-remplacer
-
préparation
à
certification
de
programmeur
java
:
dns-remplacer
/
doc
/
books
/
tutorial
/
extra
/
certification
/
sommaire
langage
programmation
orienter
objet
...
programme
java
...
...
.
style
de
programmation
Identificateurs
...
commentaire
...
...
commentaire
de
documentation
...
...
commentaire
de
implémentation
...
fichier
java
...
nom
contenir
de
fichier
java
...
...
compilation
,
exécution
,
génération
de
documentation
paquetage
...
paquetage
standard
...
...
affectation
de
classe
à
paquetage
...
...
importation
de
classe
de
paquetage
classe
interface
...
...
classe
standard
...
...
classe
abstraire
sous-classe
...
classe
abstrait
.
sous-classe
...
interface
...
...
interface
...
classe
implanter
interface
...
Enumération
...
...
...
...
...
...
classe
imbriquer
(
Nested
classe
)
...
contrôle
de
accès
par
modificateur
...
instance
de
classe
...
...
type
de
DONNEES
...
.
type
primitif
...
type
objet
(
type
référence
)
.
.
.
classe
enveloppe
...
.
.
chaîne
de
caractère
modifiable
(
string
)
...
chaîne
de
caractère
modifiable
(
StringBuffer
)
...
...
...
...
...
...
...
...
.
.
tableau
...
...
collection
...
...
Transtypage
...
...
OPERATEURS
expression
...
...
opérateur
expression
arithmétique
...
opérateur
expression
booléen
...
opérateur
relationnel
...
METHODES
...
définition
appel
de
méthode
ordinaire
...
constructeur
...
...
méthode
main
...
...
...
...
...
.
instruction
...
...
instruction
de
affectation
...
...
instruction
de
contrôle
...
instruction
de
sélection
...
...
instruction
de
boucle
...
...
instruction
de
entrée
/
sortie
...
notion
de
flux
...
entrée
/
sortie
terminal
...
...
entrée
/
sortie
fichier
...
...
lecture
de
chaîne
de
caractère
formater
...
HERITAGE
...
...
.
notion
de
héritage
...
hériter
sous-classe
?
...
...
redéfinir
méthode
...
type
statique
/
dynamique
-
liaison
statique
/
dynamique
...
type
statique
/
dynamique
-
Transtypage
...
...
...
...
...
...
...
liaison
statique
/
dynamique
...
polymorphisme
...
...
classe
méthode
particulier
...
interface
...
...
exception
...
...
exception
contrôler
contrôler
...
classe
de
exception
standard
...
...
hiérarchie
Error
...
...
...
hiérarchie
exception
...
hiérarchie
RuntimeException
...
...
...
.
...
lancement
de
exception
...
...
capture
de
exception
...
...
...
clause
throws
...
instruction
try
.
.
catch
...
...
...
...
.
.
iii
définir
nouveau
classe
de
exception
...
annexe
-
programmation
graphique
...
swing
.
.
...
...
conteneur
composant
...
...
gestion
de
mise
en
page
...
...
gestion
événement
...
notion
de
événement
...
réaliser
gestionnaire
de
événement
...
...
...
...
...
affichage
/
fermeture
de
fenêtre
graphique
...
architecture
composant
swing
...
...
Applet
...
...
annexe
-
THREADS
...
...
créer
thread
par
extension
de
classe
Thread
...
créer
thread
par
implémentation
de
interface
Runnable
...
...
...
...
...
...
...
.
.
synchronisation
communication
entre
threads
...
section
critique
synchronisation
...
communication
entre
threads
...
...
annexe
-
conception
DEVELOPPEMENT
en
java
...
conseil
général
pour
bon
conception
classe
...
architecture
de
application
interactif
:
modèle
MVC
...
test
unitaire
...
...
définition
...
JUnit
...
...
...
.
java
Beans
...
...
design
pattern
...
...
exemple
:
modèle
singleton
...
...
exemple
:
modèle
Decorator
...
...
...
...
...
.
.
...
annexe
-
machine
virtuel
java
(
JVM
)
...
annexe
-
communication
entre
java
C
(
JNI
)
...
...
...
...
...
...
appel
de
procédure
C
...
déclaration
appel
java
.
...
prototype
C
...
Implémentation
C
...
...
Echange
de
donnée
entre
java
C
...
déclaration
appel
java
...
...
prototype
C
...
Implémentation
C
...
...
annexe
-
PLATES-FORMES
java
...
...
annexe
-
glossaire
...
...
langage
programmation
orienter
objet
java
[
]
être
langage
de
programmation
orienter
objet
.
objet
être
représentation
simplifier
de
entité
monde
réel
:
entité
concret
(
:
voiture
)
(
:
date
de
)
.
objet
caractériser
par
état
comportement
.
objet
stocker
état
dans
variable
appelé
champ
(
attribut
)
présenter
comportement
travers
de
fonctionnalité
appelé
méthode
.
exemple
de
objet
:
maVoiture
=
{
valeur
attribut
:
Fiat
,
gris
,
/
100km
,
...
.
;
méthode
:
démarrer
,
arrêter
,
accélérer
,
...
.
}
,
état
être
encapsuler
cœur
de
objet
être
accessible
depuis
extérieur
de
objet
,
en
consultation
modification
,
via
méthode
offrir
par
objet
.
exemple
:
objet
maVoiture
getCouleur
setCouleur
démarrer
arrêter
accélérer
...
Fiat
griser
interagir
avec
objet
en
envoyer
message
de
demande
de
activation
de
un
de
méthode
.
exemple
de
envoi
de
message
à
objet
:
dns-remplacer
élérer
(
)
;
méthode
particulier
,
appeler
constructeur
,
permettre
de
initialiser
état
de
objet
à
création
.
classe
servir
à
regrouper
sous
même
catégorie
même
nom
générique
objet
partager
même
type
de
état
même
comportement
.
classe
être
type
de
objet
;
dire
objet
être
instance
de
classe
.
exemple
de
classe
:
automobile
=
{
attribut
:
marque
,
couleur
,
consommation
,
...
.
;
méthode
:
démarrer
,
arrêter
,
accélérer
,
...
.
}
classe
pouvoir
être
organiser
en
hiérarchie
.
classe
hériter
attribut
méthode
classe
situer
sur
ligne
hiérarchique
ascendant
.
réaliser
programme
dans
langage
orienter
objet
,
être
:
-
modéliser
par
classe
objet
avoir
à
manipuler
-
écrire
classe
dans
langage
de
programmation
orienter
objet
-
créer
objet
instance
de
classe
-
communiquer
avec
objet
en
invoquer
méthode
.
[
]
java
être
naître
en
dans
entreprise
californien
Sun
Microsystems
.
avoir
être
concevoir
par
James
GOSLING
&
al
.
programme
java
style
de
programmation
être
admettre
respect
de
syntaxe
programme
fonctionner
être
critère
de
qualité
suffisant
pour
programme
.
expérience
de
programmation
avoir
conduire
à
établir
recommandation
de
style
.
respecter
être
obligatoire
contribuer
à
améliorer
lisibilité
programme
.
convention
viser
faire
finalité
économique
:
contribuer
à
produire
programme
maintenable
pendant
durée
de
vie
.
dans
chapitre
suivant
,
exemple
respecter
convention
de
style
préconiser
par
dns-remplacé
Identificateurs
règle
recommandation
pour
nommer
identificateurs
:
+
caractère
minuscule-majuscule
caractère
être
discriminant
(
règle
langage
java
)
+
identificateurs
de
objet
,
de
champ
de
méthode
commencer
par
minuscule
(
par
convention
)
+
identificateurs
de
classe
(
de
interface
)
commencer
par
majuscule
(
par
convention
)
+
identificateurs
de
constant
être
en
majuscule
(
par
convention
)
+
identificateurs
de
méthode
commencer
par
verbe
(
recommandation
)
commentaire
commentaire
de
documentation
commentaire
de
documentation
viser
à
décrire
spécification
code
,
sans
considération
de
implémentation
.
être
destiner
à
développeur
utilisateur
avoir
code
source
sous
main
.
commentaire
pouvoir
être
extraire
par
utilitaire
javadoc
en
constituer
fichier
de
documentation
en
HTML
.
documentation
de
classe
devoir
inclure
avoir
minima
:
-
nom
de
classe
,
fonctionnalité
grand
caractéristique
,
auteur
,
version
-
documentation
pour
constructeur
méthode
documentation
de
méthode
devoir
inclure
avoir
minima
:
-
nom
de
méthode
,
fonctionnalité
,
description
de
paramètre
de
valeur
retourner
,
exception
susceptible
de
être
lancer
par
méthode
syntaxe
:
/
*
*
*
commentaire
*
/
/
*
*
commentaire
*
/
principal
balise
de
commentaire
prédéfini
:
@
author
@
version
@
param
@
return
@
see
@
throws
commentaire
de
implémentation
commentaire
de
implémentation
viser
à
expliciter
(
sans
paraphraser
)
code
choix
de
implémentation
.
choix
identificateurs
clarté
de
programmation
devoir
permettre
de
minimiser
nombre
de
commentaire
.
syntaxe
:
/
*
*
commentaire
*
/
/
*
commentaire
*
/
/
/
commentaire
fichier
java
nom
contenir
de
fichier
java
+
fichier
source
java
contenir
seul
classe
publique
.
organisation
recommandé
être
suivant
:
)
commentaire
de
début
.
être
commentaire
de
documentation
comprendre
:
intitulé
de
classe
descriptif
sommaire
de
fonction
,
auteur
,
version
)
instruction
de
paquetage
)
instruction
de
import
)
déclaration
classe
+
fichier
devoir
contenir
de
ligne
ligne
de
de
caractère
,
pour
commentaire
de
documentation
(
recommandation
)
+
fichier
java
porter
nom
de
classe
publique
contenir
;
fichier
source
java
avoir
pour
suffixe
.java
;
fichier
java
compiler
avoir
pour
suffixe
.class
(
par
convention
)
.
suffixe
.java
.class
être
imposer
par
outil
.
compilation
,
exécution
,
génération
de
documentation
depuis
ligne
de
commande
:
+
compilation
:
javac
dns-remplacer
+
exécution
:
java
fileName
/
/
fichier
main
+
génération
de
documentation
:
javadoc
*
.
java
pour
avoir
documentation
`
`
programmeur
`
`
complet
(
comprendre
membre
priver
)
de
classe
de
interaction
,
falloir
lancer
commander
avec
option
-
private
.
paquetage
paquetage
(
package
en
anglais
)
être
bibliothèque
de
classe
organiser
de
façon
hiérarchique
.
nom
de
paquetage
être
nom
de
répertoire
.
nom
de
paquetage
être
en
lettre
minuscule
(
par
convention
)
.
différent
paquetage
pouvoir
être
rassembler
compacter
dans
fichier
de
archiver
.zip
.jar
paquetage
standard
variable
de
environnement
CLASSPATH
indiquer
à
machine
virtuel
java
trouver
classe
bibliothèque
de
classe
avoir
besoin
.
hiérarchie
partiel
paquetage
standard
:
java
applet
awt
io
lang
util
event
paquetage
utile
paquetage
contenir
dns-remplacé
classe
relatif
entrée
/
sortir
dns-remplacer
classe
fondamental
:
type
basique
(
classe
enveloppe
,
string
,
StringBuffer
,
...
...
)
,
classe
math
,
...
dns-remplacé
classe
utilitaire
divers
:
collection
(
ArrayList
,
Vector
,
...
)
,
classe
Random
,
gestion
date
heure
,
...
affectation
de
classe
à
paquetage
classe
appartenir
à
paquetage
,
falloir
déclarer
paquetage
de
appartenance
en
tête
de
fichier
source
.
syntaxe
:
package
packageName
;
importation
de
classe
de
paquetage
pour
utiliser
classe
définir
dans
paquetage
autre
de
classe
de
utilisation
,
classe
devoir
être
importer
en
tête
de
fichier
source
.
syntaxe
:
import
dns-remplacer
;
import
packageName
.
*
;
/
/
former
déconseiller
informatif
exemple
:
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacé
.
*
;
/
/
former
déconseiller
informatif
paquetage
dns-remplacé
être
importer
.
classe
interface
classe
standard
syntaxe
:
public
class
ClassName
{
Fields
Constructors
Methods
/
/
accessor
methods
...
/
/
mutator
methods
...
}
exemple
:
/
*
*
*
RationalNumber
-
Represents
avoir
rational
number
num
/
den
*
*
@
author
AM
*
@
version
*
*
/
public
class
RationalNumber
{
/
/
FIELDS
private
int
numerator
;
private
int
denominator
;
private
boolean
reduced
;
/
/
CONSTRUCTORS
/
*
*
Construct
avoir
rational
number
initialized
to
/
*
/
public
RationalNumber
(
)
{
numerator
=
;
denominator
=
;
reduced
=
true
;
}
/
/
METHODS
-
ACCESSORS
/
*
*
Get
the
numerator
of
this
rational
number
*
/
public
int
getNumerator
(
)
{
return
numerator
;
}
/
*
*
Get
the
denominator
of
this
rational
number
*
/
public
int
getDenominator
(
)
{
return
denominator
;
}
/
*
*
Return
true
iff
the
numerator
/
denominator
form
is
irreducible
*
/
public
boolean
isReduced
(
)
{
return
reduced
;
}
/
/
METHODS
-
MUTATORS
/
*
*
set
this
rational
number
to
_numerator
/
_denominator
*
/
public
void
setNumber
(
int
_numerator
,
int
_denominator
)
{
numerator
=
_numerator
;
denominator
=
_denominator
;
reduced
=
false
;
}
/
*
*
set
this
rational
number
to
avoir
irreducible
*
numerator
/
denominator
form
*
/
public
void
reduce
(
)
{
int
divisor
=
greatestCommonDivisor
(
numerator
,
denominator
j
)
;
numerator
=
numerator
/
divisor
;
denominator
=
denominator
/
divisor
;
reduced
=
true
;
}
/
/
METHODS
-
UTILITIES
/
*
*
Return
the
greatest
common
divisor
of
the
two
integers
*
x
and
*
/
private
int
greatestCommonDivisor
(
int
x
,
int
)
{
int
divisor
;
/
/
...
à
implémenter
...
return
divisor
;
}
}
/
/
end
RationalNumber
classe
abstraire
sous-classe
classe
posséder
méthode
abstrait
(
i.e.
.
sans
corps
)
être
abstraire
devoir
être
déclarer
avec
modificateur
abstract
.
classe
abstrait
pouvoir
être
instanciées
.
pour
pouvoir
créer
objet
,
falloir
créer
sous-classe
dans
méthode
abstrait
être
définir
:
sous-
classe
,
abstraire
,
pouvoir
être
instanciée
.
classe
abstraire
syntaxe
:
public
abstract
class
ClassName
{
Fields
Constructors
Methods
}
exemple
:
/
*
*
*
abstract
class
progression
*
*
Represents
avoir
real
linear
progression
of
order
with
constant
*
coefficient
*
*
@
author
AM
*
@
version
*
/
public
abstract
class
progression
{
/
/
FIELDS
private
double
u0
;
/
/
the
first
term
of
the
progression
/
/
CONSTRUCTORS
/
*
*
Define
avoir
progression
,
the
first
term
of
which
is
u0
*
/
public
progression
(
double
u0
)
{
dns-remplacer
=
u0
;
}
/
/
METHODS
/
*
*
Get
the
first
term
of
this
progression
*
/
public
double
getu0
(
)
{
return
u0
;
}
/
*
*
Given
à
current
term
u
(
n
)
,
return
the
next
term
u
(
n+1
)
*
/
public
abstract
double
nextTerm
(
double
un
)
;
/
*
*
Return
the
term
of
rank
n
*
/
public
double
termOfRank
(
int
n
)
{
double
u
=
u0
;
/
/
u
(
n
)
double
v
;
/
/
u
(
n+1
)
for
(
int
i
=
;
i
<
=
n
;
i++
)
{
v
=
nextTerm
(
u
)
;
u
=
v
;
}
return
u
;
}
}
/
/
end
progression
sous-classe
syntaxe
:
public
class
SubclassName
extends
SuperclassName
{
Fields
Constructors
Methods
}
exemple
:
/
*
*
*
ArithGeomProgression
*
*
Represents
avoir
real
arithmetic-geometric
progression
with
constant
*
coefficient
:
u
(
n+1
)
=
avoir
*
u
(
n
)
+
b
*
*
@
author
AM
*
@
version
*
/
public
class
ArithGeomProgression
extends
progression
{
/
/
FIELDS
private
double
avoir
;
/
/
multiplying
coefficient
private
double
b
;
/
/
additif
coefficient
/
/
CONSTRUCTORS
/
*
*
Define
an
arithmetic-geometric
progression
*
@
param
u0O
first
term
of
the
progression
*
@
param
avoir
multiplying
coefficient
*
@
param
b
additif
coefficient
*
/
public
ArithGeomProgression
(
double
u0
,
double
avoir
,
double
b
)
{
super
(
u0
)
;
this.a.
=
avoir
;
this.b.
=
b
;
}
/
/
METHODS
/
*
*
Given
à
current
term
u
(
n
)
,
return
the
next
term
u
(
n+1
)
*
/
public
double
nextTerm
(
double
u
)
{
return
avoir
*
u
+
b
;
}
}
/
/
end
ArithGeomProgression
interface
remarquer
liminaire
.
terme
`
`
interface
`
`
avoir
sémantique
multiple
.
dans
cadre
de
programmation
en
java
,
pouvoir
prendre
,
selon
contexte
,
trois
sens|sen
distinct
(
même
conceptuellement
apparenter
)
:
-
sens|sen
informatique
commun
:
interface
être
`
`
jonction
entre
deux
élément
(
matériel
logiciel
)
permettre
échange
de
information
`
`
;
par
exemple
,
interface
homme-machine
.
-
sens|sen
programmation
objet
:
interface
de
classe
être
partie
visible
publique
de
classe
;
définir
par
liste
membre
(
attribut
,
constructeur
,
méthode
)
priver
associer
à
commentaire
de
documentation
-
sens|sen
spécifique
langage
java
:
interface
être
sorte
de
classe
abstrait
posséder
caractéristique
particulier
définir
protocole
de
comportement
;
être
sens|sen
être
définir
dans
section
.
être
contexte
de
utilisation
donner
sens|sen
mot
interface
.
interface
(
sens|sen
langage
java
)
être
sorte
de
classe
abstraire
sans
détail
de
implémentation
posséder
degré
de
abstraction
supérieur
à
classe
abstrait
.
interface
:
-
avoir
méthode
être
abstraire
(
avoir
de
corps
)
-
à
noter
être
recommander
de
ajouter
modificateur
abstract
puisqu'il
être
implicite
;
-
posséder
de
champ
,
à
exception
éventuel
de
constant
de
classe
(
static
final
)
assigner
;
-
membre
être
public
interface
être
publique
.
interface
spécifier
signature
minimal
de
classe
implémente
.
interface
être
contrat
à
respecter
.
classe
implémentir
interface
,
engager
à
conformer
à
interface
.
classe
pouvoir
implémenter
interface
.
classe
définir
type
implémentation
;
interface
définir
type
sans
implémentation
.
interface
syntaxe
:
public
interface
InterfaceName
{
constantAttribute
abstractMethods
}
exemple
:
public
interface
Measurable
{
double
size
(
)
;
/
*
*
@
return
,
,
if
this
is
<
,
=
>
than
x
*
/
int
isLargerThan
(
Measurable
x
)
;
}
classe
implanter
interface
syntaxe
:
public
class
ClassName
implements
InterfaceNamel
,
InterfaceName2
,
...
{
...
}
exemple
:
public
class
square
implements
Measurable
{
private
double
width
;
public
square
(
double
_width
)
{
width
=
_width
;
}
public
double
size
(
)
{
return
width
*
width
;
}
public
int
isLargerThan
(
Measurable
x
)
{
if
(
dns-remplacer
(
)
<
x.size
(
)
)
{
return
;
}
if
(
dns-remplacer
(
)
>
x.size
(
)
)
{
return
;
}
return
;
}
}
Enumération
classe
enum
permettre
de
représenter
ensemble
de
constante
nommé
type
être
classe
même
.
classe
contribuer
à
accroître
lisibilité
programme
.
syntaxe
:
public
enum
EnumName
{
/
/
List
of
named
constant
.
/
/
Possibility
of
other
fields
and
methods
.
}
exemple
:
public
enum
direction
{
NORTH
,
SOUTH
,
EAST
,
WEST
;
}
public
class
test
{
private
direction
dir
;
public
setDir
(
direction
d
)
{
dir
=
d
;
}
public
boolean
isNorthSouth
(
)
{
return
(
dir
=
=
dns-remplacé
)
|
|
(
dir
=
=
dns-remplacer
)
;
}
}
sous
forme
simple
,
classe
enum
être
utiliser
sous
forme
de
classe
interne
(
inner
)
.
exemple
:
public
class
MyClass
{
private
direction
dir
;
...
private
enum
direction
{
NORTH
,
SOUTH
,
EAST
,
WEST
;
}
public
void
setNorth
(
)
{
dir
=
dns-remplacer
;
}
...
}
-
être
possible
de
associer
à
constante
énumérer
valeur
de
type
quelconque
-
être
possible
de
utiliser
type
énumérer
dans
instruction
switch
classe
imbriquer
(
Nested
classe
)
concept
être
vital
pour
débutant
.
classe
pouvoir
être
définir
à
intérieur
de
autre
classe
.
parler
de
classe
imbriqué
.
distinguer
quatre
catégorie
:
-
classe
membrer
déclarer
static
(
static
nested
classe
)
:
membre
statique
de
classe
englobant
;
-
classe
interne
(
inner
classe
)
:
membre
statique
de
classe
englobant
;
-
classe
local
(
local
classe
)
:
classe
définir
à
intérieur
de
méthode
;
-
classe
anonyme
(
anonymous
classe
)
:
classe
local
sans
nom
.
exemple
:
public
class
OuterClass
{
...
public
static
class
StaticNestedClass
{
...
}
private
class
InnerClass
{
...
}
}
/
/
exemple
de
référence
à
classe
StaticNestedClass
:
/
/
dns-remplacer
intérêt
peut-il
avoir
à
déclarer
classe
imbriqué
?
regroupement
logique
,
encapsulation
accroître|accroire
,
code
lisible
maintenable
.
en
pratique
,
plupart
classe
imbriqué
être
classe
interne
.
quant
classe
anonyme
,
pouvoir
rendre
code
difficile
à
lire
devoir
être
limiter
à
classe
petit
(
de
un
deux
méthode
)
:
voir
exemple
typique
en
section
.
contrôle
de
accès
par
modificateur
contrôle
de
accès
à
membre
de
classe
pouvoir
être
préciser
dans
déclaration
par
mots-clé
appeler
modificateur
.
modificateur
permettre
de
spécifier
:
-
visibilité
champ
de
méthode
:
private
,
protected
public
-
lieu
de
stockage
:
dans
classe
(
modificateur
static
)
dans
objet
(
par
défaut
)
-
caractère
modifiable
(
par
défaut
)
(
modificateur
final
)
modificateur
*
commentaire
exemple
private
membre
déclarer
private
être
accessible
qu
'
à
intérieur
de
classe
de
définition
.
modificateur
de
accès
recommander
pour
champ
.
protected
membre
déclarer
protected
être
accessible
depuis
classe
de
déclaration
,
sous-classe
,
classe
même
paquetage
.
modificateur
de
accès
recommander
pour
méthode
super-
classe
.
public
membre
déclarer
public
être
accessible
depuis
importer
classe
.
modificateur
de
accès
recommander
pour
méthode
static
champ
déclarer
static
être
variable
de
classe
être
dupliquer
dans
différent
instance
;
champ
static
être
variable
de
instance
être
dupliquer
dans
instance
.
méthode
déclarer
static
être
méthode
de
classe
être
invoquer
sans
référence
à
objet
particulier
en
faire
référence
à
classe
;
méthode
static
être
méthode
de
instance
être
invoquer
sur
objet
particulier
voir
chapitrer
final
variable
déclarer
final
pouvoir
être
modifier
après
avoir
être
initialiser
.
permettre
en
particulier
de
déclarer
champ
constant
.
exemple
:
final
int
SIZE
=
;
méthode
déclarer
final
pouvoir
être
redéfinir
dans
sous-classe
.
classe
déclarer
final
pouvoir
être
sous-classer
.
*
nota
:
à
défaut
de
modificateur
private
,
protected
public
,
visibilité
être
dire
'
'
package
access
`
`
:
membre
de
classe
être
visible
depuis
classe
même
paquetage
.
exemple
:
public
static
final
double
GRAVITY
=
;
instance
de
classe
avant
de
pouvoir
être
utiliser
,
objet
-
instance
de
classe
-
devoir
être
:
)
déclarer
ClassName
objectName
;
)
créer
initialiser
objectName
=
new
constructorCall
;
exemple
:
GregorianCalendar
cal
;
cal
=
GregorianCalendar
(
)
;
Timer
myTimer
=
new
Timer
(
)
;
déclaration
de
objet
créer
objet
variable
pointeur
destiner
à
mémoriser
adresse
futur
de
objet
!
création
de
objet
en
même
(
i.e.
.
instance
dit
)
être
réaliser
par
opérateur
new
.
appel
constructeur
suivre
opérateur
new
avoir
pour
rôle
de
initialiser
objet
créer
.
in
fine
,
adresse
de
objet
créer
initialiser
,
adresse
renvoyer
par
opérateur
new
,
être
stocker
,
grâce
à
opérateur
de
affectation
=
,
dans
variable
déclarer
.
précision
important
:
*
déclaration
.
déclaration
ClassName
objectName
;
créer
variable
de
nom
objectName
de
type
référence
(
i.e.
.
pointeur
)
initialiser
à
null
.
null
être
constant
littéral
prédéfinie
de
java
pouvoir
être
assigner
à
variable
de
type
référence
identifier
pointeur
nul
.
variable
de
valeur
null
poindre
vers
objet
.
tentative
de
référer
à
objet
à
partir
de
pointeur
null
engendrer
erreur
(
de
compilation
de
exécution
selon
contexte
)
.
*
gestion
dynamique
de
mémoire
.
opérateur
new
créer
instance
de
classe
dans
zone
mémoire
général
appeler
`
`
tas
`
`
contenir
donnée
allouer
à
exécution
avoir
de
portée
local
.
objet
créer
conserver
portée
global
rester
`
`
vivant
`
`
disposer
de
référence
(
i.e.
.
pointeur
)
permettre
d
'
accéder
.
objet
être
référencer
,
devenir
inaccessible
'
'
mourir
`
`
:
espace
mémoire
être
désallouer
(
récupération
automatique
de
espace
mémoire
être
réaliser
par
processus
appeler
ramasse-miettes
(
garbage
collector
)
)
.
façon
de
détruire
objet
être
de
assigner
valeur
null
variable
faire
référence
.
type
de
DONNEES
java
connaître
deux
type
de
donnée
:
-
type
primitif
.
donnée
de
type
primitif
être
stocker
dans
variable
avoir
sémantique
de
valeur
(
i.e.
.
être
valeur
être
copier
variable
être
affecter
à
autre
variable
)
.
-
type
objet
(
type
référence
)
.
donnée
de
type
objet
être
stocker
sous
forme
de
référence
à
objet
(
en
objet
même
)
.
variable
de
type
objet
être
affecter
à
autre
variable
,
seul
référence
être
copier
,
objet
même
.
java
utiliser
système
Unicode-4
,
en
interne
,
pour
coder
caractère
,
chaîne
de
caractère
identificateurs
.
caractère
Unicode
être
coder
sur
bit
,
permettre
de
représenter
de
nombreux
alphabet
(
grec
,
cyrillique
,
hébreu
,
arabe
,
...
)
symbole
mathématique
technique
.
Unicode
être
utiliser
par
système
de
exploitation
(
Windows
NT
Vista
par
exemple
)
,
plupart
système
de
exploitation
utiliser
système
de
codage
bit
,
de
sorte
transcodage
être
nécessaire
problème
de
incompatibilité
pouvoir
survenir
à
affichage
.
type
primitif
typer
description
exemple
de
littéral
nombre
entier
:
type
signé
:
byte
octet
(
entier
bit
)
short
entier
court
(
bit
)
int
entier
(
bit
)
long
entier
long
(
bit
)
5123456789L
-55L
nombre
réel
:
type
signer
:
float
réel
simple
précision
43.889F
341.159E-2F
double
réel
double
précision
-2.4E107
autre
type
:
type
signer
:
char
caractère
(
seul
;
bit
)
'
?
'
'
\u00F6
'
boolean
valeur
booléen
false
true
+
nombre
sans
point
décimal
être
interpréter
entier
de
type
int
convertir
en
byte
,
short
de
affection
.
pouvoir
déclarer
littéral
de
type
long
en
affecter
suffixe
L
.
+
nombre
avec
point
décimal
être
interpréter
réel
de
type
double
.
pouvoir
déclarer
littéral
de
type
float
en
affecter
suffixe
F
.
+
caractère
littéral
pouvoir
être
écrire
sous
forme
de
unique
caractère
Unicode
entre
apostrophe
de
valeur
Unicode
précéder
par
'
\u
'
.
+
deux
littéral
booléen
être
true
false
.
+
variable
de
type
primitif
référer
à
objet
,
avoir
de
méthode
associer
.
type
objet
(
type
référence
)
type
autre
type
primitif
être
type
objet
.
inclure
classe
(
abstraire
)
bibliothèque
standard
java
(
type
string
,
par
exemple
)
classe
définir
par
utilisateur
.
variable
de
type
objet
contenir
référence
(
pointeur
)
sur
objet
.
affectation
passage
de
paramètre
avoir
sémantique
de
référence
(
i.e.
.
être
référence
être
copier
objet
même
)
.
après
affectation
de
variable
à
autre
,
deux
variable
référer
même
objet
:
agir
de
copie
de
surface
(
par
opposition
à
copie
profond
dupliquer
objet
)
.
deux
variable
être
dire
pour
même
objet
.
classe
envelopper
classe
enveloppe
permettre
de
transformer
type
simple
en
objet
(
opération
être
appeler
,
en
anglais
,
boxing
)
.
classe
envelopper
type
primitif
Boolean
boolean
Byte
byte
Character
char
double
double
Float
float
Integer
int
long
short
short
exemple
:
/
/
convert
primitif
type
>
wrapper
type
Integer
k
=
new
Integer
(
)
;
/
/
convert
wrapper
type
>
primitif
type
double
x
=
K.doubleValue
(
)
;
classe
enveloppe
être
utile
méthode
accepter
type
simple
requérir
objet
.
,
depuis
plate-forme
(
voir
chapitre
)
,
valeur
de
type
primitif
être
,
en
cas
de
besoin
,
convertir
en
objet
de
classe
envelopper
correspondant
(
autoboxing
)
,
(
unboxing
)
.
,
conversion
devoir
être
explicite
.
objet
de
classe
être
immuable
(
immutable
)
,
modifiable
fois
créer
.
en
conséquence
,
méthode
pouvoir
avoir
de
paramètre
de
sortie
de
type
.
classe
enveloppe
présenter
intérêt
de
offrir
méthode
de
conversion
typer
primitif
<
-
>
string
,
utilitaire
donnée
de
type
primitif
.
exemple
:
/
/
Convert
string
type
-
>
primitif
type
double
x
=
dns-remplacer
(
`
`
`
`
)
;
chaîne
de
caractère
modifiable
(
string
)
chaîne
de
caractère
de
type
string
être
objet
,
être
nécessaire
de
avoir
recours
à
opérateur
new
pour
créer
.
caractère
de
chaîne
de
caractère
chaine
être
indicer
de
à
dns-remplacé
(
)
chaîne
de
caractère
littéral
être
noter
entre
apostrophe
.
opérateur
+
être
opérateur
de
concaténation
de
chaîne
.
produire
nouveau
chaîne
sans
élément
partager
avec
opérande
.
comparaison
de
deux
chaîne
(
caractère
par
caractère
)
nécessiter
de
faire
appel
à
fonction
equals
(
)
,
opérateur
=
=
donner
résultat
attendre
dans
cas
particulier
.
objet
de
type
string
être
immuable
(
immutable
)
,
modifiable
fois
créer
.
en
conséquence
,
méthode
pouvoir
avoir
de
paramètre
de
sortie
de
type
string
.
classe
string
appartenir
paquetage
dns-remplacé
exemple
:
string
chaine
=
`
`
exemple
n
°
'
'
+
+
`
`
de
chaine
littéral
'
'
;
dns-remplacer
(
`
`
longueur
de
\
'
'
'
'
+
chainer
+
`
`
\
'
'
=
'
'
+
dns-remplacer
(
)
)
;
chaîne
de
caractère
modifiable
(
StringBuffer
)
chaîne
de
caractère
,
chaîne
de
type
string
,
pouvoir
être
modifier
.
opérateur
new
être
indispensable
pour
créer
chaîne
de
type
StringBuffer
.
classe
StringBuffer
appartenir
paquetage
dns-remplacé
exemple
:
StringBuffer
chaine
;
chaine
=
new
StringBuffer
(
`
`
meeting
at
pm
!
'
'
)
;
dns-remplacer
(
,
'
'
)
;
/
/
meeting
at
and
not
!
dns-remplacer
(
chaine
)
;
tableau
tableau
être
collection
de
taille
fixe
de
élément
de
même
type
.
élément
être
repérer
par
indice
permettre
accès
direct
à
élément
.
à
tableau
être
associer
classe
dériver
de
Object
partager
par
tableau
avoir
même
type
de
élément
.
attribut
de
instance
length
(
être
champ
public
méthode
)
contenir
nombre
de
élément
tableau
.
élément
de
tableau
array
être
indicer
de
à
dns-remplacé
-
tenter
de
accéder
à
élément
indice
être
hors
de
plage
permettre
,
exception
de
type
IndexOutOfBoundsException
être
lever
.
être
à
noter
tableau
de
caractère
être
objet
de
type
Siring
.
syntaxe
(
pour
cas
de
tableau
mono-dimensionnel
)
:
/
/
Declaring
an
array
variable
TypeOfElements
[
]
arrayVariable
;
/
/
Creating
an
array
object
arrayVariable
=
new
TypeOfElements
[
numberOfElements
]
;
/
/
Referring
to
an
element
arrayVariable
[
integerIndex
]
exemple
:
/
/
Declaring
an
array
variable
private
double
[
]
mark
;
/
/
Creating
an
array
object
static
final
int
NB_OF_STUDENTS
=
;
mark
=
new
double
[
NB_OF_STUDENTS
]
;
/
/
Using
an
array
object
for
(
int
=
;
<
dns-remplacer
;
i++
)
{
mark
[
i
]
=
dns-remplacer
(
)
*
;
dns-remplacer
(
`
`
mark
[
`
`
+
+
`
`
]
=
`
`
+
mark
[
i
]
)
;
}
exemple
:
static
final
int
NROW
;
static
final
int
NCOL
=
;
string
[
]
[
]
matrix
=
new
string
[
NROW
]
[
NCOL
]
;
être
possible
de
créer
de
initialiser
tableau
à
déclaration
.
exemple
:
int
[
]
t
=
{
,
,
,
}
;
dns-remplacer
(
t
[
]
+
`
`
`
`
+
t
[
]
)
;
/
/
string
[
]
[
]
s
=
{
{
`
`
monsieur
.
`
`
,
`
`
Mrs
.
`
`
,
`
`
Ms
.
`
`
}
,
/
/
row
{
`
`
Smith
'
'
,
`
`
Jones
'
'
}
/
/
row
}
;
dns-remplacer
(
s
[
]
[
]
+
s
[
]
[
]
)
;
/
/
Ms
.
Jones
classe
dns-remplacé
offrir
divers
méthode
utilitaire
applicable
à
tableau
(
comparaison
,
tri
,
...
...
)
.
depuis
plate-forme
(
voir
chapitre
)
,
java
offrir
boucle
for
simplifier
pour
parcourir
élément
de
tableau
.
exemple
:
/
/
for
each
element
of
my
array
of
double
,
print
this
element
for
(
double
e
:
myArrayOfDoubles
)
{
dns-remplacer
(
e
)
;
}
collection
collection
être
objet
représenter
groupe
de
objet
.
collection
être
agrégat
regrouper
élément
multiple
en
seul
entité
.
hypothèse
être
faire
avoir
sur
type
élément
,
sur
ordre
élément
,
sur
possibilité
de
élément
dupliquer
.
,
en
java
,
collection
de
élément
de
type
E
être
classe
implémente
interface
collection
<
E
>
.
paquetage
standard
dns-remplacé
offrir
variété
de
collection
(
collection
framework
)
répondre
besoin
fréquent
,
par
exemple
:
ArrayList
<
E
>
,
Vector
<
E
>
,
LinkedList
<
E
>
,
Stack
<
E
>
,
Hashtable
<
K
,
V
>
,
...
.
ip-remplacée
>
Généricité
notion
exister
en
java
depuis
plate-forme
(
voir
chapitre
)
.
version
introduire
révision
majeur
par
rapport
à
précédent
,
en
matière
de
gestion
collection
.
apparition
de
type
générique
être
évolution
marquant
.
généricité
permettre
de
communiquer
compilateur
type
élément
de
collection
moment
de
création
de
objet
en
fixer
avoir
dans
définition
de
classe
.
exemple
de
classe
générique
:
/
/
Defining
avoir
generic
collection
.
/
/
The
formal
parameter
T
is
the
generic
type
of
the
elements
.
public
class
MyCollection
<
T
>
implements
List
<
T
>
{
...
/
/
T
can
be
used
here
avoir
any
type
...
}
/
/
Creating
avoir
collection
of
Integers
MyCollection
<
Integer
>
collectionOfIntegers
;
CollectionOfIntegers
=
new
MyCollection
<
Integer
>
(
)
;
/
/
Creating
avoir
collection
of
string
MyCollection
<
string
>
collectionOfString
;
CollectionOfStrings
=
new
MyCollection
<
string
>
(
)
;
déclaration
de
type
pouvoir
être
générique
,
déclaration
de
méthode
pouvoir
être
générique
,
paramétrisées
par
un
paramètre
.
exemple
de
méthode
générique
:
/
/
Defining
public
static
<
T
>
void
fromArrayToCollection
(
T
[
]
avoir
,
collection
<
T
>
c
)
{
for
(
T
o
:
avoir
)
{
c.add
(
o
)
;
}
}
/
/
Using
it
string
[
]
a1
=
{
`
`
datal
'
'
,
`
`
data2
'
'
,
`
`
data3
'
'
,
`
`
data4
'
'
,
`
`
data5
'
'
}
;
collection
<
Object
>
c1
=
new
ArrayList
<
string
>
(
)
;
fromArrayToCollection
(
a1
,
c1
)
;
nota
.
être
à
signaler
tableau
générique
faire
bon
ménage
!
exemple
:
Vector
<
Integer
>
[
]
sheets
=
new
Vector
<
Integer
>
[
NBOFSHEETS
]
;
produire
erreur
classique
`
`
Generic
array
creation
'
'
.
dans
exemple
,
solution
pouvoir
consister
à
passer
par
classe
intermédiaire
définir
par
:
VectorOfIntegers
extends
Vector
<
Integer
>
{
}
type
?
être
appeler
type
joker
(
wildcard
type
)
.
permettre
de
représenter
type
.
exemple
:
public
void
printAll
(
collection
<
?
>
c
)
{
for
(
Object
o
:
c
)
{
dns-remplacer
(
o
)
;
}
}
être
possible
de
borner
type
joker
.
caractère
joker
avec
borne
supérieur
être
spécifier
:
<
?
extends
type
>
représenter
sous-type
de
type
.
caractère
joker
avec
borne
inférieur
être
spécifier
:
<
?
super
type
>
représenter
type
être
super-type
de
type
.
ip-remplacée
>
exemple
de
collection
:
ArrayList
objet
de
type
ArrayList
<
E
>
être
collection
de
taille
variable
de
élément
de
type
E
.
élément
être
repérer
par
indice
permettre
accès
direct
à
élément
.
liste-tableau
supporter
principal
fonctionnalité
suivant
:
-
ajout
de
élément
en
fin
de
tableau
(
méthode
add
(
E
)
)
-
accès
à
élément
de
indice
donner
(
méthode
get
(
int
)
add
(
int
,
E
)
)
-
suppression
de
élément
de
indice
donner
(
méthode
remove
(
int
)
)
-
consultation
nombre
de
élément
(
méthode
size
(
)
)
élément
de
objet
collection
de
type
ArrayList
<
E
>
être
indicer
de
à
dns-remplacé
(
)
-
classe
ArrayList
<
E
>
devoir
être
importer
paquetage
dns-remplacer
par
:
import
dns-remplacer
;
exemple
:
ArrayList
<
Integer
>
myCollectionOfIntegers
;
myCollectionOfIntegers
=
new
ArrayList
<
Integer
>
(
)
;
for
(
int
=
;
<
;
i++
)
{
dns-remplacer
(
i
,
)
;
}
ip-remplacée
>
parcours
de
collection
--
Itérateur
parcours
de
collection
être
opération
consister
à
explorer
collection
élément
par
élément
.
deux
façon
de
faire
pour
parcourir
collection
:
-
utiliser
itérateur
.
itérateur
être
objet
de
type
Iterator
<
E
>
.
trois
fonctionnalité
utile
pour
créer
gérer
itérateur
être
méthode
:
iterator
(
)
(
de
classe
collection
)
,
hasNext
(
)
next
(
)
(
de
classe
Iterator
)
.
à
noter
suppression
de
élément
de
collection
en
cours|cour
de
parcours
relever
de
méthode
remove
(
)
de
itérateur
de
de
collection
.
classe
Iterator
<
E
>
devoir
être
importer
paquetage
dns-remplacer
par
:
import
dns-remplacé
;
itérateurs
être
façon
de
faire
historique
pour
parcourir
collection
.
depuis
version
être
générique
.
-
utiliser
boucle
for
généraliser
.
boucle
permettre
de
affranchir
itérateurs
de
parcourir
collection
quelconque
.
être
offrir
depuis
version
.
exemple
de
parcours
avec
itérateur
:
Iterator
<
Integer
>
it
=
dns-remplacer
(
)
;
while
(
dns-remplacer
(
)
)
{
/
/
call
dns-remplacé
(
)
to
get
the
next
object
of
the
collection
/
/
and
do
something
with
that
object
}
exemple
de
parcours
sans
itérateur
:
/
/
for
each
element
of
my
collection
of
Integers
,
print
it
for
(
Integer
v
:
myCollectionOfIntegers
)
{
dns-remplacer
(
v
)
;
}
Transtypage
transtypage
(
en
anglais
:
cast
/
casting
)
être
opération
consister
à
convertir
type
de
expression
.
conversion
de
type
réaliser
en
faire
précéder
expression
par
type
cibler
entre
parenthèse
.
proposition
appliquer
à
type
primitif
type
objet
lier
par
relation
de
héritage
.
conversion
incorrect
provoquer
erreur
à
compilation
à
exécution
.
à
noter
transtypage
changer
type
variable
concerner
(
type
de
variable
être
définir
fois
pour
dès
création
)
:
opération
de
transtypage
être
changement
de
point
de
vue
demander
compilateur
.
syntaxe
:
(
newType
)
expression
exemple
:
int
n
=
;
char
c
=
(
char
)
(
n
/
)
;
classe
offrir
méthode
spécifique
adéquat
,
:
°
pour
conversion
réel
-
>
entier
:
-
méthode
math
.
round
(
realValue
)
permettre
de
convertir
réel
en
entier
proche
-
méthode
dns-remplacer
(
realValue
)
associer
à
conversion
en
entier
fournir
grand
entier
inférieur
égal
à
argument
.
exemple
:
(
int
)
dns-remplacer
(
)
valoir
-
méthode
dns-remplacer
(
realValue
)
associer
à
conversion
en
entier
fournir
petit
entier
supérieur
égal
à
argument
.
exemple
:
(
int
)
dns-remplacer
(
)
valoir
°
pour
conversion
en
à
partir
de
string
:
-
méthode
toString
(
)
,
hériter
objet
,
permettre
de
convertir
objet
en
string
-
méthode
valueOf
(
primitiveTypeExpression
)
,
de
classe
string
,
renvoyer
représentation
string
de
valeur
de
argument
-
méthode
valueOf
(
string
)
,
disposer
classe
envelopper
,
renvoyer
instance
de
classe
envelopper
contenir
valeur
représenter
par
argument
de
type
string
exemple
:
/
/
Convert
string
type
-
>
primitif
type
double
x
=
dns-remplacer
(
`
`
'
'
)
;
/
/
Convert
string
type
-
>
wrapped
typer
double
pi
=
dns-remplacer
(
`
`
'
'
)
;
/
/
Convert
wrapped
type
-
>
primitif
type
int
k
=
dns-remplacer
(
`
`
'
'
)
.intValue
(
)
;
/
/
Convert
primitif
type
-
>
string
typer
string
piStr
=
dns-remplacer
(
)
;
/
/
Convert
primitif
type
-
>
string
typer
double
pi
=
new
double
(
)
;
string
s
=
dns-remplacer
(
)
;
Autoboxing
/
unboxing
.
depuis
plate-forme
(
voir
chapitre
)
,
valeur
de
type
primitif
être
,
en
cas
de
besoin
,
convertir
en
objet
de
classe
envelopper
correspondant
(
autoboxing
)
,
(
unboxing
)
.
,
conversion
devoir
être
explicite
.
OPERATEURS
expression
java
posséder
nombre
considérable
de
opérateur
arithmétique
logique
.
expression
être
constituer
de
opérande
de
opérateur
.
opérande
pouvoir
être
de
différent
nature
:
variable
,
constant
,
appel
de
fonction
.
dans
expression
,
opérateur
devoir
être
explicite
.
de
opérateur
apparaître
dans
seul
expression
,
règle
de
précédence
être
utiliser
pour
déterminer
ordre
de
application
.
être
nécessaire
de
altérer
ordre
normal
de
évaluation
,
parenthèse
pouvoir
être
utiliser
.
à
précédences
égal
,
expression
être
évaluer
de
gauche
à
droit|droite
.
recommandation
de
style
:
+
utiliser
parenthèse
pour
isoler
sous-expression
de
éviter
problème
de
précédence
de
opérateur
rendre
code
lisible
pour
programmeur
.
+
insérer
espace
avant
après
opérateur
autre
point
opérateur
expression
arithmétique
opérateur
arithmétique
binaire
opérateur
fonction
champ
de
application
/
division
réel
réel
/
division
entier
entier
#
modulo
(
rester
de
division
entier
)
*
entier
*
noter
.
en
java
dans
plupart
langage
de
programmation
,
à
%
B
être
signe
de
à
(
en
mathématique
reste
de
division
euclidien
être
positif
,
quotient
calculer
en
conséquence
)
.
pour
java
:
avoir
/
B
=
sgn
(
à
)
*
sgn
(
B
)
*
|
à
|
/
|
B
|
;
à
%
B
=
A-
(
à
/
B
)
*
B
%
/
en
java
en
math
*
nota
.
en
java
,
opérateur
modulo
%
pouvoir
être
appliquer
sur
réel
.
résultat
être
reste
obtenir
après
soustraction
de
opérande
droit
à
opérande
gauche
nombre
entier
de
fois
.
,
à
cause
arrondir
de
calcul
,
résultat
être
attendre
(
par
exemple
:
%
donne
)
.
grand
prudence
,
,
avec
opérateur
appliquer
sur
réel
.
opérateur
arithmétique
unaire
opérateur
fonction
champ
de
application
++
incrémentation
entier
réel
--
décrémentation
entier
réel
opérateur
expression
booléen
opérateur
booléen
binaire
opérateur
fonction
&
&
logique
conditionnel
*
|
|
logique
conditionnel
*
^
logique
exclusif
*
avec
opérateur
,
évaluation
de
expression
logique
arrêter
dès
être
possible
de
inférer
valeur
final
de
expression
;
opérande
être
évaluer
.
opérateur
booléen
unaire
opérateur
fonction
!
négation
logique
opérateur
relationnel
opérateur
relationnel
(
de
comparaison
)
opérateur
fonction
=
=
égal
à
!
=
égal
à
<
inférieur
à
<
=
inférieur
égal
à
>
supérieur
à
>
=
supérieur
égal
à
METHODES
définition
appel
de
méthode
ordinaire
définition
de
procédure
définition
de
fonction
public
void
procName
(
formalParams
)
public
fctlype
fctName
(
formalParams
)
{
{
declaration
declaration
statements
statements
}
return
expression
;
}
appel
de
procédure
appel
de
fonction
appel
interne
à
classe
de
définition
:
appel
interne
à
classe
de
définition
:
procName
(
actualParams
)
;
variable
=
fctName
(
actualParams
)
;
appel
externe
à
classe
de
définition
:
appel
externe
à
classe
de
définition
:
-
méthode
de
instance
-
méthode
de
instance
dns-remplacer
(
actualParams
)
;
variable
=
dns-remplacer
(
actualParams
)
;
-
méthode
de
classe
-
méthode
de
classe
dns-remplacer
(
actualParams
)
;
variable
=
ClassName
.
fctName
(
actualParams
)
;
déclaration
de
paramètre
formel
spécification
de
paramètre
effectif
(
formal
parameter
)
(
actual
parameter
)
paramètre
de
entrée
(
type
primitif
objet
)
:
paramètre
de
entrée
(
type
primitif
objet
)
:
parameterType
parameterName
expression
paramètre
de
sortie
de
type
primitif
:
paramètre
de
sortie
de
type
primitif
:
impossible
(
utiliser
fonction
passer
impossible
paramètre
de
type
objet
)
paramètre
de
sortie
de
type
objet
:
paramètre
de
sortie
de
type
objet
:
parameterType
parameterName
objectName
+
paramètre
spécifier
dans
définition
de
méthode
être
appeler
paramètre
formel
;
devoir
être
précéder
de
type
.
paramètre
apparaître
dans
forme
de
appel
être
appeler
paramètre
effectif
.
avoir
paramètre
,
être
séparer
par
virgule
.
+
paramètre
de
type
primitif
être
passer
par
valeur
(
être
copie
de
argument
être
transmettre
à
méthode
,
disposer
de
original
)
.
paramètre
de
type
objet
être
passer
par
référence
(
être
référence
,
i.e.
.
pointeur
,
être
transmettre
à
méthode
,
objet
même
)
.
+
par
défaut
,
méthode
être
méthode
de
instance
:
être
invoquer
sur
instance
de
classe
.
exister
méthode
de
classe
pouvoir
être
invoquer
sans
instance
.
spécifier
méthode
de
classe
en
déclarant
static
+
signature
[
]
de
méthode
être
constituer
de
nom
de
liste
type
paramètre
.
dans
même
classe
,
deux
méthode
pouvoir
avoir
même
signature
;
pouvoir
porter
même
nom
(
appeler
surcharge
)
.
+
dans
méthode
de
instance
constructeur
,
pouvoir
référer
à
objet
courant
(
i.e.
.
objet
méthode
constructeur
être
en
cours|cour
de
appel
)
par
mot
clé
this
.
pouvoir
référer
à
membre
(
champ
méthode
)
de
objet
courir
par
identifier
de
forme
dns-remplacer
constructeur
constructeur
être
méthode
particulier
invocation
être
associer
à
création
de
instance
de
classe
finalité
être
de
initialiser
état
de
objet
de
création
.
définition
de
constructeur
suivre
règle
syntaxique
spécifique
:
nom
de
constructeur
être
nom
de
classe
de
appartenance
;
en-tête
de
définition
spécifier
de
type
.
syntaxe
de
définition
de
constructeur
de
classe
de
nom
ClassName
:
public
ClassName
(
formalParameters
)
{
/
/
...
Fields
initializations
...
}
constructeur
être
utiliser
en
association
avec
opérateur
new
.
exemple
de
syntaxe
de
utilisation
de
constructeur
de
classe
de
nom
ClassName
:
ClassName
object
=
new
ClassName
(
actualParameters
)
;
même
classe
pouvoir
comporter
constructeur
sous
condition
avoir
même
paramètre
.
dans
cas
,
pour
éviter
de
duplication
de
code
,
constructeur
pouvoir
en
appeler
autre
avec
syntaxe
:
this
(
actualParameters
)
.
exemple
:
public
{
private
int
x
,
;
public
pointe
int
x
,
int
)
{
/
/
à
first
constructor
this.x.
=
X
;
this.y.
=
;
}
public
point
(
)
{
/
/
à
second
constructor
this
(
,
)
;
}
/
/
...
}
[
]
à
noter
définition
,
adopter
par
java
,
prendre
en
considération
type
de
méthode
.
en
sens|sen
,
`
`
signature
`
`
correspondre
à
être
appeler
par
`
`
profil
`
`
de
méthode
.
méthode
main
méthode
main
,
en
C
C++
,
être
point
de
entrée
de
application
lancement
de
exécution
.
syntaxe
:
public
static
void
main
(
string
[
]
args
)
{
...
}
argument
args
capter
éventuel
argument
de
ligne
de
commande
,
premier
argument
de
ligne
de
commande
être
stocker
dans
args
[
]
(
dans
args
[
]
en
C
/
C++
)
exemple
:
considérer
application
classe
principal
-
contenir
méthode
main
-
appeler
game
.
supposer
application
dépendre
de
deux
paramètre
valeur
devoir
être
fournir
lancement
.
supposer
fichier
source
game
.
java
avoir
être
compiler
en
fichier
exécutable
dns-remplacer
.
lancement
de
application
par
commande
:
java
game
Daniel
attribuer
à
args
tableau
{
`
`
Daniel
'
'
,
`
`
'
'
}
instruction
sur
plan
syntaxique
,
instruction
(
statements
)
pouvoir
être
regrouper
en
grand
catégorie
:
-
instruction
simple
:
instruction
de
affectation
,
instruction
de
entrée
/
sortie
,
instruction
de
appel
à
procédure
.
instruction
simple
terminer
par
point-virgule
.
point-virgule
seul
définir
instruction
vide
.
-
instruction
de
contrôle
:
instruction
de
sélection
,
instruction
de
boucle
,
instruction
de
rupture
de
séquence
.
-
bloc
de
instruction
.
bloc
de
instruction
-
appeler
instruction
composé
-
être
séquence
de
instruction
enserrer
entre
accolade
.
bloc
{
}
définir
instruction
vide
.
instruction
de
affectation
syntaxe
:
variable
=
expression
;
symbole
=
être
opérateur
de
affectation
.
valeur
de
expression
situer
en
partie
droit
être
affecter
à
variable
spécifier
en
partie
gauche
.
type
de
expression
devoir
apparier
type
de
variable
.
impact
physique
être
différent
selon
expression
être
de
type
primitif
objet
(
voir
chapitre
)
.
instruction
de
contrôle
instruction
de
sélection
ip-remplacée
>
if-else
premier
forme
:
deuxième
forme
:
if
(
expression
)
{
if
(
expression
)
{
statements
statements
}
}
else
{
statements
}
exemple
:
if
(
dns-remplacer
(
)
=
=
)
{
dns-remplacé
(
`
`
The
field
is
empty
.
`
`
)
;
}
exemple
:
if
(
number
<
)
{
reportError
(
)
;
}
else
{
processNumber
(
number
)
;
}
exemple
:
if
(
n
<
)
{
handleNegative
(
)
;
}
else
if
(
n
=
=
)
{
handlezero
(
)
;
}
else
{
handlePositive
(
)
;
}
ip-remplacée
>
switch
premier
forme
:
deuxième
forme
:
switch
(
expression
)
{
switch
(
expression
)
{
case
value1
:
caser
value1
:
statements
;
/
*
falls
through
*
/
break
;
case
value2
:
case
value2
:
/
*
falls
through
*
/
statements
;
case
value3
:
break
;
statements
;
default
:
break
;
statements
;
case
value4
:
break
;
/
*
falls
through
*
/
}
caser
value5
:
statements
;
break
;
default
:
statements
;
break
;
}
+
instruction
switch
pouvoir
avoir
nombre
quelconque
de
label
caser
+
instruction
break
mettre
fin
à
instruction
switch
.
avoir
défaut
de
instruction
break
,
exécution
poursuivre
sur
instruction
label
suivant
.
deuxième
former
ci-
exploiter
comportement
:
trois
premier
valeur
conduire
à
exécution
de
partie
statements
associer
à
value3
;
deux
valeur
suivant
conduire
à
exécution
de
partie
statements
associer
à
value5
;
+
clause
default
être
optionnel
,
recommander
.
à
défaut
,
pouvoir
cas
conduire
à
exécution
.
exemple
:
switch
(
day
)
{
case
:
dayString
=
`
`
Monday
'
'
;
break
;
case
:
dayString
=
`
`
Tuesday
'
'
;
break
;
case
:
dayString
=
`
`
Wednesday
'
'
;
break
;
case
:
dayString
=
`
`
Thursday
'
'
;
break
;
case
:
dayString
=
`
`
Friday
'
'
;
break
;
case
:
dayString
=
`
`
Saturday
'
'
;
break
;
case
:
dayString
=
`
`
Sunday
'
'
;
break
;
default
:
error
(
)
;
break
;
}
exemple
:
switch
(
winterMonth
)
{
case
:
numberOfDays
=
;
break
;
case
:
/
*
falls
through
*
/
case
:
numberOfDays
=
;
break
;
case
:
if
(
isLeapYear
(
)
)
{
numberOfDays
=
;
}
else
{
numberOfDays
=
;
}
break
;
default
:
error
(
)
;
break
;
}
instruction
de
boucle
ip-remplacée
>
while
boucle
while
exécuter
bloc
de
instruction
valeur
de
expression
donner
être
true
.
expression
être
tester
avant
exécution
corps
de
boucle
,
corps
de
boucle
pouvoir
être
exécuter
fois
.
syntaxe
:
while
(
expression
)
{
statements
}
exemple
:
int
i
=
;
while
(
<
dns-remplacer
(
)
)
{
dns-remplacer
(
dns-remplacer
(
)
)
;
i++
;
}
exemple
:
while
(
dns-remplacer
(
)
)
{
processObject
(
dns-remplacer
(
)
;
}
ip-remplacée
>
do-while
boucle
do-while
exécuter
bloc
de
instruction
valeur
de
expression
donner
être
true
.
expression
être
tester
après
exécution
corps
de
boucle
,
corps
de
boucle
être
exécuter
fois
.
syntaxe
:
do
{
statements
}
while
(
expression
)
;
exemple
:
do
{
input
=
readInput
(
)
;
if
(
input
=
=
null
)
{
dns-remplacé
(
`
`
Try
again
'
'
)
;
}
}
while
(
input
=
=
null
)
;
ip-remplacée
>
for
boucle
for
exécuter
condition
évaluer
à
true
.
avant
boucle
démarrer
,
instruction
de
initialisation
être
exécuter
fois
.
condition
être
évaluer
avant
exécution
corps
de
boucle
(
pour
boucle
while
)
.
instruction
de
mise
à
jour
variable
être
exécuter
après
exécution
corps
de
boucle
.
syntaxe
:
for
(
initialization
;
condition
;
update
)
{
statements
}
exemple
:
for
(
int
=
;
<
dns-remplacer
(
)
;
i++
)
{
dns-remplacer
(
dns-remplacer
(
)
)
;
}
ip-remplacée
>
foreach
depuis
plate-forme
(
voir
chapitre
)
,
java
offrir
boucle
for
améliorer
pour
parcourir
élément
de
tableau
de
collection
(
reporter
section
respectif
)
.
syntaxe
:
/
/
for
each
element
of
the
collection
,
process
element
for
(
TypeOfElements
element
:
collectionOfElements
)
{
/
/
...
process
element
...
}
instruction
de
entrée
/
sortie
java
offrir
nombre
considérable
de
fonction
procédure
de
entrée
/
sortir
,
en
mode
texte
graphique
.
limiter
dans
section
principal
instruction
de
entrée
/
sortir
en
mode
texte
;
pour
entrée
/
sortir
en
mode
graphique
,
voir
chapitre
.
méthode
de
entrée
/
sortie
primaire
appartenir
classe
paquetage
java
.
io
.
depuis
plate-forme
(
voir
chapitre
)
,
classe
scanner
paquetage
dns-remplacé
offre
:
-
fonctionnalité
de
base
pour
lire
donnée
depuis
flux
de
entrée
;
-
sortie
formater
en
C
.
en
complément
,
classe
dns-remplacé
permettre
de
spécifier
format
de
entrée
de
sortie
.
notion
de
flux
flux
flot
(
stream
en
anglais
)
généraliser
notion
de
périphérique
de
entrée
/
sortie
.
flux
pouvoir
être
voir
interface
intelligent
unidirectionnel
relier
machine
java
périphérique
,
permettre
,
en
lecture
en
écriture
,
de
affranchir
spécificité
périphérique
concerner
.
réaliser
entrée
/
sortie
consister
à
:
)
créer
flux
type
approprié
(
sauf
exister
,
être
prédéfinir
(
dns-remplacer
,
dns-remplacer
dns-remplacer
)
)
)
lire
écrire
,
selon
cas
,
dans
flux
)
,
dans
cas
de
lecture
,
convertir
donnée
lire
dans
type
cibler
souhaiter
pour
premier
approche
,
limiter
à
flux
à
accès
séquentiel
.
entrée
/
sortie
terminal
solution
suivant
affranchir
erreur
de
saisie
.
pour
gérer
type
de
erreur
,
reporter
chapitre
exception
(
chapitre
)
.
ip-remplacée
>
affichage
écran
syntaxe
de
affichage
écran
en
mode
texte
:
dns-remplacer
(
string
)
;
dns-remplacer
(
string
)
;
dns-remplacer
(
primitiveTypeExpression
)
;
dns-remplacer
(
primitiveTypeExpresstion
)
;
ip-remplacée
>
affichage
formater
depuis
plate-forme
,
java
offrir
méthode
printf
permettre
sortie
formater
en
C
(
voir
classe
dns-remplacer
pour
spécification
format
)
.
exemple
:
dns-remplacer
(
`
`
count
=
`
`
+
count
)
;
dns-remplacer
(
`
`
%
s
%
5d
\n
'
'
,
user
,
total
)
;
fonctionnement
printf
code
de
formatage
:
printf
réclamer
chaîne
de
caractère
en
premier
paramètre
.
chaîne
pouvoir
être
suivre
de
n
variable
,
n
>
.
être
chaîne
,
pouvoir
contenir
code
de
formatage
,
être
imprimer
.
code
de
formatage
commencer
par
caractère
%
.
à
fois
code
de
formatage
être
rencontrer
,
printf
imprimer
variable
suivant
dans
liste
de
paramètre
.
principal
code
de
formatage
commander
affichage
de
valeur
de
type
:
%
c
caractère
%
d
entier
%
e
réel
(
en
notation
avec
exposant
)
%
f
réel
#
s
chaîne
de
caractère
code
de
formatage
pouvoir
inclure
spécification
de
format
champ
de
affichage
.
exemple
de
code
de
formatage
champ
de
affichage
spécifier
pour
paramètre
type
considérer
:
%
6d
champ
de
caractère
%
-6d
champ
de
caractère
avec
justification
à
gauche
%
8.2f
champ
de
caractère
à
droit|droite
de
virgule
ip-remplacer
>
lecture
clavier
exemple
:
scanner
input
=
new
scanner
(
dns-remplacer
)
;
string
s1
=
dns-remplacer
(
)
;
/
/
read
avoir
string
(
avoir
word
)
string
s2
=
dns-remplacer
(
)
;
/
/
read
the
rest
of
the
line
int
n
=
dns-remplacer
(
)
;
/
/
read
an
integer
double
r
=
dns-remplacer
(
)
;
/
/
read
avoir
double
dns-remplacer
(
)
;
entrée
/
sortie
fichier
opérer
sur
fichier
consister
à
:
)
créer
flux
approprier
opération
souhaiter
)
lire
écrire
dans
fichier
)
fermer
fichier
solution
suivant
affranchir
erreur
de
entrée
/
sortie
.
pour
gérer
type
de
erreur
,
reporter
chapitre
exception
(
chapitre
)
.
ip-remplacée
>
Ecriture
fichier
depuis
plate-forme
,
java
offrir
méthode
printf
permettre
sortie
formater
en
C
(
voir
classe
dns-remplacer
pour
spécification
format
)
.
exemple
de
écriture
dans
fichier
texte
:
PrintWriter
=
new
PrintWriter
(
outputFileName
)
;
for
(
int
i
=
;
i
<
;
i++
)
dns-remplacer
(
`
`
%
c
%
d
'
'
,
'
\t
'
,
i
)
;
dns-remplacer
(
)
;
ip-remplacée
>
lecture
fichier
exemple
de
lecture
de
fichier
texte
mot
à
mot
:
scanner
in
=
new
scanner
(
new
file
(
inputFileName
)
)
;
string
s
;
while
(
dns-remplacer
(
)
)
{
s
=
dns-remplacer
(
)
;
/
/
read
avoir
string
(
avoir
word
)
dns-remplacer
(
s
)
;
}
dns-remplacer
(
)
;
ip-remplacée
>
contexte
particulier
Cas1
.
ouverture
en
lecture
de
fichier
texte
stocker
dans
fichier
.jar
exécuter
import
dns-remplacer
;
import
dns-remplacé
;
ClassLoader
cl
=
dns-remplacer
(
)
;
InputStream
is
=
dns-remplacer
(
inputFileName
)
;
scanner
in
=
new
scanner
(
is
)
;
Cas2
.
ouverture
en
lecture
de
fichier
texte
distant
identifier
par
URL
import
dns-remplacer
;
import
dns-remplacé
;
URL
url
=
new
URL
(
`
`
http
:
/
/
dns-remplacer
/
...
/
inputFileName
'
'
)
;
scanner
in
=
new
scanner
(
dns-remplacer
(
)
)
;
nota
.
solution
applicable
depuis
applet
.
en
,
assurer
condition
de
accessibilité
fichier
être
lever
(
de
interdiction
par
pare-feu
local
!
)
Cas3
.
ouverture
de
nouveau
page
html
depuis
applet
(
de
même
répertoire
)
import
dns-remplacer
;
import
dns-remplacé
;
URL
url
=
new
URL
(
getDocumentBase
(
)
,
`
`
dns-remplacer
'
'
)
;
getAppletContext
(
)
.showDocument
(
url
,
`
`
_blank
'
'
)
;
repaint
(
)
;
lecture
de
chaîne
de
caractère
formater
être
fréquent
de
avoir
à
lire
chaîne
de
caractère
connaître
format
,
être
flux
de
entrée
(
terminal
fichier
)
.
depuis
plate-forme
,
classe
scanner
paquetage
dns-remplacer
offrir
fonctionnalité
pratique
.
exemple
de
lecture
de
chaîne
de
caractère
formater
:
string
str
=
`
`
XXX
XXX
yellow
XXX
blue
XXX
'
'
'
'
;
scanner
in
=
new
scanner
(
str
)
.useDelimiter
(
`
`
\\s
*
XXX\\s
*
'
'
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
)
;
/
/
Will
display
:
/
/
/
/
/
/
yellow
/
/
blue
HERITAGE
notion
de
héritage
héritage
être
technique
offrir
de
nombreux
avantage
:
-
éviter
duplication
de
code
-
permettre
réutilisation
de
code
dans
autre
contexte
-
faciliter
maintenance
programme
-
faciliter
extension
de
application
existant
.
héritage
(
inheritance
)
être
relation
`
`
est_un
`
`
(
`
`
a_un
`
`
!
!
!
)
permettre
de
définir
classe
extension
de
autre
.
exemple
:
classe
astre
est_un
est_un
classe
Etoile
classer
planète
étoile
être
astre
;
planète
être
astre
.
classe
Etoile
étendre
classe
astre
=
classe
Etoile
hériter
de
classe
astre
.
super-classe
être
classe
être
étendre
par
de
autre
classe
.
sous-classe
être
classe
étendre
(
hériter
de
)
autre
classe
.
hériter
état
comportement
de
ancêtre
,
pouvoir
redéfinir
.
classe
être
lier
par
relation
de
héritage
former
hiérarchie
de
héritage
.
exemple
de
hiérarchie
de
héritage
:
astre
Etoile
planeter
Exoplanète
planeter
solaire
Pégaside
chtonien
tellurique
habitable
constructeur
de
sous-classe
devoir
invoquer
constructeur
de
super-classe
en
premier
instruction
(
à
défaut
,
java
essayer
de
insérer
appel
automatique
)
.
forme
de
appel
être
suivant
:
super
(
actualParameters
)
;
classe
sans
super-classe
explicite
avoir
Object
super-classe
.
pour
hiérarchie
de
classe
,
type
former
hiérarchie
de
type
.
type
définir
par
définition
de
sous-classe
être
sous-type
type
définir
par
super-classe
.
exemple
:
Etoile
être
sous-type
type
astre
variable
pouvoir
contenir
:
-
objet
type
déclarer
de
variable
-
objet
de
sous-type
de
type
déclarer
exemple
:
astre
al
=
new
astre
(
)
;
/
/
correct
astre
a2
=
new
Etoile
)
;
/
/
correct
(
transtypage
ascendre
)
astre
a3
=
new
Planete
(
)
;
/
/
correct
(
transtypage
ascendre
)
Etoile
el
=
new
astre
(
)
;
/
/
erreur
Etoile
e@card@
=
(
Etoile
)
a2
;
/
/
correct
(
transtypage
descendant
/
/
devoir
être
explicite
)
objet
de
sous-type
utiliser
objet
de
super-type
être
attendre
.
appeler
substitution
.
java
permettre
héritage
multiple
:
sous-classe
pouvoir
hériter
de
seul
super-classe
.
hériter
sous-classe
?
sous-classe
hériter
de
membre
de
super-classe
être
accessible
,
sauf
membre
(
attribut
méthode
)
être
redéfinir
dans
sous-classe
.
sous-classe
hériter
de
super-classe
:
-
membre
déclarer
public
protected
-
membre
déclarer
sans
modificateur
de
accès
,
sous-classe
être
dans
même
paquetage
super-classe
.
sous-classe
hériter
de
super-classe
:
-
membre
être
redéfinir
dans
sous-classe
-
constructeur
.
attention
choix
identificateurs
dans
sous-classe
:
choix
pouvoir
masquer
membre
de
super-classe
!
être
cas
pour
attribut
:
attribut
avoir
même
nom
attribut
de
super-classe
masquer
attribut
de
super-
classe
,
être
de
type
différent
.
redéfinir
méthode
pour
redéfinir
méthode
dans
sous-classe
,
falloir
avoir
même
signature
même
type
de
retour
méthode
de
super-classe
.
méthode
redéfinir
pouvoir
autoriser
accès
large
(
:
méthode
déclarer
protected
dans
super-
classe
pouvoir
être
redéfinir
public
dans
sous-classe
,
private
)
.
exemple
typique
être
méthode
toString
de
classe
Object
:
appliquer
à
objet
,
produire
chaîne
de
caractère
former
nom
de
classe
de
code
de
hachage
,
méthode
pouvoir
être
redéfinir
dans
classe
.
méthode
redéfinir
dans
sous-classe
avoir
besoin
de
ajouter
fonctionnalité
complémentaire
à
de
méthode
de
super-classe
,
être
besoin
de
réécrire
pouvoir
appeler
méthode
de
super-classe
par
:
dns-remplacer
(
actualParameters
)
règle
:
-
méthode
de
instance
pouvoir
redéfinir
méthode
de
classe
,
-
méthode
de
instance
de
sous-classe
avoir
même
signature
type
méthode
de
instance
dans
super-classe
redéfinir
méthode
de
super-classe
:
version
de
méthode
invoquer
sur
instance
de
sous-classe
(
type
dynamique
liaison
dynamique
méthode
de
instance
)
être
de
sous-classe
.
-
méthode
de
classe
de
sous-classe
avoir
même
signature
type
méthode
de
classe
dans
super-classe
masquer
méthode
de
super-classe
:
version
de
méthode
invoquer
dépendre
de
être
appeler
sur
super-classe
sur
sous-classe
(
liaison
statique
méthode
de
classe
)
.
-
sous-classe
pouvoir
redéfinir
méthode
déclarer
final
de
super-classe
-
sous-classe
devoir
redéfinir
méthode
déclarer
abstract
dans
super-classe
,
à
sous-classe
même
déclarer
abstract
.
depuis
plate-forme
(
voir
chapitre
)
:
être
conseiller
de
utiliser
annotation
(
méta-donner
)
@
Override
pour
marquer
méthode
être
supposer
redéfinir
méthode
hériter
de
classe
parent
.
permettre
compilateur
de
signaler
erreur
redéfinition
être
avérer
(
à
cause
par
exemple
de
faute
de
frappe
dans
nom
de
méthode
)
.
en
,
en
signaler
méthode
redéfinir
,
annotation
@
Override
permettre
de
accroître
lisibilité
code
.
covariance
type
de
retour
être
autoriser
:
méthode
de
sous-classe
pouvoir
retourner
objet
type
être
sous-classe
type
retourner
par
méthode
de
même
signature
dans
super-classe
.
caractéristique
supprimer
besoin
de
test
de
conversion
de
type
excessif
.
exemple
:
@
Override
public
string
toString
(
)
{
/
/
...
}
exemple
:
classe
posséder
deux
attribut
x
;
classe
ColoredPoint
hériter
de
point
posséder
attribut
spécifique
color
.
écrire
méthode
equals
sans
duplication
de
code
?
/
*
in
the
*
/
@
Override
public
boolean
equals
(
Object
o
)
{
if
(
o
=
=
null
)
return
false
;
/
/
case
null
if
(
this
=
=
o
)
return
true
;
/
/
reflexivity
if
(
dns-remplacer
(
)
!
=
o.getClass
(
)
)
return
false
;
/
/
symmetry
/
/
Now
,
this
and
o
having
the
same
class
,
comparer
the
fields
p
=
(
point
)
o
;
return
(
this.x.
=
=
p.x.
)
&
&
(
this.y.
=
=
p.y.
)
;
}
/
*
in
the
ColoredPoint
extending
*
/
@
Override
public
boolean
equals
(
Object
o
)
{
/
/
Verify
if
this
and
o
haver
the
same
and
if
their
super
/
/
fields
are
equal
if
(
!
dns-remplacer
(
o
)
)
return
false
;
/
/
Now
comparer
the
specific
fields
ColoredPoint
cp
=
(
ColoredPoint
)
o
;
return
dns-remplacer
(
dns-remplacer
)
;
}
exemple
:
public
class
MotherClass
{
public
void
normal
(
)
{
dns-remplacé
(
`
`
the
normal
method
in
MotherClass
'
'
)
;
}
public
static
void
hide
(
)
{
dns-remplacé
(
`
`
the
hide
method
in
MotherClass
'
'
)
;
}
public
void
override
(
)
{
dns-remplacé
(
`
`
the
override
method
in
MotherClass
'
'
)
;
}
}
/
/
end
MotherClass
public
class
DaughterClass
extends
MotherClass
{
@
Override
public
static
void
hide
(
)
{
dns-remplacé
(
`
`
the
hide
method
in
DaughterClass
'
'
)
;
}
@
Override
public
void
override
(
)
{
dns-remplacé
(
`
`
the
override
method
in
DaughterClass
'
'
)
;
}
public
static
void
main
(
string
[
]
args
)
{
DaughterClass
o@card@
=
new
DaughterClass
(
)
;
MotherClass
o2
o1
;
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
!
!
liaison
statique
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
!
!
Tiaison
dynamique
}
}
/
/
end
DaughterClass
méthode
main
afficher
:
the
normal
method
in
MotherClass
the
normal
method
in
MotherClass
the
hide
method
in
DaugterClass
the
hide
method
in
MotherClass
the
override
method
in
DaugterClass
the
override
method
in
DaugterClass
type
statique
/
dynamique
-
liaison
statique
/
dynamique
section
reprendre
formaliser
un
important
concept
introduire
dans
section
précédent
.
type
statique
/
dynamique
-
Transtypage
type
statique
de
objet
être
type
spécifier
par
déclaration
.
être
type
déclarer
.
être
type
à
compilation
.
type
dynamique
de
objet
être
type
(
i.e.
.
classe
de
appartenance
)
de
objet
instancié
.
être
type
constater
.
être
type
effectif
à
exécution
.
type
dynamique
de
objet
être
type
statique
sous-type
de
type
statique
(
sauf
exception
devoir
transtypage
)
.
exemple
:
être
classe
à
classe
B
sous-classe
de
à
.
considérer
code
suivre
:
avoir
avoir
;
if
(
dns-remplacer
(
)
)
{
avoir
=
new
à
(
)
;
}
else
{
avoir
=
new
B
(
)
;
/
/
transtypage
ascendre
implicite
}
type
statique
de
avoir
être
à
;
type
dynamique
de
avoir
être
à
B
pouvoir
être
constater
condition
avoir
être
évaluer
.
transtypage
(
casting
)
appliquer
à
référence
être
possibilité
de
avoir
vue
spécifique
de
objet
pointé
.
changer
en
type
de
objet
sous-jacent
!
(
garder
long
de
vie
type
avec
avoir
être
créer
)
.
opération
de
transtypage
être
syntaxique
faire
indiquer
compilateur
point
de
vue
depuis
devoir
voir
objet
.
transtypage
vers
sur-type
être
dire
ascendant
.
transtypage
ascendre
être
implicite
.
transtypage
vers
sous-type
être
dire
descendant
.
transtypage
descendre
devoir
être
explicite
.
permettre
de
forcer
compilation
garantir
absence
de
erreur
de
exécution
.
transtypage
être
garantir
correct
respecter
règle
suivant
:
être
T1
T2
deux
type
définir
.
o
objet
de
type
dynamique
T3
.
considérer
déclaration
:
T1
obj
=
(
T2
)
o
;
transtypage
être
garantir
possible
,
à
compilation
qu
'
à
exécution
,
T3
être
sous-type
de
T2
T2
sous-type
de
T1
.
opérateur
instanceof
permettre
de
tester
objet
être
de
type
dynamique
donner
de
sous-type
de
type
donner
.
pouvoir
permettre
vérifier
compatibilité
type
avant
de
opérer
transtypage
.
exemple
:
supposer
définir
:
public
class
Shape2D
{
...
}
public
Circle
extends
Shape2D
{
...
}
public
class
triangle
extends
Shape2D
{
...
}
public
class
date
{
...
}
déclaration
suivant
génèreraient
erreur
pour
incompatibilité
de
type
:
Shape2D
s
=
(
Shape2D
)
(
new
date
(
)
)
;
/
/
erreur
de
compilation
Circle
c
=
new
Shape2D
(
)
;
/
/
erreur
de
compilation
Circle
c
=
(
Circle
)
(
new
Shape2D
(
)
)
;
/
/
erreur
de
exécution
triangle
t
=
new
triangle
(
)
;
Circle
c
=
(
Circle
)
t
;
/
/
erreur
de
exécution
déclaration
suivant
être
sain
:
Shape2D
s
=
new
Circle
(
)
;
Circle
c
=
(
Circle
)
s
;
Shape2D
s
;
if
(
obj
instanceof
Shape2D
)
s
=
(
Shaped2D
)
obj
;
liaison
statique
/
dynamique
considérer
invocation
o.m.
o
être
objet
de
type
statique
T
de
type
dynamique
T
'
,
m
message
(
attribut
méthode
)
envoyer
à
o
.
message
m
exécuter
être
code
être
accessible
depuis
classe
T
,
liaison
de
objet
message
être
dire
statique
(
liaison
à
compilation
)
être
dire
dynamique
(
liaison
à
exécution
)
.
en
java
:
-
liaison
de
objet
avec
variable
de
instance
être
statique
;
-
liaison
de
objet
avec
méthode
être
dynamique
(
sauf
méthode
static
final
)
.
exemple
:
public
class
à
{
public
boolean
m1
(
à
avoir
)
{
return
true
;
}
public
boolean
m2
(
à
avoir
)
{
return
true
;
}
}
public
class
B
extends
à
{
public
boolean
m1
(
à
avoir
)
{
return
false
;
}
public
boolean
m3
(
à
avoir
)
{
return
false
;
}
public
static
void
main
(
string
[
]
args
)
{
à
avoir
=
new
B
(
)
;
dns-remplacer
(
a.m1
(
avoir
)
)
;
dns-remplacer
(
a.m2
(
avoir
)
)
;
/
/
dns-remplacer
(
a.m3
(
avoir
)
)
;
/
/
problème
}
}
méthode
main
afficher
:
false
true
?
type
statique
de
avoir
être
à
,
type
dynamique
B
.
être
m1
de
B
être
exécuter
.
quant
à
méthode
m2
,
être
définir
dans
B
dans
super-classe
à
:
B
hériter
de
m2
m2
être
exécuter
.
dernier
instruction
dns-remplacer
(
a.m3
(
avoir
)
)
provoquer
erreur
à
compilation
.
?
compilateur
connaître
type
statique
(
i.e.
.
type
déclarer
)
:
méthode
m3
être
définir
dans
classe
à
dans
un
de
super-classe
,
compilateur
trouver
définition
de
m3
(
dans
B
)
générer
erreur
.
solution
être
transtypage
descendre
préalable
de
avoir
:
dns-remplacer
(
(
(
B
)
avoir
)
.m3
(
avoir
)
)
.
transtypage
être
correct
à
posséder
,
par
création
,
attribut
de
instance
de
B
.
polymorphisme
même
appel
de
méthode
pouvoir
invoquer
méthode
différent
liaison
être
réaliser
(
i.e.
.
à
exécution
à
compilation
)
,
identification
type
de
objet
associer
à
appel
être
dynamique
.
exemple
de
polymorphisme
de
héritage
:
public
class
Shape
{
public
void
draw
(
)
{
dns-remplacer
(
this
+
`
`
.draw
(
)
;
'
'
)
;
}
}
public
Circle
extends
Shape
{
@
Override
public
string
toString
(
)
{
return
`
`
circle
'
'
;
}
}
public
class
square
extends
Shape
{
@
Override
public
string
toString
(
)
{
return
`
`
square
'
'
;
}
}
public
class
Picture
{
public
static
void
main
(
string
[
]
args
)
{
Vector
<
Shape
>
v
=
new
Vector
<
Shape
>
(
)
;
v.add
(
new
Circle
(
)
)
;
v.add
(
new
square
(
)
)
;
for
(
Shape
s
:
v
)
{
dns-remplacer
(
s.draw
(
)
)
;
/
/
polymorphism
}
méthode
main
afficher
:
dns-remplacer
(
)
;
dns-remplacer
(
)
;
classe
méthode
particulier
classe
déclarer
final
pouvoir
être
sous-classer
.
méthode
déclarer
final
pouvoir
être
redéfinir
dans
sous-classe
.
classe
déclarer
abstract
représenter
concept
abstrait
:
pouvoir
être
instanciée
pouvoir
être
sous-classer
.
méthode
déclarer
abstract
être
méthode
corps
être
spécifier
.
classe
abstrait
pouvoir
contenir
méthode
abstraire
,
classe
contenir
méthode
abstrait
devoir
être
déclarer
abstract
.
sous-classe
implémentir
méthode
abstraire
de
super-classe
,
devoir
être
déclarer
abstract
.
interface
interface
(
sens|sen
langage
java
,
cf
section
)
être
protocole
de
comportement
pouvoir
être
implanter
par
classe
.
interface
être
en
dehors
de
hiérarchie
classe
.
interface
différencier
de
classe
abstraire
par
caractéristique
:
-
méthode
concret
(
par
opposition
à
abstrait
)
pouvoir
être
définir
dans
interface
;
-
classe
pouvoir
implémenter
interface
.
pouvoir
construire
hiérarchie
de
classe
,
pouvoir
construire
hiérarchie
de
interface
.
classe
pouvoir
étendre
seul
super-classe
,
(
de
héritage
multiple
)
,
interface
pouvoir
étendre
super-interface
(
héritage
multiple
possible
)
.
exemple
:
public
interface
List
<
E
>
extends
collection
<
E
>
{
...
}
exemple
:
public
interface
Predator
{
boolean
chasePrey
(
Prey
p
)
;
}
public
interface
Prey
{
boolean
isChasedBy
(
Predator
p
)
;
}
public
interface
Venomous
{
...
}
public
interface
VenomousPredator
extends
Predator
,
Venomous
{
...
}
public
class
pet
{
...
}
public
class
Cat
extends
pet
implements
Predator
{
...
}
public
class
Frog
implements
Predator
,
Prey
{
...
}
exception
exception
être
objet
fournir
information
relatif
à
défaillance
programme
.
exception
être
générer
dans
situation
suivant
:
-
condition
de
exécution
anormal
,
par
exemple
:
tentative
de
division
par
zéro
,
mémoire
insuffisant
,
-
exécution
de
instruction
throw
paquetage
java
.
lang
définir
nombre
de
classe
de
exception
couvrir
cas
courant
.
exception
contrôler
contrôler
exception
être
instance
de
classe
Throwable
un
de
sous-classe
:
Object
Throwable
Error
exception
MyCheckedException
RunTimeException
MyUncheckedException
java
diviser
classe
de
exception
en
deux
catégorie
:
-
exception
contrôler
(
unchecked
)
.
exception
concerner
cas
'
'
imprévu
`
`
,
situation
devoir
avoir
de
défaillance
en
fonctionnement
normal
.
concerner
situation
pouvoir
être
éviter
(
exemple
:
indice
de
tableau
hors
limite
)
.
exception
indiquer
erreur
de
programme
.
avoir
vocation
à
conduire
à
arrêt
immédiat
définitif
programme
.
-
exception
contrôler
(
checked
)
.
exception
concerner
cas
`
`
prévu
`
`
,
situation
programmeur
devoir
attendre
à
opération
pouvoir
échouer
.
concerner
situation
de
défaillance
être
contrôle
programmeur
(
exemple
:
disque
devenir
plein
rendre
impossible
écriture
dans
fichier
)
.
exception
avoir
vocation
à
être
récupérer
pour
permettre
programme
de
poursuivre
.
gestion
de
exception
contrôler
imposer
utilisation
de
clause
throws
de
instruction
de
contrôle
try
.
.
catch
.
exception
contrôler
être
classe
RuntimeException
,
Error
sous-
classe
;
autre
classe
sous-classe
être
exception
contrôler
.
classe
de
exception
standard
hiérarchie
Error
classe
Error
être
super-classe
de
hiérarchie
de
erreur
grave
contrôler
.
hiérarchie
être
réserver
erreur
de
exécution
système
.
exemple
de
sous-
classe
prédéfinie
:
NoSuchMethodError
StackOverFlowError
OutOfMemoryError
IllegalAccessError
hiérarchie
exception
classe
exception
être
super-classe
de
hiérarchie
de
exception
,
exclusion
faire
de
sous-hiérarchie
RuntimeException
,
contrôler
.
exemple
de
sous-classe
de
exception
contrôler
prédéfinie
:
DataFormatException
IOException
EOFException
FileNotFoundException
hiérarchie
RuntimeException
classe
RuntimeException
être
super-classe
de
hiérarchie
de
exception
contrôler
.
exemple
de
sous-classe
prédéfinie
:
ArithmeticException
IllegalArgumentException
NumberFormatException
IllegalStateException
IndexOutOfBoundsException
NullPointerException
lancement
de
exception
instruction
throw
permettre
de
lancer
exception
.
être
recommander
de
appliquer
qu
'
à
exception
contrôler
.
syntaxe
:
throw
new
ClassOfException
(
`
`
diagnostic
message
to
print
'
'
)
;
exemple
:
if
(
key
=
=
null
)
{
throw
new
NullPointerException
(
`
`
null
key
found
in
method
x
'
'
)
;
}
exemple
:
if
(
key
=
=
)
{
throw
new
IllegalArgumentException
(
`
`
empty
key
received
'
'
)
;
}
exemple
(
dans
constructeur
)
:
if
(
dns-remplacer
(
)
=
=
)
{
throw
new
IllegalStateException
(
`
`
name
must
be
provided
-
`
`
+
`
`
object
creation
aborted
'
'
)
;
}
exemple
.
opération
remove
(
)
de
interface
Iterator
être
spécifier
optionnel
,
implémentation
pouvoir
être
dans
cas
:
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
capture
de
exception
capture
de
exception
être
obligatoire
pour
exception
vouloir
contrôler
.
dans
cas
exception
contrôler
,
compilateur
renforcer
contrôle
à
fois
dans
méthode
lancer
exception
dans
appelant
de
méthode
.
clause
throws
clause
throws
être
déclaration
ajouter
à
en-tête
de
méthode
susceptible
de
lever
exception
contrôler
.
déclarer
exception
contrôler
à
prendre
en
compte
dans
cadre
de
méthode
.
être
nécessaire
compilateur
pouvoir
savoir
excepter
contrôler
.
par
convention
,
exception
contrôler
devoir
être
inclus
dans
clause
throws
.
syntaxe
:
throws
ExceptionClass1
,
ExceptionClass2
,
...
exemple
:
public
void
saveToFile
(
string
filename
)
throws
IOException
{
...
}
instruction
try
.
.
catch
instruction
try
.
.
catch
permettre
de
capturer
exception
générer
par
appel
de
méthode
.
exception
être
générer
,
contrôle
être
transférer
code
avoir
générer
exception
à
clause
catch
avoir
capturer
exception
.
clause
catch
devoir
avoir
seul
paramètre
formel
.
type
de
paramètre
devoir
être
classe
Throwable
un
de
sous-classe
.
instruction
try
pouvoir
contenir
bloc
catch
.
dans
cas
,
exception
général
devoir
être
traiter
en
dernier
.
syntaxe
:
try
{
/
/
protect
one
more
statement
here
}
catch
(
ExceptionClass
e
)
{
/
/
report
and
recover
from
the
exception
here
}
finally
{
/
/
in
fine
,
in
any
case
,
always
execute
these
statements
}
bloc
finally
être
optionnel
,
permettre
de
éviter
duplication
de
code
.
exemple
(
à
partir
de
plate-forme
)
:
/
/
Read
avoir
double
from
the
standard
input
stream
scanner
input
=
new
scanner
(
dns-remplacer
)
;
double
x
;
try
{
x
=
dns-remplacer
(
)
;
}
catch
(
InputMismatchException
e
)
{
dns-remplacé
(
`
`
Error
-
double
waited
-
`
`
+
e
)
;
}
dns-remplacer
(
)
;
exemple
(
à
partir
de
plate-forme
)
:
/
/
Create
avoir
copy
of
avoir
text
filer
scanner
in
=
null
;
PrintWriter
=
null
;
try
{
in
=
new
scanner
(
new
file
(
inputFileName
)
)
;
=
new
PrintWriter
(
outputFileName
)
;
while
(
dns-remplacer
(
)
)
{
dns-remplacer
(
dns-remplacer
(
)
)
;
}
}
catch
(
exception
e
)
{
dns-remplacé
(
`
`
Error
in
reading
/
writing
file
-
`
`
+
e
)
;
}
finally
{
if
(
in
!
=
null
)
dns-remplacer
(
)
)
;
if
(
out
!
=
null
)
dns-remplacer
(
)
;
}
exemple
(
à
partir
de
plate-forme
)
:
/
/
Read
and
print
avoir
text
file
of
double
scanner
in
=
null
;
try
{
in
=
new
scanner
(
new
file
(
inputFileName
)
)
;
while
(
dns-remplacer
(
)
)
{
dns-remplacer
(
dns-remplacer
(
dns-remplacer
(
)
)
)
;
}
}
catch
(
FileNotFoundException
e
)
{
dns-remplacé
(
`
`
Unable
to
open
the
input
file
.
'
'
+
e
)
;
}
catch
(
NumberFormatException
e
)
{
dns-remplacé
(
`
`
à
token
is
not
avoir
double
.
'
'
+
e
)
;
}
catch
(
exception
e
)
'
dns-remplacer
(
`
`
Problem
in
reading
the
filer
`
`
+
e
)
;
}
finally
{
if
(
in
!
=
null
)
{
try
{
dns-remplacer
(
)
;
}
catch
(
exception
e
)
{
dns-remplacé
(
`
`
Error
in
closing
the
file
.
'
'
+
e
)
;
}
}
définir
nouveau
classe
de
exception
un
principal
raison
conduire
à
définition
de
nouveau
classe
de
exception
être
besoin
de
inclure
information
complémentaire
dans
objet
exception
de
permettre
diagnostic
récupération
de
erreur
.
nouveau
classe
de
exception
être
définir
sous-classe
de
classe
de
exception
existant
de
hiérarchie
exception
.
exemple
:
public
class
WrongValueException
extends
exception
{
private
string
key
;
public
WrongValueException
(
string
key
)
{
dns-remplacer
=
key
;
}
public
string
getKey
(
)
{
return
key
;
}
public
string
toString
(
)
{
return
`
`
Wrong
valoir
`
`
+
key
+
`
`
found
'
'
;
}
}
annexe
-
programmation
graphique
référence
:
base
de
swing
exemple
de
programmation
de
interface
graphique
:
dns-remplacer
/
doc
/
books
/
tutorial
/
uiswing
/
mini
/
dns-remplacé
gestion
événement
exemple
de
programmation
:
dns-remplacer
/
doc
/
books
/
tutorial
/
uiswing
/
event
/
dns-remplacer
swing
architecturer
Overview
dns-remplacer
/
products
/
jfc
/
isc
/
article
/
architecturer
chapitre
introduire
à
programmation
graphique
avec
bibliothèque
dns-remplacer
swing
exister
deux
grand
paquetage
de
utilitaire
java
pour
réaliser
interface
graphique
:
-
AWT
(
abstract
Window
Toolkit
)
:
paquetage
primitif
.
composant
de
paquetage
importer
par
:
import
dns-remplacé
.
*
;
-
swing
:
récent
évoluer
,
construire
sur
AWT
,
être
paquetage
recommander
.
composant
de
paquetage
importer
par
:
import
dns-remplacé
.
*
;
deux
paquetage
swing
utiliser
être
:
dns-remplacer
dns-remplacer
classe
de
dns-remplacé
courant
être
:
JFrame
JPanel
JLabel
JTextField
JButton
JOPtionPane
exemple
de
saisie
/
affichage
dans
boîte
de
dialogue
:
/
/
import
dns-remplacé
;
/
/
user
method
showInputDialog
to
prompt
for
some
input
string
inputValue
=
dns-remplacer
(
`
`
valoir
?
`
`
)
;
/
/
user
method
showMessageDialog
to
display
avoir
message
dns-remplacé
(
null
,
'
'
à
message
...
'
'
)
conteneur
composant
objet
graphique
être
composer
de
différent
objet
:
conteneur
(
container
)
composant
atomique
,
différent
constituant
être
organiser
en
hiérarchie
de
inclusion
.
principal
catégorie
de
conteneur
composant
:
+
conteneur
de
haut
niveau
objet
graphique
pouvoir
être
afficher
à
écran
,
hiérarchie
de
constituant
devoir
avoir
pour
racine
un
trois
conteneur
suivant
:
>
Frame
(
classe
JFrame
)
:
conteneur
général
,
fournir
fenêtre
principal
dans
autre
composant
swing
pouvoir
dessiner
.
>
Dialog
(
classe
JDialog
)
:
limiter
Frame
,
fournir
fenêtre
de
dialogue
;
classe
J0ptionPane
permettre
de
créer
fenêtre
de
dialogue
simple
standard
;
classe
JDialog
permettre
de
créer
fenêtre
de
dialogue
personnaliser
.
>
Applet
(
classe
JApplet
)
:
spécialiser
pour
interface
web
,
fournir
fenêtre
être
afficher
par
navigateur
web
.
+
conteneur
intermédiaire
,
:
>
panel
(
classe
JPanel
)
:
simplifier
positionnement
objet
graphique
atomique
.
conteneur
de
haut
niveau
contenir
conteneur
intermédiaire
spécial
appeler
ContentPane
.
être
conteneur
intermédiaire
principal
.
contenir
panel
.
+
composant
atomique
,
par
exemple
:
>
Button
(
classe
JButton
)
>
label
(
classe
JLabel
)
>
Text
field
(
classe
JTextField
)
sauf
pour
conteneur
de
haut
niveau
,
composant
(
conteneur
intermédiaire
composer
atomique
)
commencer
par
J
hériter
de
classe
JComponent
.
pour
ajouter
objet
à
conteneur
,
utiliser
méthode
add
.
méthode
prendre
en
général
deuxième
argument
spécifier
mise
en
page
.
exemple
:
/
/
import
dns-remplacé
.
*
;
frame
=
new
JFrame
(
.
.
.
)
;
paner
=
new
JPanel
(
)
;
button
=
new
JButton
(
.
.
.
)
;
label
=
new
JLabel
(
.
.
.
)
;
dns-remplacer
(
button
)
;
dns-remplacer
(
1abel
)
;
dns-remplacer
(
)
.add
(
paner
,
dns-remplacer
)
;
dns-remplacer
(
)
;
/
/
sizes
at
or
above
preferred
sizes
dns-remplacé
(
true
)
;
/
/
objet
frame
créer
avoir
pour
hiérarchie
:
JFrame
ContentPane
JPanel
JButton
JLabel
exemple
:
import
dns-remplacé
;
public
AppletExample
extends
JApplet
{
public
void
init
)
{
JPanel
paner
=
new
JPanel
(
)
;
dns-remplacer
(
new
JLabel
(
`
`
hello
,
World
!
'
'
)
;
dns-remplacer
(
paner
)
;
gestion
de
mise
en
page
mise
en
page
(
layout
)
consister
à
fixer
taille
position
composant
.
conteneur
posséder
gestionnaire
de
mise
en
page
par
défaut
.
convenir|convier
,
pouvoir
remplacer
.
composant
pouvoir
solliciter
taille
alignement
donné
,
,
in
fine
,
être
gestionnaire
de
mise
en
page
conteneur
conserver
décision
final
.
exister
gestionnaire
de
mise
en
page
:
+
BorderLayout
:
gestionnaire
de
mise
en
page
par
défaut
pour
ContentPane
;
définir
zone
de
placement
:
NORTH
,
SOUTH
,
EAST
,
WEST
,
CENTER
+
FlowLayout
:
gestionnaire
de
mise
en
page
par
défaut
pour
JPanel
;
positionner
composant
de
gauche
à
droit|droite
,
passer
à
nouveau
ligne
nécessaire
+
BoxLayout
:
gestionnaire
de
mise
en
page
flexible
;
positionner
composant
sur
seul
ligne
colonne
en
respecter
attente
de
composant
en
matière
de
taille
maximal
de
alignement
+
GridLayout
:
gestionnaire
de
mise
en
page
simple
;
créer
ensemble
de
composant
de
même
taille
affiche
dans
nombre
de
ligne
de
colonne
spécifier
+
GridBagLayout
:
gestionnaire
de
mise
en
page
sophistiqué
flexible
;
aligner
composant
en
placer
dans
grille
de
cellule
,
permettre
à
de
étendre
sur
cellule
(
largeur
rangée
hauteur
colonne
,
,
pouvoir
être
différent
)
+
CardLayout
:
gestionnaire
de
mise
en
page
pour
usage
spécial
;
permettre
de
implémenter
zone
contenir
différent
composant
à
différent
moment
;
utiliser
en
combinaison
avec
autre
gestionnaire
de
mise
en
page
exemple
de
changement
gestionnaire
de
mise
en
page
par
défaut
:
JPanel
paner
=
new
JPanel
(
)
;
dns-remplacer
(
new
BorderLayout
(
)
)
;
taille
alignement
de
composant
pouvoir
être
spécifier
par
méthode
suivant
:
setMinimumSize
,
setPreferredSize
,
setMaximumSize
,
setAlignmentX
,
setAlignmentY
.
gestion
événement
notion
de
événement
à
fois
utilisateur
agir
sur
clavier
souris
,
événement
survenir
,
objet
événement
être
générer
.
objet
événement
être
objet
contenir
information
sur
source
nature
de
événement
survenir
.
swing
offrir
interface
(
sens|sen
java
)
appeler
`
`
écouteur
de
événement
`
`
(
event
listeners
)
permettre
de
capter
événement
de
façon
sélectif
de
pouvoir
traiter
.
event
source
event
object
event
listener
event
listener
event
listener
exemple
de
événement
type
de
Listener
clic
de
bouton
graphique
enfoncement
de
touche
return
ActionListener
de
saisie
dans
champ
texte
fermeture
de
fenêtre
WindowListener
graphique
(
frame
)
clic
de
souris
passage
curseur
sur
composant
MouseListener
graphique
de
faciliter
travail
programmeur
,
swing
associer
à
interface
Listener
classe
adaptateur
(
adapter
)
.
adaptateur
exister
,
être
avec
travailler
.
exemple
de
interface
Listener
classer
adapter
associer
ActionListener
none
WindowListener
WindowAdapter
MouseListener
MouseAdapter
KeyListener
KeyAdapter
réaliser
gestionnaire
de
événement
réaliser
gestionnaire
de
événement
(
event
handler
)
requérir
trois
élément
de
code
:
+
déclarer
classe
gestionnaire
de
événement
:
classe
devoir
implémenter
interface
Listener
étendre
classe
adapter
exemple
:
import
dns-remplacé
.
*
;
public
class
MyClass
implements
ActionListener
{
.
.
.
}
+
définir
dans
classe
gestionnaire
de
événement
méthode
de
interface
Listener
exemple
:
public
void
actionPerformed
(
ActionEvent
e
)
{
.
.
.
}
+
définir
instance
de
classe
gestionnaire
de
événement
enregistrer
sur
(
s
)
composer
(
s
)
concerner
(
s
)
exemple
:
dns-remplacer
(
instanceOfMyClass
)
;
type
ActionListener
permettre
de
définir
gestionnaire
de
événement
simple
commun
.
événement
de
type
être
générer
(
clic
de
bouton
graphique
enfoncement
de
touche
return
de
saisie
dans
champ
texte
)
,
message
actionPerformed
être
envoyer
à
écouteur
de
événement
être
enregistrer
sur
composant
concerner
.
classe
gestionnaire
de
événement
être
implanter
sous
forme
de
classe
interne
(
inner
)
sein
de
classe
graphique
.
exemple
:
/
/
Ecriture
de
MouseListener
public
class
myClass
extends
JPanel
{
...
dns-remplacer
(
new
MyAdapter
(
)
)
;
...
MyAdapter
extends
MouseAdapter
{
public
void
mouseClicked
(
MouseEvent
e
)
{
...
}
}
}
,
classe
gestionnaire
de
événement
être
implanter
sous
forme
de
classe
interne
anonyme
.
exemple
(
solution
équivalent
à
de
exemple
précédent
)
:
/
/
Ecriture
de
MouseListener
public
class
myClass
extends
JPanel
{
...
dns-remplacer
(
new
MouseAdapter
(
)
{
public
void
mouseClicked
(
MouseEvent
e
)
{
...
}
}
)
;
...
}
affichage
/
fermeture
de
fenêtre
graphique
affichage
/
masquage
de
fenêtre
graphique
de
type
JFrame
commander
par
méthode
setVisible
.
utilisateur
ferme
fenêtre
graphique
de
type
JFrame
,
fenêtre
être
faire
,
par
défaut
,
masquer
.
Quoiqu'invisible
,
objet
graphique
exister
programme
pouvoir
à
nouveau
rendre
visible
.
désirer
comportement
différent
,
être
nécessaire
:
-
de
enregistrer
sur
objet
graphique
gestionnaire
de
événement
de
type
WindowListener
de
capter
message
windowClosing
-
de
spécifier
comportement
par
défaut
en
utiliser
méthode
setDefaultCloseOperation
.
comportement
être
indiquer
en
argument
par
constant
(
définir
dans
interface
WindowConstant
)
.
exemple
de
argument
:
DISPOSE_ON_CLOSE
architecture
composant
swing
objectif
:
application
adaptable
.
architecture
composant
swing
être
baser
sur
adaptation
de
renommé
architecture
MVC
(
`
`
Modèle-Vue-Contrôleur
`
`
;
voir
section
)
.
dans
communauté
swing
,
être
appeler
`
`
architecture
à
modèle
séparable
`
`
:
partie
modèle
de
composant
swing
(
partie
représenter
donnée
de
application
)
être
traiter
élément
séparer
,
préconiser
conception
MVC
;
swing
fusionner
parti
vue
(
prendre
en
charge
représentation
visuel
donnée
)
contrôleur
(
traiter
entrée
utilisateur
)
de
composant
en
seul
objet
interface
utilisateur
(
user
interface
Object
)
.
être
en
général
considérer
bon
pratique
de
centrer
architecture
de
application
de
donnée
de
interface
utilisateur
.
pour
supporter
paradigme
[
]
,
swing
définir
interface
modeler
séparer
pour
composant
.
séparation
fournir
programme
de
application
possibilité
de
connecter
composant
swing
dans
implémentation
modeler
propre
.
table
suivant
montrer
interface
modeler
offrir
par
composant
swing
:
Component
Model
interface
Model
typer
JButton
ButtonModel
gui
JToggleButton
ButtonModel
gui
/
dater
JCheckBox
ButtonModel
gui
/
dater
JRadioButton
ButtonModel
gui
/
dater
JMenu
ButtonModel
gui
JMenuItem
ButtonModel
gui
JCheckBoxMenuItem
ButtonModel
gui
/
dater
JRadioButtonMenuItem
ButtonModel
gui
/
dater
JComboBox
ComboBoxModel
dater
JProgressBar
BoundedRangeModel
gui
/
dater
JScrollBar
BoundedRangeModel
gui
/
dater
Slider
BoundedRangeModel
gui
/
dater
Component
Model
interface
Model
typer
JTabbedPane
SingleSelectionModel
gui
JList
ListModel
dater
JList
ListSelectionModel
gui
JTable
TableModel
dater
JTable
TableColumnModel
gui
JTree
TreeModel
dater
JTree
TreeSelectionModel
gui
JEditorPane
document
dater
JTextPane
document
dater
JTextArea
document
dater
JTextField
document
dater
JPasswordField
document
dater
interface
modeler
fournir
par
swing
relever
de
deux
grand
catégorie
:
type
'
'
Etat
de
interface
graphique
`
`
(
gui
)
,
définir
statut
visuel
commande
de
interface
graphique
;
type
`
`
donnée
de
application
`
`
(
dater
)
,
représenter
donnée
quantifiable
avoir
sens|sen
pour
application
.
modèle
relever
de
type
partager
(
gui
/
dater
)
.
être
recommander
de
utiliser
catégorie
`
`
donnée
de
application
`
`
(
dater
)
modèle
de
swing
renforcer
adaptabilité
modularité
application
sur
long
terme
.
[
]
paradigme
être
vision
monde
reposer
sur
modèle
.
Applet
java
permettre
de
créer
deux
type
de
programme
:
-
application
,
exécuter
sous
contrôle
de
machine
virtuel
java
-
appliquette
(
applette
;
en
anglais
:
applet
)
destiner
à
être
exécuter
par
navigateur
Web
pour
réaliser
applette
,
minimum
consister
à
:
-
créer
sous-classe
de
classe
JApplet
(
voir
section
)
-
créer
méthode
init
(
)
,
être
lancer
par
navigateur
-
référencer
classe
dans
balise
<
APPLET
coder
=
...
>
de
fichier
HTML
syntaxe
:
import
dns-remplacé
;
public
AppletClassName
extends
JApplet
{
/
/
...
Fields
...
public
void
init
)
{
;
...
}
}
syntaxe
:
<
APPLET
coder
=
'
'
dns-remplacer
'
'
WIDTH
=
anint
HEIGHT
=
anint
>
<
/
APPLET
>
annexe
-
THREADS
référence
:
programmation
concurrent
,
processus
,
threads
dns-remplacer
/
doc
/
books
/
tutorial
/
essential
/
concurrency
/
dns-remplacer
threads
permettre
de
programmer
tâche
,
à
intérieur
de
même
programme
,
exécuter
.
être
processus
léger
.
tâche
à
exécuter
par
thread
devoir
être
implémenter
dans
méthode
run
(
)
.
exister
deux
façon
de
fournir
méthode
run
(
)
:
-
définir
sous-classe
de
classe
Thread
redéfinir
méthode
run
(
)
-
définir
classe
implémente
interface
Runnable
définir
méthode
run
(
)
créer
thread
par
extension
de
classe
Thread
exemple
:
/
/
Example
of
defining
avoir
thread
avoir
extending
Thread
public
class
SimpleThread
extends
Thread
{
public
SimpleThread
(
string
threadName
)
{
super
(
threadName
)
;
}
/
/
The
task
of
this
thread
is
to
print
times
its
name
/
/
at
avoir
random
rater
public
void
run
(
)
{
for
(
int
i
=
;
i
<
;
i++
)
{
dns-remplacer
(
i
+
`
`
`
`
+
getName
(
)
)
;
try
{
sleep
(
(
long
)
(
dns-remplacer
(
)
*
)
)
;
}
catch
(
InterruptedException
e
)
{
}
}
dns-remplacé
(
`
`
DONE
!
`
`
'
'
+
getName
(
)
)
;
}
}
/
/
end
SimpleThread
/
/
Example
of
running
two
threads
concurrently
.
/
/
`
`
Jamaica
'
'
and
`
`
Fiji
'
'
Will
be
printed
randomly
times
.
public
static
void
main
(
string
[
]
args
)
{
new
SimpleThread
(
`
`
Jamaica
'
'
)
.start
(
)
;
new
SimpleThread
(
`
`
Fiji
'
'
)
.start
(
)
;
}
créer
thread
par
implémentation
de
interface
Runnable
façon
de
faire
imposer
classe
à
créer
devoir
sous-classer
classe
quelconque
(
cas
typique
être
Applet
)
,
java
supporter
héritage
multiple
.
exemple
:
/
/
Example
of
defining
avoir
thread
avoir
implementing
Runnable
public
class
SimpleThread
implements
Runnable
{
string
threadName
;
public
SimpleThread
(
string
threadName
)
{
dns-remplacer
=
threadName
;
}
/
/
The
task
of
this
thread
is
to
print
times
its
name
/
/
at
avoir
random
rater
public
void
run
(
)
{
for
(
int
i
=
;
i
<
;
i++
)
{
dns-remplacer
(
i
+
`
`
`
`
+
threadName
)
;
try
{
dns-remplacer
(
(
long
)
(
dns-remplacer
(
)
*
)
)
;
}
catch
(
InterruptedException
e
)
{
}
}
dns-remplacé
(
`
`
DONE
!
'
'
+
threadName
)
;
}
}
/
/
end
SimpleThread
/
/
Example
of
running
two
threads
concurrently
/
/
(
`
`
Jamaica
'
'
and
`
`
Fiji
'
'
Will
be
printed
randomly
times
)
public
static
void
main
(
string
[
]
args
)
{
new
Thread
(
new
SimpleThread
(
`
`
Jamaica
'
'
)
)
.start
(
)
;
new
Thread
(
new
SimpleThread
(
`
`
Fiji
'
'
)
)
.start
(
)
;
}
synchronisation
communication
entre
threads
section
critique
synchronisation
dans
programme
,
segment
de
code
accéder
à
même
donner
depuis
threads
concurrent
être
appeler
section
critique
.
deux
threads
concurrent
invoquer
méthode
opérer
sur
même
donnée
partager
(
méthode
critique
)
,
être
nécessaire
java
pouvoir
synchroniser
méthode
de
garantir
accès
sûr
à
information
.
à
fin
,
de
méthode
devoir
être
déclarer
avec
modificateur
synchronized
.
à
exécution
,
accès
à
donnée
partagé
être
verrouiller
être
utiliser
par
méthode
critique
.
exemple
:
get
pouvoir
être
supposer
deux
méthode
critique
de
objet
partager
.
public
synchronized
int
get
(
)
{
...
}
public
synchronized
void
pouvoir
(
int
valoir
)
{
...
}
communication
entre
threads
deux
threads
,
processus
indépendant
dérouler
de
façon
asynchrone
,
pouvoir
communiquer
donnée
,
être
nécessaire
savoir
synchroniser
de
sas
de
communication
.
thread
émetteur
de
donnée
être
appeler
producteur
;
thread
destinataire
de
donnée
être
appeler
consommateur
.
thread
producteur
de
donnée
devoir
être
capable
de
:
-
attendre
espace
de
stockage
sas
de
communication
être
libre
;
-
déposer
nouveau
donnée
;
-
informer
threads
consommateur
de
mise
à
disposition
de
donnée
.
de
façon
symétrique
,
thread
consommateur
de
donnée
devoir
être
capable
de
:
-
attendre
donnée
être
mettre
à
disposition
dans
espace
de
stockage
sas
de
communication
;
-
lire
donnée
;
-
informer
threads
producteur
de
disponibilité
sas
de
communication
accuser
réception
.
être
sas
de
communication
confier
charge
de
synchronisation
.
mise
en
attente
réaliser
par
méthode
wait
(
)
,
notification
autre
threads
par
méthode
notify
(
)
notifyAll
(
)
.
méthode
être
deux
définir
dans
classe
Object
(
)
.
exemple
de
classe
définir
sas
de
communication
de
seul
élément
de
type
entier
(
attribut
content
)
.
noter
en
particulier
sécurisation
apporter
par
usage
de
while
de
if
de
prévenir
de
faux
réveil
éventuel
.
public
class
CubbyHole
{
private
int
content
;
private
boolean
available
=
false
;
public
synchronized
int
get
(
)
{
/
/
called
by
consumer
while
(
available
=
=
false
)
{
try
{
wait
(
)
;
/
/
wait
for
Producer
to
pouvoir
valoir
}
catch
(
InterruptedException
e
)
(
)
{
}
}
available
=
false
;
notifyAll
(
)
;
return
content
;
}
public
synchronized
void
pouvoir
(
int
x
)
{
/
/
called
by
Producer
while
(
available
=
=
true
)
{
try
{
wait
(
)
;
/
/
wait
for
consumer
to
get
valoir
}
catch
(
InterruptedException
e
)
(
)
{
}
}
content
=
x
;
available
=
true
;
notifyAll
(
)
;
}
annexe
-
conception
DEVELOPPEMENT
en
java
référence
:
architecture
Modèle-Vue-Contrôleur
:
dns-remplacer
/
blueprints
/
guidelines
/
designing_enterprise_applications_2e
/
app-arch
/
dns-remplacer
développement
de
test
unitaire
avec
cadre
de
application
JUnit
:
dns-remplacer
/
doc
/
cookbook
/
dns-remplacer
JavaBeans
:
dns-remplacer
/
products
/
javabeans
/
dns-remplacer
/
doc
/
books
/
tutorial
/
javabeans
/
dns-remplacé
design
pattern
:
section
aller
langage
java
pour
aborder
aspect
de
conception
développement
de
programme
java
.
conseil
général
pour
bon
conception
classe
rechercher
couplage
faible
.
couplage
décrire
interconnectivité
entre
classe
.
couplage
être
faible
classe
être
indépendant
autre
communiquer
avec
via
interface
petit
définir
(
interface
de
classe
être
partie
visible
publique
de
classe
:
définir
par
liste
membre
(
attribut
,
constructeur
,
méthode
)
priver
associer
à
commentaire
de
documentation
)
.
rechercher
COHESION
fort
.
cohésion
décrire
adéquation
entre
unité
de
code
entité
tâche
logique
.
cohésion
être
fort
unité
de
code
(
méthode
,
classe
,
module
,
...
.
.
)
être
responsable
de
entité
tâcher
définir
.
utiliser
maximum
encapsulation
.
encapsulation
être
technique
de
base
pour
réduire
couplage
.
contribuer
à
séparer
,
vue
implémentation
,
définition
utilisation
.
principe
de
base
:
rendre
attribut
priver
utiliser
méthode
de
accès
.
DECOUPLER
ENTREES
,
traitement
sortir
.
voir
en
particulier
section
adopter
conception
DIRIGEE
par
responsabilité
.
attribution
bon
responsabilité
bon
classe
être
un
problème
délicat
de
conception
orienter
objet
.
programmation
diriger
par
responsabilité
être
processus
de
conception
de
classe
par
attribution
de
responsabilité
définir
à
classe
.
approche
pouvoir
être
utiliser
pour
déterminer
classer
devoir
implémenter
fonctionnalité
.
conception
diriger
par
responsabilité
contribuer
à
réduire
couplage
.
EVITER
duplication
de
code
.
Eviter
même
segment
de
code
retrouver
de
fois
dans
application
.
utiliser
HERITAGE
à
bon
escient
.
héritage
être
relation
`
`
est_un
`
`
,
relation
'
'
a_un
`
`
.
dans
hiérarchie
de
héritage
,
objet
devoir
avoir
relation
`
`
est_un
`
`
avec
classe
de
base
,
héritage
de
attribut
,
propriété
méthode
de
classe
de
base
garder
sens|sen
(
sous-classe
spécialiser
complet
)
.
objet
relever
de
relation
`
`
est_un
`
`
devoir
traduire
par
classe
interface
sans
relation
de
héritage
entre
.
limiter
taille
COMPLEXITE
.
mettre
de
chose
dans
méthode
:
méthode
être
longue
faire
de
tâche
logique
.
mettre
dans
seul
classe
:
classe
être
complexe
représenter
de
entité
logique
.
chercher
à
faciliter
changement
localiser
.
réaliser
changement
dans
classe
devoir
avoir
minimum
de
impact
sur
autre
classe
.
localisation
changement
être
un
but
rechercher
de
bon
conception
de
classe
.
être
produit
de
couplage
faible
de
cohésion
fort
.
architecture
de
application
interactif
:
modèle
MVC
architecture
Modèle-Vue-Contrôleur
(
Model-View-Controller
,
MVC
)
être
modèle
de
architecture
logicielle
recommander
-
utiliser
-
pour
conception
de
application
interactif
.
modèle
viser
à
minimiser
degré
de
couplage
entre
objet
de
application
en
découpler
entrer
,
traitement
sortir
.
point
essentiel
consister
à
séparer
objet
relever
de
interface
utilisateur
objet
métier
,
de
pouvoir
faire
évoluer
réutiliser
.
MVC
organiser
application
interactif
en
trois
grand
composante
:
modèle
,
vue
contrôleur
,
découpler
responsabilité
respectif
:
+
MODELE
encapsuler
fonctionnalité
donné
cœur
de
application
.
être
indépendant
de
représentation
de
sortie
spécifique
de
comportement
de
entrée
.
avoir
à
charge
représentation
interne
donnée
de
application
logique
de
gestion
de
donnée
.
notifier
à
composant
vue
changement
de
donnée
permettre
de
interroger
sur
état
.
fournir
contrôleur
possibilité
de
accéder
à
fonctionnalité
applicatives
encapsuler
dans
modèle
.
+
vue
afficher
information
à
utilisateur
.
récupérer
modèle
donnée
à
présenter
à
utilisateur
,
spécifier
présentation
externe
mettre
à
jour
information
afficher
.
relayer
contrôleur
entrée
utilisateur
autoriser
à
sélectionner
vue
.
séparation
modèle
de
part
de
vue
contrôleur
de
autre
part
permettre
vue
multiple
de
même
modèle
.
avoir
vue
modèle
,
vue
avoir
contrôleur
associé
.
+
CONTROLEUR
gérer
entrée
utilisateur
.
recevoir
entrée
,
sous
forme
de
événement
encoder
mouvement
de
souris
,
activation
de
bouton
,
entrée
clavier
(
,
agir
de
application
web
,
requête
HTTP
GET
POST
)
.
événement
être
traduire
en
requête
de
service
pour
modèle
vue
.
application
avoir
contrôleur
pour
ensemble
de
fonctionnalité
apparenté
.
application
pouvoir
avoir
contrôleur
séparer
par
type
de
client
interaction
utilisateur
varier
selon
type
de
client
.
utilisateur
interagir
avec
système
travers
contrôleur
.
ensemble
voir
+
contrôleur
composer
interface
utilisateur
.
modèle
interrogation
de
état
notification
de
changement
changement
de
état
voir
requêter
utilisateur
sélection
de
vue
contrôleur
invocation
de
méthode
Evènements
en
pratique
,
schéma
de
principe
laisser
place
à
grand
variété
de
implémentations
possible
.
difficulté
pour
implémentation
idéal
en
java
résider
dans
fait
composant
graphique
swing
fusionner
partie
voir
contrôleur
(
cf
section
)
.
pour
petit
programme
,
vue
contrôleur
être
combiner
,
dans
cas
modèle
devoir
être
séparer
.
exemple
de
implémentation
de
architecture
MVC
:
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacé
;
public
Controller
extends
JApplet
implements
ActionListener
{
private
View
view
;
private
Model
model
;
public
void
init
(
)
{
model
=
new
Mode1
(
)
;
view
=
new
View
(
model
,
this
)
;
dns-remplacer
(
view
)
;
dns-remplacer
(
view
)
;
}
public
void
actionPerformed
(
ActionEvent
e
)
{
/
/
process
the
event
}
}
public
class
View
extends
JPanel
implements
observer
{
private
Model
model
;
/
/
Declare
here
the
JPanel
components
.
public
View
(
Model
m
,
ActionListener
listener
)
{
model
=
m
;
makeContentPane
(
listener
)
;
}
public
void
update
(
observable
o
,
Object
arg
)
{
/
/
Automatically
called
when
observer
is
notified
.
/
/
Update
the
view
.
}
public
void
makeContentPane
(
ActionListener
listener
)
{
/
/
Create
and
initialize
the
JPanel
components
and
,
/
/
when
need
be
,
attach
them
the
event
listener
.
/
/
Define
the
layout
.
}
}
public
Model
extends
observable
{
/
/
Wherever
the
valoir
of
an
attribute
interesting
the
/
/
View
is
changed
,
insert
these
two
statements
/
/
setChanged
(
)
;
/
/
notifyObservers
(
)
;
or
notifyObservers
(
arg
)
;
}
chercher
à
découpler
traitement
entrées-sortie
être
classique
en
programmation
.
dans
esprit
,
pouvoir
noter
en
particulier
modèle
MVC
avoir
certain
similitude
avec
classique
architecture
trois-tiers
(
three-tiers
)
système
distribuer
.
architecture
trois-
tiers
être
architecture
logicielle
client-serveur
dans
interface
utilisateur
,
logique
de
traitement
donnée
être
trois
module
indépendant
:
interface
utilisateur
être
stocker
dans
client
,
gros
de
logique
de
application
être
stocker
dans
serveur
de
application
,
donnée
être
stocker
dans
serveur
de
base
de
donnée
.
exemple
.
pour
application
web
professionnel
reposer
sur
solution
java
EE
(
voir
chapitre
)
,
modèle
être
assurer
par
EJB
/
JavaBeans
,
contrôleur
être
assurer
par
servlets
,
vue
par
JSP
(
glossaire
en
chapitre
)
.
test
unitaire
définition
test
être
activité
consister
à
déterminer
segment
de
code
(
méthode
,
classe
programme
)
produire
résultat
attendre
.
définir
trois
niveau
de
test
,
être
mettre
en
œuvre
:
+
test
unitaire
(
unir
testing
)
:
agir
de
tester
composante
individuel
(
méthode
,
classe
)
de
application
.
+
test
de
intégration
(
integration
testing
)
:
agir
de
tester
groupe
de
classe
en
interrelation
application
dans
ensemble
.
test
appliqué
suivre
plan
de
test
(
i.e.
.
approche
systématique
méthodique
)
.
+
test
système
(
system
testing
)
:
agir
de
tester
application
intégrer
dans
environnement
de
utilisation
complet
.
test
entrer
dans
catégorie
test
boîte
noir
,
,
en
,
devoir
nécessiter
de
connaissance
de
conception
interne
code
de
logique
.
considération
suivant
limiter
test
unitaire
.
cas
de
test
être
ensemble
de
condition
variable
à
partir
testeur
déterminer
exigence
requis
être
satisfaire
.
cas
de
test
être
caractériser
par
entrée
connaître
(
pré-condition
)
sortie
attendre
(
post-
condition
)
.
de
nombreux
cas
de
test
pouvoir
être
nécessaire
pour
vérifier
exigence
donner
.
distinguer
deux
type
de
cas
de
test
:
-
cas
de
test
positif
,
consister
à
tester
cas
censé
faire
réussir
fonctionnalité
.
test
devoir
convaincre
élément
de
code
tester
fonctionner
espérer
.
-
cas
de
test
négatif
,
consister
à
tester
cas
censé
mettre
en
échec
fonctionnalité
.
être
situation
de
valeur
hors
limite
,
de
erreur
,
...
.
exemple
:
entrer
valeur
hors
plage
,
lire
ensemble
vide
,
...
.
dans
de
cas
,
devoir
attendre
à
programme
traiter
erreur
de
façon
contrôler
approprier
.
simple
correction
erreur
détecter
par
test
devoir
améliorer
qualité
programme
.
,
expérience
montrer
changement
dans
programme
pouvoir
introduire
,
de
façon
inattendu
,
de
autre
erreur
.
en
particulier
erreur
de
régression
(
regression
bugs
)
:
erreur
de
régression
survenir
fonctionnalité
fonctionner
fonctionner
suite
à
modification
programme
.
méthode
courant
de
test
de
non-régression
(
non-regression
testing
)
consister
à
réexécuter
test
réaliser
voir
défaut
apparaître
réapparaître
.
test
être
appliquer
seul
fois
à
modification
logiciel
,
être
souhaitable
de
disposer
de
batterie
de
test
programmer
de
permettre
automatisation
test
.
agir
de
programmer
cas
de
test
pour
méthode
trivial
,
veiller
à
cas
de
test
être
séparer
autre
.
JUnit
JUnit
,
développer
par
communauté
open
source
,
offrir
cadre
de
application
(
framework
)
pour
programmation
de
test
de
régression
.
être
utiliser
pour
implémenter
test
unitaire
en
java
.
classe
TestCase
permettre
de
définir
cas
de
test
;
classe
Assert
fournir
ensemble
de
méthode
faciliter
gestion
erreur
détecter
;
classe
TestSuite
permettre
de
exécuter
suite
de
test
;
classe
TestRunner
être
outil
de
exploitation
permettre
de
définir
suite
de
test
à
exécuter
de
afficher
résultat
.
exemple
de
cas
de
test
:
/
*
*
*
à
test
caser
for
the
class
MyClass
*
/
import
dns-remplacé
.
*
;
public
class
TestMyClass
extends
TestCase
{
/
*
The
test
need
to
run
against
the
background
of
à
known
*
set
of
objects
.
This
set
of
objects
is
called
à
test
*
fixture
.
*
Define
here
an
instance
variable
for
each
partir
of
the
*
fixture
.
*
/
private
MyClass
myObject
;
public
TestMyClass
(
string
name
)
{
super
(
name
)
;
}
/
*
*
*
set
up
the
test
fixture
.
*
setUp
(
)
is
called
before
every
test
caser
method
.
*
Initialize
the
instance
variable
.
*
/
protected
void
setUp
(
)
{
myObject
=
new
MyClass
(
.
.
.
)
;
}
/
*
*
*
Tears
down
the
test
fixture
.
*
tearDown
(
)
is
called
after
every
test
caser
method
.
*
Releases
any
permanent
resource
allocated
in
setUp
*
(
example
:
clore
file
,
...
)
*
/
protected
void
tearDown
(
)
{
/
/
...
}
/
/
once
the
fixture
is
in
place
,
avoir
many
test
case
avoir
/
/
necessary
can
be
written
.
/
*
*
*
test
the
method
methodX
(
)
*
/
public
void
testMethodX
(
)
{
ArgumentType
argument
=
.
.
.
;
ResponseType
expectedResponse
=
.
.
.
;
string
errorMessage
=
`
`
.
.
.
`
`
;
assertTrue
(
errorMessage
,
dns-remplacer
(
MethodX
(
argument
)
)
;
}
}
/
/
end
TestMyClass
JUnit
déterminer
succès
échec
de
test
via
instruction
de
assertion
.
assertion
être
procédure
de
comparaison
entre
valeur
espérer
valeur
effectif
générer
échec
en
cas
de
différence
.
procédure
de
assertion
disponible
être
définir
dans
classe
dns-remplacé
.
exemple
de
instruction
de
assertion
:
assertTrue
(
errorMessage
,
booleanCondition
)
;
assertFalse
(
errorMessage
,
booleanCondition
)
;
assertEquals
(
errorMessage
,
expectedValue
,
actualValue
)
;
assertEquals
(
errorMessage
,
doubleExpected
,
doubleActual
,
doubleDelta
)
;
pour
exécuter
test
,
créer
instance
de
classe
avec
en
paramètre
nom
de
méthode
de
test
.
exemple
new
TestMyClass
(
`
`
testMethodX
'
'
)
;
JUnit
être
intégrer
dans
outil
de
développement
.
de
outil
offrir
fonctionnalité
permettre
de
créer
test
.
java
Beans
java
Bean
(
`
`
grain
java
`
`
)
être
définir
par
Sun
`
`
composant
réutilisable
java
destiner
à
être
manipuler
par
outil
de
développement
graphique
visuel
`
`
.
java
Beans
être
composant
java
(
i.e.
.
classe
)
respecter
critère
de
pouvoir
être
développer
,
assembler
réutiliser
pour
créer
application
sophistiqué
.
par
exemple
,
technologie
java
Beans
être
architecture
composant
dans
plate-forme
java
.
obligation
devoir
respecter
java
Bean
être
nombreux
enjeu
être
de
importance
:
disposer
de
composant
`
`
Write
One
,
run
Anywhere
`
`
(
WORA
)
réutilisable
.
java
Beans
être
classe
publique
concret
avoir
pour
caractéristique
commune
de
:
+
supporter
`
`
propriété
`
`
:
propriété
être
attribut
discret
nommer
de
java
Bean
pouvoir
affecter
apparence
comportement
.
propriété
être
pour
java
Beans
équivalent
champ
pour
objet
.
par
exemple
,
bouton
graphique
pouvoir
avoir
propriété
nommer
`
`
label
`
`
représenter
texte
afficher
dans
bouton
.
méthode
de
accès
propriété
devoir
respecter
convention
de
nommage
particulier
,
par
exemple
:
-
pour
propriété
simple
(
exister
de
autre
:
lier
,
contraindre
,
indexer
,
...
)
:
PropertyType
getPropertyName
(
)
;
/
/
simple
getter
void
setPropertyName
(
PropertyType
)
;
/
/
simple
setter
-
pour
propriété
booléen
,
utiliser
is
lieu
de
get
+
communiquer
entre
par
événement
:
en
pratique
,
utiliser
technique
swing
`
`
listeners
`
`
(
voir
section
)
;
+
supporter
introspection
:
à
exécution
dans
environnement
de
développement
,
devoir
être
capable
de
déterminer
de
analyser
propriété
,
événement
méthode
supporter
java
Bean
.
à
noter
propriété
de
introspection
être
présent
dans
objet
java
puisqu'un
objet
pouvoir
être
analyser
grâce
classe
class
,
Method
,
Field
,
+
supporter
personnalisation
(
`
`
customization
`
`
)
:
outil
de
développement
devoir
permettre
de
modifier
apparence
comportement
de
java
Bean
en
phase
de
conception
;
+
supporter
persistance
:
persistance
de
objet
être
capacité
de
sauvegarder
sur
support
de
stockage
de
restaurer
à
identique
programme
pouvoir
terminer
sans
objet
être
perdre
.
exemple
de
persistance
:
objet
pouvoir
prétendre
à
être
document
Excel
à
intérieur
de
document
Word
.
mécanisme
rendre
possible
persistance
être
appeler
`
`
sérialisation
`
`
(
serialization
)
.
à
fin
,
java
Bean
devoir
implémenter
interface
Serializable
Externalizable
.
exemple
de
java
Bean
:
package
dns-remplacer
;
import
dns-remplacé
.
*
;
import
dns-remplacé
;
/
*
*
*
SimpleBean
wi11
be
displayed
with
avoir
green
*
centered
rectangle
,
boire
its
color
may
be
changed
1ater
.
*
/
public
class
SimpleBean
extends
Canvas
implements
Serializable
{
private
Color
color
=
dns-remplacer
;
/
/
Property
getter
method
.
public
Color
getColor
(
)
{
return
color
;
}
/
/
Property
setter
method
.
/
/
set
new
SimpleBean
color
and
repaints
.
public
void
setColor
(
Color
newColor
)
{
color
=
newColor
;
repaint
(
)
;
}
public
void
paint
(
Graphics
g
)
{
g.setColor
(
color
)
;
g.fillRect
(
,
,
,
)
;
}
/
/
Constructor
set
inherited
properties
public
SimpleBean
(
)
{
setSize
(
,
)
;
setBackground
(
dns-remplacer
)
;
}
}
/
/
end
class
SimpleBean
pour
être
reconnaître
par
outil
de
développement
,
java
Bean
devoir
être
conditionnné
dans
fichier
de
archiver
format
jar
.
être
obligatoire
,
être
souhaitable
java
Beans
être
paquetage
(
éviter
conflit
en
cas
de
homonymie
beans
)
.
design
pattern
section
être
premier
introduction
modèle
de
conception
(
design
pattern
)
[
]
.
développement
orienter
objet
de
application
professionnel
conduire
à
rencontrer
problème
de
conception
type
être
familier
à
communauté
développeur
confirmer
solution
éprouver
exister
.
agir
de
solution
théorique
(
algorithme
)
de
solution
orienter
objet
empirique
solidité
efficacité
avoir
faire
preuve
en
pratique
.
solution
être
appeler
modèle
de
conception
(
design
pattern
)
.
développeur
expérimenté
devoir
de
connaître
de
disposer
de
un
`
`
panier
`
`
de
modèle
de
conception
appliquer
possible
.
modèle
de
conception
être
stratégie
de
résolution
de
grand
type
de
problème
de
conception
orienter
objet
.
décrire
forme
générique
de
organisation
de
classe
.
être
indépendant
langage
de
programmation
objet
mettre
en
œuvre
.
à
titre
illustratif
,
architecture
MVC
,
décrire
à
section
,
être
exemple
de
modèle
de
conception
de
architecture
logicielle
(
architectural
design
pattern
)
.
connaître
modèle
de
conception
de
base
être
modèle
fondamental
décrire
par
quatre
auteur
être
appeler
`
`
The
gang
of
four
`
`
(
`
`
bande
quatre
`
`
)
GoF
[
]
.
distinguer
grand
famille
de
modèle
de
conception
:
[
]
expression
design
pattern
être
traduire
par
patron
de
conception
.
[
]
-
modèle
de
construction
avoir
pour
but
de
organiser
création
de
objet
de
façon
à
gagner
en
abstraction
.
exemple
présenter
ci-après
:
modèle
singleton
.
-
modèle
de
structuration
faciliter
organisation
de
hiérarchie
classe
de
relation
.
exemple
présenter
ci-après
:
modèle
Decorator
.
-
modèle
de
comportement
proposer
solution
pour
organiser
interaction
pour
répartir
traitement
entre
objet
.
tenter
de
répartir
responsabilité
entre
classe
.
exemple
:
modèle
Chain
of
Responsibility
permettre
de
créer
chaîne
de
objet
,
un
de
pouvoir
répondre
à
requête
,
pouvoir
transmettre
à
successeur
jusqu
'
à
un
de
entre
répondre
.
exemple
:
modèle
singleton
modèle
de
conception
singleton
permettre
de
assurer
classe
posséder
instance
de
offrir
méthode
unique
retourner
instance
.
exemple
de
implémentation
(
cas
information
nécessaire
à
création
singleton
être
disponible
moment
chargement
de
classe
en
mémoire
)
public
final
class
MySingleton
{
/
/
Creating
at
the
class
loading
private
static
MySingleton
singleInstance
=
new
MySingleton
(
)
;
/
/
Private
constructor
.
Ca
t
be
used
outside
this
private
MySingleton
(
)
{
...
}
/
*
*
Get
avoir
singleton
of
this
*
/
public
static
MySingleton
getInstance
(
)
{
return
singleInstance
;
}
}
/
/
Creation
of
avoir
singleton
MySingleton
singleton
=
dns-remplacer
(
)
;
exemple
:
modèle
Decorator
modèle
de
conception
Decorator
permettre
de
ajouter
fonctionnalité
à
objet
.
réaliser
en
créer
nouveau
classe
Decorator
envelopper
classe
original
.
modèle
de
conception
Decorator
être
alternative
à
approche
par
création
de
sous-
classe
de
classe
original
.
imposer
à
approche
par
extension
de
classe
original
dans
cas
suivant
:
classe
original
pouvoir
être
étendre
par
héritage
;
nombre
de
sous-classe
permettre
de
définir
combinaison
possible
de
fonctionnalité
être
important
;
ajout
fonctionnalité
pouvoir
être
statique
(
i.e.
.
réaliser
à
compilation
)
devoir
être
dynamique
(
.e
.
réaliser
à
exécution
)
.
exemple
[
Wikipedia
]
.
considérer
fenêtre
de
affichage
instance
de
classe
Window
supposer
classe
offrir
possibilité
de
ajouter
barre
de
défilement
.
créer
décorateur
pouvoir
ajouter
fonctionnalité
à
objet
Window
existant
.
/
/
an
interface
common
to
the
decorator
and
the
decorated
public
interface
Window
{
public
void
draw
(
)
;
}
/
/
The
original
class
,
the
instance
of
which
can
be
decorated
public
class
SimpleWindow
implements
Window
public
void
draw
(
)
{
...
}
}
/
/
The
abstract
decorator
public
abstract
class
WindowDecorator
implements
Window
{
protected
Window
decoratedWindow
;
public
WindowDecorator
(
Window
decoratedWindow
)
{
dns-remplacer
=
decoratedWindow
;
}
}
/
/
à
first
concrete
decorator
public
class
VerticalScrollBarDecorator
extends
WindowDecorator
{
public
VerticalScrollBarDecorator
(
Window
decoratedWindow
)
{
super
(
decoratedWindow
)
;
}
public
void
draw
(
)
{
drawVerticalScrollBar
(
)
;
dns-remplacer
(
)
;
}
public
void
drawVerticalScrollBar
(
)
{
...
}
}
/
/
à
second
concrete
decorator
public
class
HorizontalScrollBarDecorator
extends
WindowDecorator
{
public
HorizontalScrollBarDecorator
(
Window
decoratedWindow
)
{
super
(
decoratedWindow
)
;
}
public
void
draw
(
)
{
drawHorizontalScrollBar
(
)
;
dns-remplacer
(
)
;
}
public
void
drawHorizontalScrollBar
(
)
{
...
}
}
/
/
Example
:
creation
of
avoir
fully
decorated
Window
instance
.
Window
decoratedWindow
=
new
HorizontalScrollBarDecorator
(
new
VerticalScrollBarDecorator
(
new
SimpleWindow
(
)
)
)
;
annexe
--
machine
virtuel
java
(
JVM
)
objectif
premier
de
chapitre
être
:
-
comprendre
opérer
chargement
dynamique
classe
en
mémoire
de
exécution
de
programme
java
;
-
comprendre
traitement
champ
bloc
static
chargement
de
classe
.
machine
virtuel
java
(
JVM
)
être
interpréteur
de
code
java
compiler
(
bytecode
)
permettre
de
exécuter
programme
java
sur
machine
cibler
.
espace
mémoire
de
JVM
comporter
zone
,
:
-
zone
méthode
:
contenir
code
méthode
constructeur
information
sur
structure
de
classe
(
table
symbole
)
;
-
pile
:
espace
propre
à
thread
,
mémoriser
contexte
de
exécution
(
variable
local
)
méthode
en
cours|cour
de
exécution
;
-
tas
:
contenir
objet
créer
par
new
(
instance
de
classe
tableau
)
(
cf
chapitre
)
.
être
demande
de
exécution
de
programme
java
lancer
machine
virtuel
java
.
JVM
réaliser
grand
étape
suivant
:
-
chargement
de
classe
principal
spécifier
(
main
class
)
classe
dépendre
(
premier
rang
sur-classe
)
:
o
création
champ
static
,
création
de
table
méthode
,
...
o
traitement
champ
(
initialisation
)
bloc
(
exécution
)
static
-
exécution
de
méthode
main
de
classe
principal
.
durant
exécution
de
code
java
,
classe
(
bytecode
)
être
charger
dans
JVM
fur
à
mesure
besoin
.
dans
hiérarchie
de
héritage
,
chargement
classe
être
opérer
par
ordre
hiérarchique
descendre
(
i.e.
de
super-classe
raciner
vers
classe
courant
)
.
exemple
:
public
class
classer
{
static
{
dns-remplacer
(
`
`
start
loading
classer
'
'
)
;
}
public
static
final
int
C
;
private
static
int
n
=
;
static
{
C
=
;
}
static
{
dns-remplacer
(
`
`
C
=
`
`
+
C
)
;
dns-remplacer
(
`
`
n
=
`
`
+
n
)
;
}
public
classer
(
)
{
dns-remplacé
(
`
`
start
classer
(
)
'
'
)
;
n
=
n
+
;
dns-remplacer
(
`
`
End
classer
(
)
'
'
)
;
}
public
int
getN
(
)
{
return
n
;
}
static
{
dns-remplacer
(
`
`
End
loading
classer
'
'
)
;
}
}
/
/
end
classer
public
ClassB
extends
classer
{
static
{
dns-remplacer
(
`
`
start
loading
ClassB
'
'
)
;
}
private
int
x
=
;
public
ClassB
(
)
{
dns-remplacé
(
`
`
start
ClassB
(
)
'
'
)
;
x
=
x
+
getN
(
)
;
dns-remplacer
(
x
)
;
dns-remplacer
(
`
`
End
ClassB
(
)
'
'
)
;
}
static
{
dns-remplacer
(
`
`
End
loading
ClassB
'
'
)
;
}
}
/
/
end
ClassB
public
class
(
)
{
static
{
dns-remplacer
(
`
`
start
loading
Class0
'
'
)
;
}
private
static
int
=
initY
(
)
;
private
static
int
initY
(
)
{
dns-remplacer
(
`
`
Init
'
'
)
;
return
;
}
public
static
void
main
(
string
[
]
args
)
{
dns-remplacé
(
`
`
start
main
Class0
'
'
)
;
ClassB
b
=
new
ClassB
(
)
;
dns-remplacer
(
`
`
End
main
Class0
'
'
)
;
}
static
{
dns-remplacer
(
`
`
End
loading
Class0
'
'
)
;
}
}
/
/
end
Class0
après
compilation
de
trois
classe
,
exécution
de
commande
:
java
Class0
afficher
(
commentaire
ajouter
en
marge
)
:
start
loading
Class0
Init
End
loading
Class0
start
main
Class0
start
loading
classer
/
/
Sur-classes
de
ClassB
de
abord
C
=
n
=
End
loading
classer
start
loading
ClassB
/
/
ClassB
.
End
loading
ClassB
start
classer
(
)
/
/
super
(
)
de
abord
.
End
classer
(
)
start
ClassB
(
)
/
/
+
classer
(
)
+
ClassB
(
)
End
ClassB
(
)
End
main
Class0
annexe
-
communication
entre
java
C
(
JNI
)
référence
:
'
'
The
java
natif
interface
:
programmer
'
s
guide
and
Specification
'
'
dns-remplacer
/
doc
/
books
/
jni
/
tutoriel
:
dns-remplacer
/
doc
/
books
/
jni
/
html
/
dns-remplacer
'
'
java
natif
interface
Specification
v1.5
'
'
dns-remplacer
/
j2se
/
/
doc
/
guide
/
jni
/
spec
/
dns-remplacer
'
'
javah
-
C
Header
and
Stub
filer
Generator
'
'
dns-remplacer
/
javase
/
/
doc
/
technote
/
tools
/
windows
/
dns-remplacer
poser
problème
de
appeler
sous-programme
C
depuis
méthode
java
dans
environnement
Unix
.
solution
mettre
en
œuvre
interface
de
programmation
JNI
(
java
natif
interface
)
offrir
par
plate-forme
java
.
JNI
être
ensemble
de
fonctionnalité
permettre
à
programme
java
fonctionner
sur
machine
virtuel
java
(
JVM
)
de
appeler
de
être
appeler
par
programme
écrire
dans
autre
langage
(
en
C
,
C++
assembleur
)
.
en
permettre
interfaçage
avec
application
bibliothèque
natif
[
]
,
mise
en
œuvre
de
JNI
accroître
interopérabilité
application
java
,
détriment
de
portabilité
.
bon
architecture
de
application
devoir
minimiser
nombre
de
classe
faire
référence
à
méthode
natif
.
par
suite
,
supposer
fichier
java
appeler
sous-programme
C
nommer
dns-remplacer
,
fichier
C
implémentir
sous-programme
nommer
MyRoutines.c.
développement
de
application
complet
comporter
étape
:
)
Ecrire
programme
java
compiler
:
javac
dns-remplacer
)
produire
fichier
de
en-tête
MyClass.h.
pour
programme
C
:
javah
MyClass
)
Ecrire
sous-programme
C
compiler
:
gcc
-o
MyRoutines
-c
MyRoutines.c.
-pedantic
-W
-Wal1l
-Idir
dir
être
répertoire
de
installation
par
JDK
fichier
de
include
JNI
.
par
exemple
(
fichier
être
répartir
dans
deux
répertoire
)
:
gcc
-o
MyRoutines
-c
MyRoutines.c.
-pedantic
-W
-Wall
-I
/
usr
/
lib
/
jdk1.5.0v11
/
include
-I
/
usr
/
lib
/
jdk1.5.0v11
/
include
/
linux
[
]
application
bibliothèque
de
sous-programme
être
dire
en
code
natif
être
dépendant
de
environnement
hôte
(
système
de
exploitation
jeu
de
instruction
processeur
)
particulier
.
par
exemple
,
programme
C
compiler
sur
système
de
exploitation
donner
être
en
code
natif
fonctionner
sur
autre
système
de
exploitation
.
)
produire
bibliothèque
partagé
(
lib
*
.so
)
être
chargeable
par
programme
java
:
gcc
-Wall
-shared
-o
dns-remplacer
MyRoutines.o.
)
avant
premier
exécution
,
spécifier
à
machine
virtuel
java
chemin
de
accès
à
bibliothèque
:
setenv
LD_LIBRARY_PATH
path
path
désigner
chemin
de
accès
.
supposer
répertoire
courant
,
commande
être
:
setenv
LD_LIBRARY_PATH
.
)
exécuter
programme
java
:
java
MyClass
façon
de
écrire
programme
java
de
implémenter
sous-programme
C
associé
être
illustrer
ci-après
.
appel
de
procédure
C
considèrera
de
bout
en
bout
même
exemple
.
déclaration
appel
java
exemple
de
classe
java
public
class
MyClass
{
/
/
Declaration
of
an
extern
class
procedure
natif
public
static
void
procedure1
(
)
;
/
/
Declaration
of
an
extern
instance
procedure
natif
public
void
procedure2
(
)
;
/
/
test
procedure
public
static
void
main
(
string
[
]
argv
)
{
dns-remplacer
(
)
;
MyClass
o
=
new
MyClasse
(
)
;
o.procedure2
(
)
;
}
/
/
Load
the
library
libMyRoutines
static
{
dns-remplacer
(
`
`
MyRoutine
'
'
)
;
}
}
commentaire
:
-
modificateur
natif
indique
agir
de
procédure
externe
écrire
en
java
.
nom
de
procédure
être
arbitraire
.
-
méthode
loadLibrary
aller
charger
bibliothèque
dns-remplacé
;
mot
clé
static
encapsuler
bloc
de
instruction
dans
appel
être
réaliser
permettre
de
exécuter
bloc
dès
chargement
de
classe
MyClass
sans
avoir
besoin
de
passer
par
appel
de
méthode
intermédiaire
.
prototype
C
fichier
MyClass.h.
produit
par
javah
(
cf
étape
précédent
)
spécifier
prototype
devoir
respecter
sous-programme
C
à
écrire
.
contenir
(
expurger
)
fichier
MyClass.h.
produire
par
javah
/
*
do
NOT
EDIT
THIS
filer
-
it
is
machine
generated
*
/
/
*
Header
for
MYClass
*
/
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
(
JNIEnv
*
,
jclass
)
;
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
(
JNIEnv
*
,
jobject
)
;
commentaire
:
-
JNIEXPORT
JNICALL
être
deux
macros
prédéfinie
par
JNI
pour
faire
communiquer
java
C
-
void
spécifier
agir
de
procédure
-
Java_MyClass_procedure1
être
nom
imposé
devoir
porter
procédure
C
correspondant
à
méthode
de
nom
procedure1
déclarer
dans
programme
java
;
pour
procedure2
-
deux
paramètre
être
introduire
en
tête
de
liste
paramètre
:
o
premier
,
de
type
JNIEnv
*
,
être
pointeur
vers
environnement
JNIEnv
être
même
pointeur
vers
structure
contenir
fonction
de
interface
avec
machine
virtuel
java
(
JVM
)
;
o
second
,
de
type
jclass
agir
de
méthode
de
classe
jobject
agir
de
méthode
de
instance
,
être
pointeur
vers
descripteur
de
classe
de
objet
(
sorte
de
this
)
de
appel
implémentation
C
exemple
de
fichier
MyRoutines.c.
#
include
<
stdio.h.
>
#
include
`
`
MyClass.h.
'
'
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
(
JINIEnv
*
penv
,
jclass
cla
)
{
printf
(
`
`
routine
procedure1\n
'
'
)
;
}
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
(
JINIEnv
*
penv
,
jobject
obj
)
{
printf
(
`
`
routine
procedure2\n
'
'
)
;
}
Echange
de
donnée
entre
java
C
échange
de
donnée
entre
application
java
sous-programme
C
(
par
paramètre
résultat
de
fonction
)
supposer
compatibilité
type
correspondant
.
or
n
'
avoir
de
correspondance
systématique
naturel
entre
type
langage
java
type
langage
C
(
caractère
,
par
exemple
,
être
coder
sur
bit
en
java
sur
bit
en
C
)
.
JNI
définir
ensemble
de
type
en
C
(
de
nom
j
*
)
correspondre
type
de
java
.
JNI
traiter
type
primitif
type
objet
.
correspondance
type
primitif
être
direct
(
voir
tableau
ci-après
)
,
reposer
sur
représentation
machiner
donnée
identique
,
être
cas
pour
type
objet
.
transmission
de
chaîne
de
caractère
,
de
tableau
,
avoir
de
instance
quelconque
de
classe
,
être
direct
nécessiter
conversion
de
type
.
paramètre
java
de
type
objet
être
transmettre
sous-
programme
C
sous
forme
de
pointeur
sur
structure
de
donnée
interne
à
machine
virtuel
java
.
organisation
interne
de
structure
être
masquer
programmeur
pouvoir
accéder
composante
sous-jacent
via
fonction
utilitaire
offrir
par
JNI
dans
environnement
JNIEnv
.
type
primitif
java
typer
primitif
côté
C
description
boolean
jboolean
unsigned
bit
byte
jbyte
signed
bit
char
jchar
unsigned
bit
short
jshort
signed
bit
int
jint
signed
bit
long
jlong
signed
bit
float
jfloat
bit
double
jdoubler
bit
par
suite
,
considèrera
de
bout
en
bout
même
exemple
.
déclaration
appel
java
exemple
de
classe
java
public
class
MyClass
{
/
/
Declaration
of
an
extern
instance
function
natif
public
string
getMessage
(
int
id
,
string
prompt
)
;
/
/
test
procedure
public
static
void
main
(
string
[
]
argv
)
{
MyClass
o
=
new
MyClasse
(
)
;
dns-remplacer
(
o.getMessage
(
,
`
`
Name
:
`
`
)
)
;
}
/
/
Load
the
library
libMyRoutines
static
{
dns-remplacer
(
`
`
libMyRoutine
'
'
)
;
}
}
prototype
C
contenu
(
expurger
)
fichier
MyClass.h.
produire
par
javah
/
*
do
NOT
EDIT
THIS
filer
-
it
is
machine
generated
*
/
/
*
Header
for
MYClass
*
/
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
(
INIEnv
*
,
jobject
,
jint
,
jstring
)
;
implémentation
C
exemple
de
fichier
MyRoutines.c.
#
include
<
stdio.h.
>
#
include
`
`
MyClass.h.
'
'
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
(
JINIEnv
*
penv
,
jobject
obj
,
jint
jid
,
jstring
jprompt
)
;
{
const
char
*
str
;
char
buf
[
]
;
/
*
Get
the
C
string
from
the
java
string
*
/
str
=
(
*
penv
)
-
>
GetStringUTFChars
(
penv
,
jprompt
,
NULL
)
;
printf
(
`
`
%
d
-
%
s
'
'
,
jid
,
str
)
;
/
*
do
t
forget
this
line
!
!
!
*
/
(
*
penv
)
-
>
ReleaseStringUTFChars
(
penv
,
jprompt
,
str
)
;
/
*
assumer
the
user
does
t
type
more
than
char
*
/
scanf
(
`
`
%
s
'
'
,
buf
)
;
return
(
*
penv
)
-
>
NewStringUTF
(
penv
,
buf
)
;
}
commentaire
:
-
représentation
physique
chaîne
de
type
jstring
de
type
char
*
être
identique
.
conversion
devoir
être
réaliser
.
être
rôle
fonction
GetStringUTFChars
NewStringUTF
.
à
noter
,
dans
cas
,
conversion
caractère
codables
en
ASCII
bit
(
lettre
accentué
,
...
)
poser
problème
.
-
fonction
GetStringUTFChars
réaliser
allocation
mémoire
dynamique
,
désallocation
devoir
être
réaliser
avant
fin
sous-
programme
:
être
rôle
de
fonction
ReleaseStringUTFChars
annexe
-
PLATES-FORMES
java
référence
:
java
Platform
,
standard
Edition
,
api
Specification
:
dns-remplacer
/
javase
/
/
doc
/
api
/
New
features
and
Enhancements
J2SE
:
dns-remplacer
/
j2se
/
/
doc
/
relnote
/
dns-remplacer
java
Platform
,
standard
Edition
:
dns-remplacer
/
javase
/
java
Platform
,
Enterprise
Edition
:
dns-remplacer
/
javaee
/
java
Platform
,
micro
Edition
:
dns-remplacer
/
javame
/
JDK
Tools
and
Utilities
:
dns-remplacer
/
javase
/
/
doc
/
technote
/
tools
/
Sun
Microsystems
fournir
trois
plates-formes
java
permettre
développement
exécution
de
programme
java
:
java
(
standard
de
base
)
,
java
EE
java
.
à
noter
nom
être
employé
pour
version
sortir
depuis
:
,
plates-
forme
être
nommer
J2SE
,
J2EE
J2ME
.
java
Platform
,
standard
Edition
(
java
)
.
plate-forme
être
framework
java
de
base
permettre
de
développer
/
exécuter
programme
java
.
dernier
version
nommer
J2SE
être
version
porter
nom
J2SE
:
être
à
souligner
version
apporter
mise
à
jour
majeur
par
rapport
à
précédent
.
version
actuel
récent
date
de
décembre
:
être
version
porter
nom
java
.
version
(
java
)
être
annoncer
nouveau
mise
à
jour
majeur
,
à
mi
,
être
attendre
.
plate-forme
java
délivrer
deux
produit
logiciel
principal
:
java
Runtime
Environment
(
JRE
)
,
fournir
librairie
,
machine
java
virtuel
de
autre
composante
nécessaire
pour
exécuter
programme
java
.
java
Development
kit
(
JDK
)
,
inclure
JRE
outil
de
développement
,
compilateur
débogueur
,
nécessaire
utile
pour
développer
programme
java
.
à
noter
terme
JDK
,
populaire
,
être
devenir
imprécis
de
autre
plates-forme
java
(
java
EE
par
exemple
)
comporter
propre
kit
de
développement
.
java
Platform
,
Enterprise
Edition
(
java
EE
)
.
plate-forme
être
framework
java
destiner
application
de
entreprise
.
offrir
cadre
standard
pour
développer
application
distribuer
.
java
Platform
,
micro
Edition
(
java
)
.
plate-forme
être
framework
java
spécialiser
dans
application
mobile
.
plates-formes
java
compatibles
avec
J2ME
être
embarquer
dans
de
nombreux
téléphone
mobile
PDA
.
de
façon
spécifique
,
pouvoir
citer
plateforme
java
Card
(
fournir
environnement
pour
développement
de
application
sur
carte
à
puce
)
JavaFX
(
pour
créer
Rich
Internet
application
)
.
annexe
-
glossaire
trouver
sur
web
de
excellent
définition
en
anglais
terme
,
sigle
,
produire
de
référence
,
informatique
.
parmi
source
possible
,
citer
par
exemple
:
-
parmi
encyclopédie
:
dns-remplacer
(
version
anglais
être
complet
)
-
parmi
moteur
spécialiser
dans
recherche
dans
encyclopédie
,
dictionnaire
glossaire
:
dns-remplacer
glossaire
de
terme
sigle
général
courant
:
sigle
/
terme
définition
commentaire
api
application
Programming
bibliothèque
de
fonctionnalité
commun
,
interface
courant
de
bas
niveau
.
constituer
interface
entre
couche
bas
couche
applicatives
de
haut
niveau
.
exemple
:
dns-remplacer
/
javase
/
/
doc
/
api
/
spécifier
api
standard
de
java
fournir
dans
JDK
.
Framework
cadre
de
application
Ensemble
cohérent
de
classe
(
abstraire
)
de
interface
permettre
développement
rapide
de
application
.
fournir
de
brique
logicielles
pour
pouvoir
produire
application
aboutir
.
spécialiser
pour
type
de
application
.
gui
Graphical
user
interface
interface
homme-machine
graphique
,
par
opposition
à
interface
en
ligne
de
commande
.
IDE
Integrated
Development
programme
regrouper
ensemble
de
utilitaire
Environment
logiciel
pour
développement
de
programme
(
éditeur
de
texte
,
compilateur
,
débogueur
,
gestionnaire
de
version
,
aide
à
production
de
interface
,
...
)
.
dédier
à
seul
langage
de
programmation
.
JDK
java
Development
kit
(
voir
chapitre
)
JFC
java
Foundation
classe
cadre
de
application
graphique
.
ensemble
de
classe
java
permettre
de
construire
interface
utilisateur
graphique
portable
.
contenir
composant
swing
.
JRE
java
Runtime
Environment
(
voir
chapitre
)
J2EE
java
Platform
,
Enterprise
(
voir
chapitre
)
Edition
java
java
Platform
,
Enterprise
J2ME
java
Platform
,
micro
(
voir
chapitre
)
Edition
java
java
Platform
,
micro
Edition
J2SE
java
Platform
,
standard
(
voir
chapitre
)
Edition
java
java
Platform
,
standard
Edition
dans
cadre
de
application
professionnel
java
distribuer
:
sigle
/
terme
définition
commentaire
EJB
Enterprise
JavaBeans
technologie
java
,
offrir
par
plateforme
java
EE
,
permettre
de
créer
composant
distribuer
héberger
dans
serveur
de
application
.
dans
architecture
MVC
,
utiliser
pour
réaliser
modèle
.
dns-remplacer
/
products
/
ejb
/
JSP
java
Server
page
technologie
java
,
offrir
par
plateforme
java
EE
,
permettre
de
créer
page
Web
dynamique
.
dans
architecture
MVC
,
utiliser
pour
réaliser
vue
.
dns-remplacer
/
products
/
jsp
/
Servlet
technologie
java
,
offrir
par
plateforme
java
EE
,
permettre
de
étendre
fonctionnalité
de
serveur
Web
(
accès
à
base
de
donnée
,
transaction
d
'
e-commerce
,
...
...
)
.
dans
architecture
MVC
,
utiliser
pour
réaliser
contrôleur
.
dns-remplacer
/
products
/
servlet
/
