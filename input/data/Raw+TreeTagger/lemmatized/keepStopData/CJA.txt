le
langage
java
Petit
mémento
de
syntaxe
&
élément
de
programmation
site
de
REFERENCE
le
site
officiel
de
java
être
:
dns-remplacer
.
on
pouvoir
notamment
y
consulter
avec
intérêt
:
-
du
tutoriel
:
dns-remplacer
/
doc
/
books
/
tutorial
/
-
un
grand
collection
de
petit
exemple
de
programme
:
dns-remplacer
/
developer
/
codesamples
/
examplet
/
-
du
recommandation
de
style
:
dns-remplacer
/
doc
/
codeconv
/
html
/
dns-remplacer
-
le
descriptif
de
tout
le
paquetage
,
classe
et
méthode
standard
:
dns-remplacer
/
javase
/
/
doc
/
api
/
-
le
mode
de
emploi
du
générateur
de
documentation
javadoc
:
dns-remplacer
/
j2se
/
javadoc
/
dns-remplacer
-
un
préparation
à
le
certification
de
programmeur
java
:
dns-remplacer
/
doc
/
books
/
tutorial
/
extra
/
certification
/
sommaire
langage
et
programmation
orienter
objet
...
programme
java
...
...
.
style
de
programmation
Identificateurs
...
commentaire
...
...
commentaire
de
documentation
...
...
commentaire
de
implémentation
...
fichier
java
...
nom
et
contenir
de
un
fichier
java
...
...
compilation
,
exécution
,
génération
de
le
documentation
paquetage
...
paquetage
standard
...
...
affectation
de
un
classe
à
un
paquetage
...
...
importation
de
un
classe
de
un
paquetage
classe
et
interface
...
...
classe
standard
...
...
classe
abstraire
et
sous-classe
...
classe
abstrait
.
sous-classe
...
interface
...
...
interface
...
classe
implanter
un
interface
...
Enumération
...
...
...
...
...
...
classe
imbriquer
(
Nested
classe
)
...
contrôle
de
accès
par
le
modificateur
...
instance
de
classe
...
...
type
de
DONNEES
...
.
type
primitif
...
type
objet
(
ou
type
référence
)
.
.
.
classe
enveloppe
...
.
.
chaîne
de
caractère
non
modifiable
(
string
)
...
chaîne
de
caractère
modifiable
(
StringBuffer
)
...
...
...
...
...
...
...
...
.
.
tableau
...
...
collection
...
...
Transtypage
...
...
OPERATEURS
et
expression
...
...
opérateur
et
expression
arithmétique
...
opérateur
et
expression
booléen
...
opérateur
relationnel
...
METHODES
...
définition
et
appel
de
un
méthode
ordinaire
...
constructeur
...
...
méthode
main
...
...
...
...
...
.
instruction
...
...
instruction
de
affectation
...
...
instruction
de
contrôle
...
instruction
de
sélection
...
...
instruction
de
boucle
...
...
instruction
de
entrée
/
sortie
...
notion
de
flux
...
entrée
/
sortie
terminal
...
...
entrée
/
sortie
fichier
...
...
lecture
de
un
chaîne
de
caractère
formater
...
HERITAGE
...
...
.
notion
de
héritage
...
que
hériter
un
sous-classe
?
...
...
redéfinir
un
méthode
...
type
statique
/
dynamique
-
liaison
statique
/
dynamique
...
type
statique
/
dynamique
-
Transtypage
...
...
...
...
...
...
...
liaison
statique
/
dynamique
...
polymorphisme
...
...
classe
et
méthode
particulier
...
interface
...
...
exception
...
...
exception
contrôler
et
non
contrôler
...
classe
de
exception
standard
...
...
le
hiérarchie
Error
...
...
...
le
hiérarchie
exception
...
le
hiérarchie
RuntimeException
...
...
...
.
...
lancement
de
un
exception
...
...
capture
de
un
exception
...
...
...
clause
throws
...
instruction
try
.
.
catch
...
...
...
...
.
.
iii
définir
un
nouveau
classe
de
exception
...
annexe
-
programmation
graphique
...
swing
.
.
...
...
conteneur
et
composant
...
...
gestion
de
le
mise
en
page
...
...
gestion
du
événement
...
notion
de
événement
...
réaliser
un
gestionnaire
de
événement
...
...
...
...
...
affichage
/
fermeture
de
un
fenêtre
graphique
...
architecture
du
composant
swing
...
...
Applet
...
...
annexe
-
THREADS
...
...
créer
un
thread
par
extension
de
le
classe
Thread
...
créer
un
thread
par
implémentation
de
le
interface
Runnable
...
...
...
...
...
...
...
.
.
synchronisation
et
communication
entre
threads
...
section
critique
et
synchronisation
...
communication
entre
threads
...
...
annexe
-
conception
et
DEVELOPPEMENT
en
java
...
conseil
général
pour
un
bon
conception
du
classe
...
architecture
de
un
application
interactif
:
le
modèle
MVC
...
test
unitaire
...
...
définition
...
JUnit
...
...
...
.
java
Beans
...
...
design
pattern
...
...
exemple
:
le
modèle
singleton
...
...
exemple
:
le
modèle
Decorator
...
...
...
...
...
.
.
...
annexe
-
machine
virtuel
java
(
JVM
)
...
annexe
-
communication
entre
java
et
C
(
JNI
)
...
...
...
...
...
...
appel
de
un
procédure
C
...
déclaration
et
appel
java
.
...
prototype
C
...
Implémentation
C
...
...
Echange
de
donnée
entre
java
et
C
...
déclaration
et
appel
java
...
...
prototype
C
...
Implémentation
C
...
...
annexe
-
PLATES-FORMES
java
...
...
annexe
-
glossaire
...
...
langage
et
programmation
orienter
objet
java
[
]
être
un
langage
de
programmation
orienter
objet
.
un
objet
être
un
représentation
simplifier
de
un
entité
du
monde
réel
:
entité
concret
(
ex
:
mon
voiture
)
ou
non
(
ex
:
le
date
de
aujourd'hui
)
.
un
objet
se
caractériser
par
son
état
et
son
comportement
.
un
objet
stocker
son
état
dans
du
variable
appelé
champ
(
ou
attribut
)
et
présenter
son
comportement
au
travers
de
fonctionnalité
appelé
méthode
.
exemple
de
objet
:
maVoiture
=
{
valeur
du
attribut
:
Fiat
,
gris
,
/
100km
,
...
.
;
méthode
:
démarrer
,
arrêter
,
accélérer
,
...
.
}
typiquement
,
le
état
être
encapsuler
au
cœur
de
le
objet
et
ne
être
accessible
depuis
le
extérieur
de
le
objet
,
en
consultation
ou
modification
,
que
via
le
méthode
offrir
par
ce
objet
.
exemple
:
le
objet
maVoiture
getCouleur
setCouleur
démarrer
arrêter
accélérer
...
Fiat
griser
on
interagir
avec
un
objet
en
lui
envoyer
un
message
de
demande
de
activation
de
un
de
son
méthode
.
exemple
de
envoi
de
un
message
à
un
objet
:
dns-remplacer
élérer
(
)
;
un
méthode
particulier
,
appeler
constructeur
,
permettre
de
initialiser
le
état
de
le
objet
à
son
création
.
un
classe
servir
à
regrouper
sous
un
même
catégorie
et
un
même
nom
générique
le
objet
partager
le
même
type
de
état
et
le
même
comportement
.
un
classe
être
donc
un
type
de
objet
;
on
dire
réciproquement
que
un
objet
être
un
instance
de
classe
.
exemple
de
classe
:
automobile
=
{
attribut
:
marque
,
couleur
,
consommation
,
...
.
;
méthode
:
démarrer
,
arrêter
,
accélérer
,
...
.
}
le
classe
pouvoir
être
organiser
en
hiérarchie
.
chaque
classe
hériter
alors
du
attribut
et
méthode
du
classe
situer
sur
son
ligne
hiérarchique
ascendant
.
réaliser
un
programme
dans
un
langage
orienter
objet
,
ce
être
:
-
modéliser
par
du
classe
le
objet
que
la|le
on
avoir
à
manipuler
-
écrire
ce
classe
dans
le
langage
de
programmation
orienter
objet
-
créer
du
objet
instance
de
ce
classe
-
communiquer
avec
ce
objet
en
invoquer
leur
méthode
.
[
]
java
être
naître
en
dans
le
entreprise
californien
Sun
Microsystems
.
il
avoir
être
concevoir
par
James
GOSLING
&
al
.
programme
java
style
de
programmation
il
être
largement
admettre
que
le
respect
de
le
syntaxe
et
un
programme
qui
fonctionner
ne
être
pas
du
critère
de
qualité
suffisant
pour
un
programme
.
le
expérience
de
le
programmation
avoir
ainsi
conduire
à
établir
du
recommandation
de
style
.
la|le
respecter
ne
être
pas
techniquement
obligatoire
mais
contribuer
à
améliorer
le
lisibilité
du
programme
.
ce
convention
viser
en
faire
un
finalité
économique
:
contribuer
à
produire
du
programme
plus
facilement
maintenable
pendant
tout
leur
durée
de
vie
.
dans
le
chapitre
suivant
,
le
exemple
respecter
le
convention
de
style
préconiser
par
dns-remplacé
Identificateurs
quelque
règle
et
recommandation
pour
nommer
le
identificateurs
:
+
le
caractère
minuscule-majuscule
du
caractère
être
discriminant
(
règle
du
langage
java
)
+
le
identificateurs
de
objet
,
de
champ
et
de
méthode
commencer
toujours
par
un
minuscule
(
par
convention
)
+
le
identificateurs
de
classe
(
et
de
interface
)
commencer
toujours
par
un
majuscule
(
par
convention
)
+
le
identificateurs
de
constant
être
tout
en
majuscule
(
par
convention
)
+
le
identificateurs
de
méthode
commencer
par
un
verbe
(
recommandation
)
commentaire
commentaire
de
documentation
le
commentaire
de
documentation
viser
à
décrire
le
spécification
du
code
,
sans
considération
de
implémentation
.
il
être
destiner
à
du
développeur
et
utilisateur
qui
ne
avoir
pas
nécessairement
le
code
source
sous
le
main
.
ce
commentaire
pouvoir
être
automatiquement
extraire
par
le
utilitaire
javadoc
pour
en
constituer
un
fichier
de
documentation
en
HTML
.
le
documentation
de
un
classe
devoir
inclure
avoir
minima
:
-
le
nom
de
le
classe
,
son
fonctionnalité
et
son
grand
caractéristique
,
son
auteur
,
son
version
-
un
documentation
pour
chaque
constructeur
et
chaque
méthode
le
documentation
de
un
méthode
devoir
inclure
avoir
minima
:
-
le
nom
de
le
méthode
,
son
fonctionnalité
,
un
description
de
chaque
paramètre
et
de
le
valeur
retourner
,
le
exception
susceptible
de
être
lancer
par
ce
méthode
syntaxe
:
/
*
*
*
commentaire
*
/
/
*
*
commentaire
*
/
principal
balise
de
commentaire
prédéfini
:
@
author
@
version
@
param
@
return
@
see
@
throws
commentaire
de
implémentation
le
commentaire
de
implémentation
viser
à
expliciter
(
sans
paraphraser
)
le
code
et
le
choix
de
implémentation
.
le
choix
du
identificateurs
et
le
clarté
de
le
programmation
devoir
permettre
de
minimiser
le
nombre
de
tel
commentaire
.
syntaxe
:
/
*
*
commentaire
*
/
/
*
commentaire
*
/
/
/
commentaire
fichier
java
nom
et
contenir
de
un
fichier
java
+
chaque
fichier
source
java
contenir
un
seul
classe
publique
.
le
organisation
recommandé
être
le
suivant
:
)
le
commentaire
de
début
.
ce
être
un
commentaire
de
documentation
comprendre
typiquement
:
le
intitulé
de
le
classe
et
un
descriptif
sommaire
de
son
fonction
,
le
auteur
,
le
version
)
le
instruction
de
paquetage
)
le
instruction
de
import
)
le
déclaration
du
classe
+
un
fichier
devoir
contenir
moins
de
ligne
et
du
ligne
de
moins
de
caractère
,
voire
pour
le
commentaire
de
documentation
(
recommandation
)
+
un
fichier
java
porter
le
nom
de
le
classe
publique
que
il
contenir
;
le
fichier
source
java
avoir
pour
suffixe
.java
;
le
fichier
java
compiler
avoir
pour
suffixe
.class
(
par
convention
)
.
le
suffixe
.java
et
.class
être
imposer
par
le
outil
.
compilation
,
exécution
,
génération
de
le
documentation
depuis
le
ligne
de
commande
:
+
compilation
:
javac
dns-remplacer
+
exécution
:
java
fileName
/
/
fichier
du
main
+
génération
de
le
documentation
:
javadoc
*
.
java
pour
avoir
un
documentation
`
`
programmeur
`
`
complet
(
y
comprendre
le
membre
priver
)
de
tout
le
classe
et
de
leur
interaction
,
il
falloir
lancer
ce
commander
avec
le
option
-
private
.
paquetage
un
paquetage
(
package
en
anglais
)
être
un
bibliothèque
de
classe
organiser
de
façon
hiérarchique
.
le
nom
de
un
paquetage
être
nécessairement
le
nom
de
son
répertoire
.
le
nom
de
un
paquetage
être
toujours
en
lettre
minuscule
(
par
convention
)
.
différent
paquetage
pouvoir
être
rassembler
et
compacter
dans
un
fichier
de
archiver
.zip
ou
.jar
paquetage
standard
le
variable
de
environnement
CLASSPATH
indiquer
à
le
machine
virtuel
java
où
trouver
le
classe
et
bibliothèque
de
classe
dont
elle
avoir
besoin
.
hiérarchie
partiel
du
paquetage
standard
:
java
applet
awt
io
lang
util
event
paquetage
le
plus
immédiatement
utile
paquetage
contenir
dns-remplacé
classe
relatif
au
entrée
/
sortir
dns-remplacer
classe
fondamental
:
type
basique
(
classe
enveloppe
,
string
,
StringBuffer
,
...
...
)
,
classe
math
,
...
dns-remplacé
classe
utilitaire
divers
:
collection
(
ArrayList
,
Vector
,
...
)
,
classe
Random
,
gestion
du
date
et
du
heure
,
...
affectation
de
un
classe
à
un
paquetage
pour
que
un
classe
appartenir
à
un
paquetage
,
il
falloir
déclarer
le
paquetage
de
appartenance
en
tête
de
fichier
source
.
syntaxe
:
package
packageName
;
importation
de
un
classe
de
un
paquetage
pour
utiliser
un
classe
définir
dans
un
paquetage
autre
que
celui
de
le
classe
de
utilisation
,
ce
classe
devoir
être
importer
en
tête
de
fichier
source
.
syntaxe
:
import
dns-remplacer
;
import
packageName
.
*
;
/
/
former
déconseiller
car
peu
informatif
exemple
:
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacé
.
*
;
/
/
former
déconseiller
car
peu
informatif
le
paquetage
dns-remplacé
être
importer
automatiquement
.
classe
et
interface
classe
standard
syntaxe
:
public
class
ClassName
{
Fields
Constructors
Methods
/
/
accessor
methods
...
/
/
mutator
methods
...
}
exemple
:
/
*
*
*
class
RationalNumber
-
Represents
avoir
rational
number
num
/
den
*
*
@
author
AM
*
@
version
*
*
/
public
class
RationalNumber
{
/
/
FIELDS
private
int
numerator
;
private
int
denominator
;
private
boolean
reduced
;
/
/
CONSTRUCTORS
/
*
*
Construct
avoir
rational
number
initialized
to
/
*
/
public
RationalNumber
(
)
{
numerator
=
;
denominator
=
;
reduced
=
true
;
}
/
/
METHODS
-
ACCESSORS
/
*
*
Get
the
numerator
of
this
rational
number
*
/
public
int
getNumerator
(
)
{
return
numerator
;
}
/
*
*
Get
the
denominator
of
this
rational
number
*
/
public
int
getDenominator
(
)
{
return
denominator
;
}
/
*
*
Return
true
iff
the
numerator
/
denominator
form
is
irreducible
*
/
public
boolean
isReduced
(
)
{
return
reduced
;
}
/
/
METHODS
-
MUTATORS
/
*
*
set
this
rational
number
to
_numerator
/
_denominator
*
/
public
void
setNumber
(
int
_numerator
,
int
_denominator
)
{
numerator
=
_numerator
;
denominator
=
_denominator
;
reduced
=
false
;
}
/
*
*
set
this
rational
number
to
avoir
irreducible
*
numerator
/
denominator
form
*
/
public
void
reduce
(
)
{
int
divisor
=
greatestCommonDivisor
(
numerator
,
denominator
j
)
;
numerator
=
numerator
/
divisor
;
denominator
=
denominator
/
divisor
;
reduced
=
true
;
}
/
/
METHODS
-
UTILITIES
/
*
*
Return
the
greatest
common
divisor
of
the
two
integers
*
x
and
y
*
/
private
int
greatestCommonDivisor
(
int
x
,
int
y
)
{
int
divisor
;
/
/
...
à
implémenter
...
return
divisor
;
}
}
/
/
end
class
RationalNumber
classe
abstraire
et
sous-classe
un
classe
qui
posséder
au
moins
un
méthode
abstrait
(
i.e.
.
sans
corps
)
être
abstraire
et
devoir
être
déclarer
avec
le
modificateur
abstract
.
le
classe
abstrait
ne
pouvoir
pas
être
instanciées
.
pour
pouvoir
créer
du
objet
,
il
falloir
créer
un
sous-classe
dans
lequel
tout
le
méthode
abstrait
être
définir
:
ce
sous-
classe
,
non
abstraire
,
pouvoir
alors
être
instanciée
.
classe
abstraire
syntaxe
:
public
abstract
class
ClassName
{
Fields
Constructors
Methods
}
exemple
:
/
*
*
*
abstract
class
progression
*
*
Represents
avoir
real
linear
progression
of
order
with
constant
*
coefficient
*
*
@
author
AM
*
@
version
*
/
public
abstract
class
progression
{
/
/
FIELDS
private
double
u0
;
/
/
the
first
term
of
the
progression
/
/
CONSTRUCTORS
/
*
*
Define
avoir
progression
,
the
first
term
of
which
is
u0
*
/
public
progression
(
double
u0
)
{
dns-remplacer
=
u0
;
}
/
/
METHODS
/
*
*
Get
the
first
term
of
this
progression
*
/
public
double
getu0
(
)
{
return
u0
;
}
/
*
*
Given
à
current
term
u
(
n
)
,
return
the
next
term
u
(
n+1
)
*
/
public
abstract
double
nextTerm
(
double
un
)
;
/
*
*
Return
the
term
of
rank
n
*
/
public
double
termOfRank
(
int
n
)
{
double
u
=
u0
;
/
/
u
(
n
)
double
v
;
/
/
u
(
n+1
)
for
(
int
i
=
;
i
<
=
n
;
i++
)
{
v
=
nextTerm
(
u
)
;
u
=
v
;
}
return
u
;
}
}
/
/
end
class
progression
sous-classe
syntaxe
:
public
class
SubclassName
extends
SuperclassName
{
Fields
Constructors
Methods
}
exemple
:
/
*
*
*
class
ArithGeomProgression
*
*
Represents
avoir
real
arithmetic-geometric
progression
with
constant
*
coefficient
:
u
(
n+1
)
=
avoir
*
u
(
n
)
+
b
*
*
@
author
AM
*
@
version
*
/
public
class
ArithGeomProgression
extends
progression
{
/
/
FIELDS
private
double
avoir
;
/
/
multiplying
coefficient
private
double
b
;
/
/
additif
coefficient
/
/
CONSTRUCTORS
/
*
*
Define
an
arithmetic-geometric
progression
*
@
param
u0O
first
term
of
the
progression
*
@
param
avoir
multiplying
coefficient
*
@
param
b
additif
coefficient
*
/
public
ArithGeomProgression
(
double
u0
,
double
avoir
,
double
b
)
{
super
(
u0
)
;
this.a.
=
avoir
;
this.b.
=
b
;
}
/
/
METHODS
/
*
*
Given
à
current
term
u
(
n
)
,
return
the
next
term
u
(
n+1
)
*
/
public
double
nextTerm
(
double
u
)
{
return
avoir
*
u
+
b
;
}
}
/
/
end
class
ArithGeomProgression
interface
remarquer
liminaire
.
le
terme
`
`
interface
`
`
avoir
un
sémantique
multiple
.
dans
le
cadre
de
le
programmation
en
java
,
il
pouvoir
prendre
,
selon
le
contexte
,
trois
sens|sen
distinct
(
même
si
conceptuellement
apparenter
)
:
-
au
sens|sen
informatique
commun
:
un
interface
être
un
`
`
jonction
entre
deux
élément
(
matériel
ou
logiciel
)
permettre
le
échange
de
information
`
`
;
par
exemple
,
le
interface
homme-machine
.
-
au
sens|sen
programmation
objet
:
le
interface
de
un
classe
être
le
partie
visible
publique
de
ce
classe
;
elle
se
définir
typiquement
par
le
liste
du
membre
(
attribut
,
constructeur
,
méthode
)
non
priver
associer
à
leur
commentaire
de
documentation
-
au
sens|sen
spécifique
du
langage
java
:
un
interface
être
un
sorte
de
classe
abstrait
posséder
du
caractéristique
particulier
et
qui
définir
un
protocole
de
comportement
;
ce
être
le
sens|sen
qui
être
définir
dans
ce
section
.
ce
être
son
contexte
de
utilisation
qui
donner
sens|sen
au
mot
interface
.
le
interface
(
au
sens|sen
du
langage
java
)
être
du
sorte
de
classe
abstraire
sans
aucun
détail
de
implémentation
et
qui
posséder
un
degré
de
abstraction
supérieur
à
celui
du
classe
abstrait
.
le
interface
:
-
avoir
du
méthode
qui
être
tout
implicitement
abstraire
(
elle
ne
avoir
pas
de
corps
)
-
à
noter
que
il
ne
être
pas
recommander
de
ajouter
le
modificateur
abstract
puisqu'il
être
implicite
;
-
ne
posséder
pas
de
champ
,
à
le
exception
éventuel
de
constant
de
classe
(
implicitement
static
final
)
assigner
;
-
son
membre
être
implicitement
public
si
le
interface
être
publique
.
un
interface
spécifier
le
signature
minimal
de
un
classe
qui
le
implémente
.
un
interface
être
donc
un
contrat
à
respecter
.
quand
un
classe
implémentir
un
interface
,
elle
se
engager
à
se
conformer
à
ce
interface
.
un
classe
pouvoir
implémenter
plusieurs
interface
.
un
classe
définir
un
type
et
son
implémentation
;
un
interface
définir
un
type
sans
son
implémentation
.
interface
syntaxe
:
public
interface
InterfaceName
{
constantAttribute
abstractMethods
}
exemple
:
public
interface
Measurable
{
double
size
(
)
;
/
*
*
@
return
,
,
if
this
is
<
,
=
or
>
than
x
*
/
int
isLargerThan
(
Measurable
x
)
;
}
classe
implanter
un
interface
syntaxe
:
public
class
ClassName
implements
InterfaceNamel
,
InterfaceName2
,
...
{
...
}
exemple
:
public
class
square
implements
Measurable
{
private
double
width
;
public
square
(
double
_width
)
{
width
=
_width
;
}
public
double
size
(
)
{
return
width
*
width
;
}
public
int
isLargerThan
(
Measurable
x
)
{
if
(
dns-remplacer
(
)
<
x.size
(
)
)
{
return
;
}
if
(
dns-remplacer
(
)
>
x.size
(
)
)
{
return
;
}
return
;
}
}
Enumération
un
classe
enum
permettre
de
représenter
un
ensemble
de
constante
nommé
dont
le
type
être
le
classe
elle
même
.
ce
classe
contribuer
à
accroître
le
lisibilité
du
programme
.
syntaxe
:
public
enum
EnumName
{
/
/
List
of
named
constant
.
/
/
Possibility
of
other
fields
and
methods
.
}
exemple
:
public
enum
direction
{
NORTH
,
SOUTH
,
EAST
,
WEST
;
}
public
class
test
{
private
direction
dir
;
public
setDir
(
direction
d
)
{
dir
=
d
;
}
public
boolean
isNorthSouth
(
)
{
return
(
dir
=
=
dns-remplacé
)
|
|
(
dir
=
=
dns-remplacer
)
;
}
}
sous
leur
forme
le
plus
simple
,
le
classe
enum
être
souvent
utiliser
sous
le
forme
de
un
classe
interne
(
inner
class
)
.
exemple
:
public
class
MyClass
{
private
direction
dir
;
...
private
enum
direction
{
NORTH
,
SOUTH
,
EAST
,
WEST
;
}
public
void
setNorth
(
)
{
dir
=
dns-remplacer
;
}
...
}
-
il
être
possible
de
associer
à
chaque
constante
énumérer
un
valeur
de
un
type
quelconque
-
il
être
possible
de
utiliser
un
type
énumérer
dans
un
instruction
switch
classe
imbriquer
(
Nested
classe
)
ce
concept
ne
être
pas
vital
pour
un
débutant
.
un
classe
pouvoir
être
définir
à
le
intérieur
de
un
autre
classe
.
on
parler
alors
de
classe
imbriqué
.
on
en
distinguer
quatre
catégorie
:
-
le
classe
membrer
déclarer
static
(
static
nested
classe
)
:
membre
statique
de
le
classe
englobant
;
-
le
classe
interne
(
inner
classe
)
:
membre
non
statique
de
le
classe
englobant
;
-
le
classe
local
(
local
classe
)
:
classe
définir
à
le
intérieur
de
un
méthode
;
-
le
classe
anonyme
(
anonymous
classe
)
:
classe
local
sans
nom
.
exemple
:
public
class
OuterClass
{
...
public
static
class
StaticNestedClass
{
...
}
private
class
InnerClass
{
...
}
}
/
/
exemple
de
référence
à
le
classe
StaticNestedClass
:
/
/
dns-remplacer
quel
intérêt
peut-il
y
avoir
à
déclarer
du
classe
imbriqué
?
potentiellement
un
regroupement
logique
,
un
encapsulation
accroître|accroire
,
un
code
plus
lisible
et
plus
facilement
maintenable
.
en
pratique
,
le
plupart
du
classe
imbriqué
être
du
classe
interne
.
quant
au
classe
anonyme
,
elle
pouvoir
rendre
le
code
difficile
à
lire
et
devoir
donc
être
limiter
à
du
classe
très
petit
(
de
un
ou
deux
méthode
)
:
voir
exemple
typique
en
section
.
contrôle
de
accès
par
le
modificateur
le
contrôle
de
accès
à
un
membre
de
un
classe
pouvoir
être
préciser
dans
leur
déclaration
par
du
mots-clé
appeler
modificateur
.
ce
modificateur
permettre
de
spécifier
:
-
le
visibilité
du
champ
ou
de
le
méthode
:
private
,
protected
ou
public
-
le
lieu
de
stockage
:
dans
le
classe
(
modificateur
static
)
ou
dans
le
objet
(
par
défaut
)
-
le
caractère
modifiable
(
par
défaut
)
ou
non
(
modificateur
final
)
modificateur
*
commentaire
et
exemple
private
un
membre
déclarer
private
ne
être
accessible
qu
'
à
le
intérieur
de
son
classe
de
définition
.
modificateur
de
accès
recommander
pour
le
champ
.
protected
un
membre
déclarer
protected
ne
être
accessible
que
depuis
son
classe
de
déclaration
,
un
sous-classe
,
ou
un
classe
du
même
paquetage
.
modificateur
de
accès
recommander
pour
le
méthode
du
super-
classe
.
public
un
membre
déclarer
public
être
accessible
depuis
ne
importer
quel
classe
.
modificateur
de
accès
recommander
pour
le
méthode
static
un
champ
déclarer
static
être
un
variable
de
classe
et
ne
être
pas
dupliquer
dans
le
différent
instance
;
un
champ
non
static
être
un
variable
de
instance
et
être
dupliquer
dans
chaque
instance
.
un
méthode
déclarer
static
être
un
méthode
de
classe
et
être
invoquer
sans
référence
à
un
objet
particulier
mais
en
faire
référence
à
son
classe
;
un
méthode
non
static
être
un
méthode
de
instance
et
être
invoquer
sur
un
objet
particulier
voir
également
chapitrer
@ord@
final
un
variable
déclarer
final
ne
pouvoir
plus
être
modifier
après
que
elle
avoir
être
initialiser
.
cela
permettre
en
particulier
de
déclarer
du
champ
constant
.
exemple
:
final
int
SIZE
=
;
un
méthode
déclarer
final
ne
pouvoir
pas
être
redéfinir
dans
un
sous-classe
.
un
classe
déclarer
final
ne
pouvoir
pas
être
sous-classer
.
*
nota
:
à
défaut
de
modificateur
private
,
protected
ou
public
,
le
visibilité
être
dire
'
'
package
access
`
`
:
le
membre
de
le
classe
être
visible
depuis
tout
le
classe
du
même
paquetage
.
exemple
:
public
static
final
double
GRAVITY
=
;
instance
de
classe
avant
de
pouvoir
être
utiliser
,
un
objet
-
ou
instance
de
classe
-
devoir
être
:
)
déclarer
ClassName
objectName
;
)
créer
puis
initialiser
objectName
=
new
constructorCall
;
exemple
:
GregorianCalendar
cal
;
cal
=
GregorianCalendar
(
)
;
Timer
myTimer
=
new
Timer
(
)
;
le
déclaration
de
un
objet
ne
créer
pas
le
objet
mais
uniquement
un
variable
pointeur
destiner
à
mémoriser
le
adresse
futur
de
le
objet
!
le
création
de
le
objet
en
lui
même
(
i.e.
.
le
instance
proprement
dit
)
être
réaliser
par
le
opérateur
new
.
le
appel
au
constructeur
qui
suivre
le
opérateur
new
avoir
pour
rôle
de
initialiser
proprement
le
objet
ainsi
créer
.
in
fine
,
le
adresse
de
le
objet
ainsi
créer
et
initialiser
,
adresse
renvoyer
par
le
opérateur
new
,
être
stocker
,
grâce
à
le
opérateur
de
affectation
=
,
dans
le
variable
préalablement
déclarer
.
quelque
précision
important
:
*
déclaration
.
le
déclaration
ClassName
objectName
;
créer
un
variable
de
nom
objectName
de
type
référence
(
i.e.
.
un
pointeur
)
et
la|le
initialiser
automatiquement
à
null
.
null
être
un
constant
littéral
prédéfinie
de
java
qui
pouvoir
être
assigner
à
tout
variable
de
type
référence
et
qui
identifier
un
pointeur
nul
.
un
variable
de
valeur
null
ne
poindre
vers
aucun
objet
.
tout
tentative
de
référer
à
un
objet
à
partir
de
un
pointeur
null
engendrer
un
erreur
(
de
compilation
ou
de
exécution
selon
le
contexte
)
.
*
gestion
dynamique
de
le
mémoire
.
le
opérateur
new
créer
le
instance
de
classe
dans
un
zone
mémoire
général
appeler
`
`
tas
`
`
qui
contenir
tout
le
donnée
allouer
à
le
exécution
et
ne
avoir
pas
de
portée
local
.
le
objet
ainsi
créer
conserver
donc
un
portée
global
et
rester
`
`
vivant
`
`
tant
que
on
disposer
de
un
référence
(
i.e.
.
un
pointeur
)
permettre
d
'
y
accéder
.
quand
un
objet
ne
être
plus
référencer
,
il
devenir
définitivement
inaccessible
et
'
'
mourir
`
`
:
son
espace
mémoire
être
automatiquement
désallouer
(
le
récupération
automatique
de
ce
espace
mémoire
être
réaliser
par
un
processus
appeler
ramasse-miettes
(
garbage
collector
)
)
.
un
façon
de
détruire
un
objet
être
donc
de
assigner
le
valeur
null
au
variable
qui
y
faire
référence
directement
ou
indirectement
.
type
de
DONNEES
java
connaître
deux
type
de
donnée
:
-
le
type
primitif
.
le
donnée
de
type
primitif
être
stocker
directement
dans
le
variable
et
avoir
un
sémantique
de
valeur
(
i.e.
.
ce
être
le
valeur
qui
être
copier
quand
un
variable
être
affecter
à
un
autre
variable
)
.
-
le
type
objet
(
ou
type
référence
)
.
le
donnée
de
type
objet
être
stocker
sous
forme
de
référence
à
ce
objet
(
et
non
pas
en
tant
que
objet
même
)
.
quand
un
variable
de
type
objet
être
affecter
à
un
autre
variable
,
seul
le
référence
être
copier
,
pas
le
objet
lui
même
.
java
utiliser
le
système
Unicode-4
,
en
interne
,
pour
coder
le
caractère
,
le
chaîne
de
caractère
et
le
identificateurs
.
chaque
caractère
Unicode
être
coder
sur
bit
,
ce
qui
permettre
de
représenter
de
nombreux
alphabet
(
grec
,
cyrillique
,
hébreu
,
arabe
,
...
)
ainsi
que
le
symbole
mathématique
et
technique
.
bien
que
Unicode
être
utiliser
par
certain
système
de
exploitation
(
Windows
NT
ou
Vista
par
exemple
)
,
le
plupart
du
système
de
exploitation
utiliser
du
système
de
codage
bit
,
de
sorte
que
du
transcodage
être
nécessaire
et
du
problème
de
incompatibilité
pouvoir
survenir
à
le
affichage
.
type
primitif
typer
description
exemple
de
littéral
nombre
entier
:
type
signé
:
byte
octet
(
entier
bit
)
short
entier
court
(
bit
)
int
entier
(
bit
)
long
entier
long
(
bit
)
5123456789L
-55L
nombre
réel
:
type
signer
:
float
réel
simple
précision
43.889F
341.159E-2F
double
réel
double
précision
-2.4E107
autre
type
:
type
non
signer
:
char
caractère
(
un
seul
;
bit
)
'
?
'
'
\u00F6
'
boolean
valeur
booléen
false
true
+
un
nombre
sans
point
décimal
être
interpréter
comme
un
entier
de
type
int
mais
immédiatement
convertir
en
byte
,
short
ou
long
lors
de
le
affection
.
on
pouvoir
déclarer
un
littéral
de
type
long
en
le
affecter
du
suffixe
L
.
+
un
nombre
avec
un
point
décimal
être
interpréter
comme
un
réel
de
type
double
.
on
pouvoir
déclarer
un
littéral
de
type
float
en
le
affecter
du
suffixe
F
.
+
un
caractère
littéral
pouvoir
être
écrire
sous
forme
de
un
unique
caractère
Unicode
entre
apostrophe
ou
de
un
valeur
Unicode
précéder
par
'
\u
'
.
+
le
deux
littéral
booléen
être
true
et
false
.
+
le
variable
de
un
type
primitif
ne
référer
pas
à
du
objet
,
elle
ne
avoir
pas
de
méthode
associer
.
type
objet
(
ou
type
référence
)
tout
le
type
autre
que
le
type
primitif
être
du
type
objet
.
il
inclure
le
classe
(
non
abstraire
)
du
bibliothèque
standard
java
(
tel
que
le
type
string
,
par
exemple
)
ainsi
que
le
classe
définir
par
le
utilisateur
.
un
variable
de
un
type
objet
contenir
un
référence
(
ou
pointeur
)
sur
ce
objet
.
le
affectation
et
passage
de
paramètre
avoir
un
sémantique
de
référence
(
i.e.
.
ce
être
le
référence
qui
être
copier
et
non
le
objet
lui
même
)
.
après
le
affectation
de
un
variable
à
un
autre
,
le
deux
variable
référer
au
même
objet
:
il
se
agir
donc
de
un
copie
de
surface
(
par
opposition
à
un
copie
profond
qui
dupliquer
le
objet
)
.
le
deux
variable
être
alors
dire
alias
pour
le
même
objet
.
classe
envelopper
le
classe
enveloppe
permettre
de
transformer
un
type
simple
en
objet
(
ce
opération
être
appeler
,
en
anglais
,
boxing
)
.
classe
envelopper
type
primitif
Boolean
boolean
Byte
byte
Character
char
double
double
Float
float
Integer
int
long
long
short
short
exemple
:
/
/
convert
primitif
type
>
wrapper
type
Integer
k
=
new
Integer
(
)
;
/
/
convert
wrapper
type
>
primitif
type
double
x
=
K.doubleValue
(
)
;
le
classe
enveloppe
être
utile
quand
un
méthode
ne
accepter
pas
le
type
simple
mais
requérir
du
objet
.
toutefois
,
depuis
le
plate-forme
(
voir
chapitre
)
,
le
valeur
de
type
primitif
être
,
en
cas
de
besoin
,
implicitement
convertir
en
le
objet
de
le
classe
envelopper
correspondant
(
autoboxing
)
,
et
réciproquement
(
unboxing
)
.
auparavant
,
le
conversion
devoir
être
explicite
.
le
objet
de
tel
classe
être
immuable
(
immutable
)
,
ce
est-à-dire
non
modifiable
un
fois
créer
.
en
conséquence
,
un
méthode
ne
pouvoir
pas
avoir
de
paramètre
de
sortie
de
tel
type
.
le
classe
enveloppe
présenter
surtout
le
intérêt
de
offrir
du
méthode
de
conversion
typer
primitif
<
-
>
string
,
ainsi
que
du
utilitaire
pour
du
donnée
de
type
primitif
.
exemple
:
/
/
Convert
string
type
-
>
primitif
type
double
x
=
dns-remplacer
(
`
`
`
`
)
;
chaîne
de
caractère
non
modifiable
(
string
)
bien
que
le
chaîne
de
caractère
de
type
string
être
du
objet
,
il
ne
être
pas
nécessaire
de
avoir
recours
à
le
opérateur
new
pour
la|le
créer
.
le
caractère
de
un
chaîne
de
caractère
chaine
être
indicer
de
à
dns-remplacé
(
)
un
chaîne
de
caractère
littéral
être
noter
entre
apostrophe
.
le
opérateur
+
être
le
opérateur
de
concaténation
de
chaîne
.
il
produire
un
nouveau
chaîne
sans
élément
physiquement
partager
avec
son
opérande
.
le
comparaison
de
deux
chaîne
(
caractère
par
caractère
)
nécessiter
de
faire
appel
à
le
fonction
equals
(
)
,
le
opérateur
=
=
ne
donner
le
résultat
intuitivement
attendre
que
dans
un
cas
particulier
.
le
objet
de
type
string
être
immuable
(
immutable
)
,
ce
est-à-dire
non
modifiable
un
fois
créer
.
en
conséquence
,
un
méthode
ne
pouvoir
pas
avoir
de
paramètre
de
sortie
de
type
string
.
le
classe
string
appartenir
au
paquetage
dns-remplacé
exemple
:
string
chaine
=
`
`
exemple
n
°
'
'
+
+
`
`
de
chaine
littéral
'
'
;
dns-remplacer
(
`
`
longueur
de
\
'
'
'
'
+
chainer
+
`
`
\
'
'
=
'
'
+
dns-remplacer
(
)
)
;
chaîne
de
caractère
modifiable
(
StringBuffer
)
ce
chaîne
de
caractère
,
contrairement
au
chaîne
de
type
string
,
pouvoir
être
modifier
.
le
opérateur
new
être
indispensable
pour
créer
un
chaîne
de
type
StringBuffer
.
le
classe
StringBuffer
appartenir
au
paquetage
dns-remplacé
exemple
:
StringBuffer
chaine
;
chaine
=
new
StringBuffer
(
`
`
meeting
at
pm
!
'
'
)
;
dns-remplacer
(
,
'
'
)
;
/
/
meeting
at
and
not
!
dns-remplacer
(
chaine
)
;
tableau
un
tableau
être
un
collection
de
taille
fixe
de
élément
de
même
type
.
chaque
élément
être
repérer
par
son
indice
qui
permettre
un
accès
direct
à
le
élément
.
à
tout
tableau
être
automatiquement
associer
un
classe
dériver
de
Object
et
partager
par
tout
le
tableau
avoir
le
même
type
de
élément
.
le
attribut
de
instance
length
(
qui
être
un
champ
public
et
non
un
méthode
)
contenir
le
nombre
de
élément
du
tableau
.
le
élément
de
un
tableau
array
être
indicer
de
à
dns-remplacé
-
quand
on
tenter
de
accéder
à
un
élément
dont
le
indice
être
hors
de
le
plage
permettre
,
un
exception
de
type
IndexOutOfBoundsException
être
lever
.
il
être
à
noter
que
un
tableau
de
caractère
ne
être
pas
un
objet
de
type
Siring
et
réciproquement
.
syntaxe
(
pour
le
cas
de
un
tableau
mono-dimensionnel
)
:
/
/
Declaring
an
array
variable
TypeOfElements
[
]
arrayVariable
;
/
/
Creating
an
array
object
arrayVariable
=
new
TypeOfElements
[
numberOfElements
]
;
/
/
Referring
to
an
element
arrayVariable
[
integerIndex
]
exemple
:
/
/
Declaring
an
array
variable
private
double
[
]
mark
;
/
/
Creating
an
array
object
static
final
int
NB_OF_STUDENTS
=
;
mark
=
new
double
[
NB_OF_STUDENTS
]
;
/
/
Using
an
array
object
for
(
int
=
;
<
dns-remplacer
;
i++
)
{
mark
[
i
]
=
dns-remplacer
(
)
*
;
dns-remplacer
(
`
`
mark
[
`
`
+
+
`
`
]
=
`
`
+
mark
[
i
]
)
;
}
exemple
:
static
final
int
NROW
;
static
final
int
NCOL
=
;
string
[
]
[
]
matrix
=
new
string
[
NROW
]
[
NCOL
]
;
il
être
possible
de
créer
et
de
initialiser
un
tableau
à
le
déclaration
.
exemple
:
int
[
]
t
=
{
,
,
,
}
;
dns-remplacer
(
t
[
]
+
`
`
`
`
+
t
[
]
)
;
/
/
string
[
]
[
]
s
=
{
{
`
`
monsieur
.
`
`
,
`
`
Mrs
.
`
`
,
`
`
Ms
.
`
`
}
,
/
/
row
{
`
`
Smith
'
'
,
`
`
Jones
'
'
}
/
/
row
}
;
dns-remplacer
(
s
[
]
[
]
+
s
[
]
[
]
)
;
/
/
Ms
.
Jones
le
classe
dns-remplacé
offrir
divers
méthode
utilitaire
applicable
à
du
tableau
(
comparaison
,
tri
,
...
...
)
.
depuis
le
plate-forme
(
voir
chapitre
)
,
java
offrir
un
boucle
for
simplifier
pour
parcourir
le
élément
de
un
tableau
.
exemple
:
/
/
for
each
element
of
my
array
of
double
,
print
this
element
for
(
double
e
:
myArrayOfDoubles
)
{
dns-remplacer
(
e
)
;
}
collection
un
collection
être
un
objet
représenter
un
groupe
de
objet
.
un
collection
être
un
agrégat
qui
regrouper
du
élément
multiple
en
un
seul
entité
.
aucun
hypothèse
ne
être
faire
avoir
priori
sur
le
type
du
élément
,
ni
sur
le
ordre
du
élément
,
ni
sur
le
possibilité
de
élément
dupliquer
.
plus
formellement
,
en
java
,
un
collection
de
élément
de
type
E
être
un
classe
qui
implémente
le
interface
collection
<
E
>
.
le
paquetage
standard
dns-remplacé
offrir
un
variété
de
collection
(
collection
framework
)
qui
répondre
au
besoin
le
plus
fréquent
,
par
exemple
:
ArrayList
<
E
>
,
Vector
<
E
>
,
LinkedList
<
E
>
,
Stack
<
E
>
,
Hashtable
<
K
,
V
>
,
...
.
ip-remplacée
>
Généricité
ce
notion
ne
exister
en
java
que
depuis
le
plate-forme
(
voir
chapitre
)
.
ce
version
introduire
un
révision
majeur
par
rapport
à
le
précédent
,
notamment
en
matière
de
gestion
du
collection
.
le
apparition
de
type
générique
en
être
probablement
le
évolution
le
plus
marquant
.
le
généricité
permettre
de
communiquer
au
compilateur
le
type
du
élément
de
un
collection
au
moment
de
le
création
de
le
objet
et
non
pas
en
le
fixer
avoir
priori
dans
le
définition
de
classe
.
exemple
de
classe
générique
:
/
/
Defining
avoir
generic
collection
.
/
/
The
formal
parameter
T
is
the
generic
type
of
the
elements
.
public
class
MyCollection
<
T
>
implements
List
<
T
>
{
...
/
/
T
can
be
used
here
avoir
any
type
...
}
/
/
Creating
avoir
collection
of
Integers
MyCollection
<
Integer
>
collectionOfIntegers
;
CollectionOfIntegers
=
new
MyCollection
<
Integer
>
(
)
;
/
/
Creating
avoir
collection
of
string
MyCollection
<
string
>
collectionOfString
;
CollectionOfStrings
=
new
MyCollection
<
string
>
(
)
;
tout
comme
le
déclaration
de
type
pouvoir
être
générique
,
le
déclaration
de
méthode
pouvoir
être
aussi
générique
,
ce
est-à-dire
paramétrisées
par
un
ou
plusieurs
paramètre
.
exemple
de
méthode
générique
:
/
/
Defining
public
static
<
T
>
void
fromArrayToCollection
(
T
[
]
avoir
,
collection
<
T
>
c
)
{
for
(
T
o
:
avoir
)
{
c.add
(
o
)
;
}
}
/
/
Using
it
string
[
]
a1
=
{
`
`
datal
'
'
,
`
`
data2
'
'
,
`
`
data3
'
'
,
`
`
data4
'
'
,
`
`
data5
'
'
}
;
collection
<
Object
>
c1
=
new
ArrayList
<
string
>
(
)
;
fromArrayToCollection
(
a1
,
c1
)
;
nota
.
il
être
à
signaler
que
le
tableau
et
le
générique
ne
faire
pas
encore
bon
ménage
!
exemple
:
Vector
<
Integer
>
[
]
sheets
=
new
Vector
<
Integer
>
[
NBOFSHEETS
]
;
produire
le
erreur
classique
`
`
Generic
array
creation
'
'
.
dans
ce
exemple
,
un
solution
pouvoir
consister
à
passer
par
un
classe
intermédiaire
simplement
définir
par
:
class
VectorOfIntegers
extends
Vector
<
Integer
>
{
}
le
type
?
être
appeler
type
joker
(
wildcard
type
)
.
il
permettre
de
représenter
tout
type
.
exemple
:
public
void
printAll
(
collection
<
?
>
c
)
{
for
(
Object
o
:
c
)
{
dns-remplacer
(
o
)
;
}
}
il
être
possible
de
borner
le
type
joker
.
un
caractère
joker
avec
un
borne
supérieur
être
spécifier
:
<
?
extends
type
>
et
représenter
tout
le
sous-type
de
type
.
un
caractère
joker
avec
un
borne
inférieur
être
spécifier
:
<
?
super
type
>
et
représenter
tout
le
type
qui
être
du
super-type
de
type
.
ip-remplacée
>
exemple
de
collection
:
ArrayList
un
objet
de
type
ArrayList
<
E
>
être
un
collection
de
taille
variable
de
élément
de
type
E
.
chaque
élément
être
repérer
par
son
indice
qui
permettre
un
accès
direct
à
le
élément
.
un
liste-tableau
supporter
le
principal
fonctionnalité
suivant
:
-
ajout
de
un
élément
en
fin
de
tableau
(
méthode
add
(
E
)
)
-
accès
à
un
élément
de
indice
donner
(
méthode
get
(
int
)
et
add
(
int
,
E
)
)
-
suppression
de
un
élément
de
indice
donner
(
méthode
remove
(
int
)
)
-
consultation
du
nombre
de
élément
(
méthode
size
(
)
)
le
élément
de
un
objet
collection
de
type
ArrayList
<
E
>
être
indicer
de
à
dns-remplacé
(
)
-
le
classe
ArrayList
<
E
>
devoir
être
importer
du
paquetage
dns-remplacer
par
:
import
dns-remplacer
;
exemple
:
ArrayList
<
Integer
>
myCollectionOfIntegers
;
myCollectionOfIntegers
=
new
ArrayList
<
Integer
>
(
)
;
for
(
int
=
;
<
;
i++
)
{
dns-remplacer
(
i
,
)
;
}
ip-remplacée
>
parcours
de
un
collection
--
Itérateur
le
parcours
de
un
collection
être
le
opération
qui
consister
à
explorer
ce
collection
élément
par
élément
.
deux
façon
de
faire
pour
parcourir
un
collection
:
-
soit
utiliser
un
itérateur
.
un
itérateur
être
un
objet
de
type
Iterator
<
E
>
.
le
trois
fonctionnalité
le
plus
utile
pour
créer
et
gérer
un
itérateur
être
le
méthode
:
iterator
(
)
(
de
le
classe
collection
)
,
hasNext
(
)
et
next
(
)
(
de
le
classe
Iterator
)
.
à
noter
que
le
suppression
de
élément
de
le
collection
en
cours|cour
de
parcours
relever
de
le
méthode
remove
(
)
de
le
itérateur
et
non
de
celui
de
le
collection
.
le
classe
Iterator
<
E
>
devoir
être
importer
du
paquetage
dns-remplacer
par
:
import
dns-remplacé
;
le
itérateurs
être
le
façon
de
faire
historique
pour
parcourir
un
collection
.
depuis
le
version
il
être
générique
.
-
soit
utiliser
un
boucle
for
généraliser
.
un
tel
boucle
permettre
de
se
affranchir
du
itérateurs
et
de
parcourir
très
simplement
un
collection
quelconque
.
elle
ne
être
offrir
que
depuis
le
version
.
exemple
de
parcours
avec
itérateur
:
Iterator
<
Integer
>
it
=
dns-remplacer
(
)
;
while
(
dns-remplacer
(
)
)
{
/
/
call
dns-remplacé
(
)
to
get
the
next
object
of
the
collection
/
/
and
do
something
with
that
object
}
exemple
de
parcours
sans
itérateur
:
/
/
for
each
element
of
my
collection
of
Integers
,
print
it
for
(
Integer
v
:
myCollectionOfIntegers
)
{
dns-remplacer
(
v
)
;
}
Transtypage
le
transtypage
(
en
anglais
:
cast
/
casting
)
être
un
opération
qui
consister
à
convertir
le
type
de
un
expression
.
le
conversion
de
type
se
réaliser
en
faire
précéder
le
expression
par
le
type
cibler
entre
parenthèse
.
ce
proposition
se
appliquer
à
certain
type
primitif
et
au
type
objet
lier
par
un
relation
de
héritage
.
le
conversion
incorrect
provoquer
un
erreur
à
le
compilation
ou
à
le
exécution
.
à
noter
que
un
transtypage
ne
changer
pas
le
type
du
variable
concerner
(
le
type
de
un
variable
être
définir
un
fois
pour
tout
dès
son
création
)
:
le
opération
de
transtypage
être
simplement
un
changement
de
point
de
vue
que
on
demander
au
compilateur
.
syntaxe
:
(
newType
)
expression
exemple
:
int
n
=
;
char
c
=
(
char
)
(
n
/
)
;
mais
certain
classe
offrir
du
méthode
spécifique
plus
adéquat
,
notamment
:
°
pour
le
conversion
réel
-
>
entier
:
-
le
méthode
math
.
round
(
realValue
)
permettre
de
convertir
un
réel
en
le
entier
le
plus
proche
-
le
méthode
dns-remplacer
(
realValue
)
associer
à
un
conversion
en
entier
fournir
le
plus
grand
entier
inférieur
ou
égal
à
le
argument
.
exemple
:
(
int
)
dns-remplacer
(
)
valoir
-
le
méthode
dns-remplacer
(
realValue
)
associer
à
un
conversion
en
entier
fournir
le
plus
petit
entier
supérieur
ou
égal
à
le
argument
.
exemple
:
(
int
)
dns-remplacer
(
)
valoir
°
pour
le
conversion
en
ou
à
partir
de
string
:
-
le
méthode
toString
(
)
,
dont
hériter
tout
objet
,
permettre
de
convertir
un
objet
en
string
-
le
méthode
valueOf
(
primitiveTypeExpression
)
,
de
le
classe
string
,
renvoyer
le
représentation
string
de
le
valeur
de
son
argument
-
le
méthode
valueOf
(
string
)
,
dont
disposer
tout
classe
envelopper
,
renvoyer
un
instance
de
ce
classe
envelopper
contenir
le
valeur
représenter
par
le
argument
de
type
string
exemple
:
/
/
Convert
string
type
-
>
primitif
type
double
x
=
dns-remplacer
(
`
`
'
'
)
;
/
/
Convert
string
type
-
>
wrapped
typer
double
pi
=
dns-remplacer
(
`
`
'
'
)
;
/
/
Convert
wrapped
type
-
>
primitif
type
int
k
=
dns-remplacer
(
`
`
'
'
)
.intValue
(
)
;
/
/
Convert
primitif
type
-
>
string
typer
string
piStr
=
dns-remplacer
(
)
;
/
/
Convert
primitif
type
-
>
string
typer
double
pi
=
new
double
(
)
;
string
s
=
dns-remplacer
(
)
;
Autoboxing
/
unboxing
.
depuis
le
plate-forme
(
voir
chapitre
)
,
le
valeur
de
type
primitif
être
,
en
cas
de
besoin
,
implicitement
convertir
en
le
objet
de
le
classe
envelopper
correspondant
(
autoboxing
)
,
et
réciproquement
(
unboxing
)
.
auparavant
,
le
conversion
devoir
être
explicite
.
OPERATEURS
et
expression
java
posséder
un
nombre
considérable
de
opérateur
arithmétique
et
logique
.
le
expression
être
constituer
de
opérande
et
de
opérateur
.
le
opérande
pouvoir
être
de
différent
nature
:
variable
,
constant
,
appel
de
fonction
.
dans
un
expression
,
tout
le
opérateur
devoir
être
explicite
.
quand
plus
de
un
opérateur
apparaître
dans
un
seul
expression
,
alors
du
règle
de
précédence
être
utiliser
pour
déterminer
le
ordre
de
application
.
se
il
être
nécessaire
de
altérer
le
ordre
normal
de
évaluation
,
du
parenthèse
pouvoir
être
utiliser
.
à
précédences
égal
,
le
expression
être
évaluer
de
gauche
à
droit|droite
.
recommandation
de
style
:
+
utiliser
le
parenthèse
pour
isoler
le
sous-expression
afin
de
éviter
le
problème
de
précédence
de
opérateur
et
rendre
le
code
plus
lisible
pour
tout
programmeur
.
+
insérer
un
espace
avant
et
après
chaque
opérateur
autre
que
le
point
opérateur
et
expression
arithmétique
quelque
opérateur
arithmétique
binaire
opérateur
fonction
champ
de
application
/
division
réel
réel
/
division
entier
entier
#
modulo
(
rester
de
le
division
entier
)
*
entier
*
noter
.
en
java
comme
dans
le
plupart
du
langage
de
programmation
,
à
%
B
être
toujours
du
signe
de
à
(
alors
que
en
mathématique
le
reste
de
le
division
euclidien
être
toujours
positif
,
le
quotient
se
calculer
en
conséquence
)
.
pour
java
:
avoir
/
B
=
sgn
(
à
)
*
sgn
(
B
)
*
|
à
|
/
|
B
|
;
à
%
B
=
A-
(
à
/
B
)
*
B
%
/
en
java
en
math
*
nota
.
en
java
,
le
opérateur
modulo
%
pouvoir
aussi
être
appliquer
sur
du
réel
.
le
résultat
être
alors
le
reste
obtenir
après
soustraction
de
le
opérande
droit
à
le
opérande
gauche
un
nombre
entier
de
fois
.
toutefois
,
à
cause
du
arrondir
de
calcul
,
le
résultat
ne
être
pas
toujours
celui
que
on
attendre
(
par
exemple
:
%
donne
et
non
)
.
grand
prudence
,
donc
,
avec
ce
opérateur
appliquer
sur
du
réel
.
quelque
opérateur
arithmétique
unaire
opérateur
fonction
champ
de
application
++
incrémentation
entier
ou
réel
--
décrémentation
entier
ou
réel
opérateur
et
expression
booléen
quelque
opérateur
booléen
binaire
opérateur
fonction
&
&
et
logique
conditionnel
*
|
|
ou
logique
conditionnel
*
^
ou
logique
exclusif
*
avec
ce
opérateur
,
le
évaluation
de
le
expression
logique
se
arrêter
dès
que
il
être
possible
de
inférer
le
valeur
final
de
le
expression
;
tout
le
opérande
ne
être
donc
pas
nécessairement
évaluer
.
opérateur
booléen
unaire
opérateur
fonction
!
négation
logique
opérateur
relationnel
quelque
opérateur
relationnel
(
ou
de
comparaison
)
opérateur
fonction
=
=
égal
à
!
=
non
égal
à
<
inférieur
à
<
=
inférieur
ou
égal
à
>
supérieur
à
>
=
supérieur
ou
égal
à
METHODES
définition
et
appel
de
un
méthode
ordinaire
définition
de
un
procédure
définition
de
un
fonction
public
void
procName
(
formalParams
)
public
fctlype
fctName
(
formalParams
)
{
{
declaration
declaration
statements
statements
}
return
expression
;
}
appel
de
un
procédure
appel
de
un
fonction
appel
interne
à
le
classe
de
définition
:
appel
interne
à
le
classe
de
définition
:
procName
(
actualParams
)
;
variable
=
fctName
(
actualParams
)
;
appel
externe
à
le
classe
de
définition
:
appel
externe
à
le
classe
de
définition
:
-
méthode
de
instance
-
méthode
de
instance
dns-remplacer
(
actualParams
)
;
variable
=
dns-remplacer
(
actualParams
)
;
-
méthode
de
classe
-
méthode
de
classe
dns-remplacer
(
actualParams
)
;
variable
=
ClassName
.
fctName
(
actualParams
)
;
déclaration
de
un
paramètre
formel
spécification
de
un
paramètre
effectif
(
formal
parameter
)
(
actual
parameter
)
paramètre
de
entrée
(
type
primitif
ou
objet
)
:
paramètre
de
entrée
(
type
primitif
ou
objet
)
:
parameterType
parameterName
expression
paramètre
de
sortie
de
type
primitif
:
paramètre
de
sortie
de
type
primitif
:
impossible
(
utiliser
un
fonction
ou
passer
impossible
un
paramètre
de
type
objet
)
paramètre
de
sortie
de
type
objet
:
paramètre
de
sortie
de
type
objet
:
parameterType
parameterName
objectName
+
le
paramètre
spécifier
dans
le
définition
de
un
méthode
être
appeler
paramètre
formel
;
il
devoir
être
précéder
de
leur
type
.
le
paramètre
apparaître
dans
le
forme
de
appel
être
appeler
paramètre
effectif
.
se
il
y
avoir
plusieurs
paramètre
,
il
être
séparer
par
du
virgule
.
+
tout
le
paramètre
de
type
primitif
être
passer
par
valeur
(
ce
être
un
copie
de
ce
argument
qui
être
transmettre
à
le
méthode
,
elle
ne
disposer
pas
de
le
original
)
.
tout
le
paramètre
de
type
objet
être
passer
par
référence
(
ce
être
un
référence
,
i.e.
.
un
pointeur
,
qui
être
transmettre
à
le
méthode
,
et
pas
le
objet
lui
même
)
.
+
par
défaut
,
le
méthode
être
du
méthode
de
instance
:
elle
être
invoquer
sur
un
instance
de
classe
.
il
exister
aussi
du
méthode
de
classe
qui
pouvoir
être
invoquer
sans
instance
.
on
spécifier
un
méthode
de
classe
en
le
déclarant
static
+
le
signature
[
]
de
un
méthode
être
constituer
de
son
nom
et
de
le
liste
du
type
du
paramètre
.
dans
un
même
classe
,
deux
méthode
ne
pouvoir
pas
avoir
le
même
signature
;
elle
pouvoir
toutefois
porter
le
même
nom
(
cela
se
appeler
le
surcharge
)
.
+
dans
tout
méthode
de
instance
ou
constructeur
,
on
pouvoir
référer
à
le
objet
courant
(
i.e.
.
le
objet
dont
le
méthode
ou
le
constructeur
être
en
cours|cour
de
appel
)
par
le
mot
clé
this
.
on
pouvoir
ainsi
référer
à
tout
membre
(
champ
ou
méthode
)
de
le
objet
courir
par
un
identifier
de
le
forme
dns-remplacer
constructeur
un
constructeur
être
un
méthode
particulier
dont
le
invocation
être
explicitement
associer
à
le
création
de
un
instance
de
classe
et
dont
le
finalité
être
de
initialiser
proprement
le
état
de
ce
objet
lors
de
son
création
.
le
définition
de
un
constructeur
suivre
du
règle
syntaxique
spécifique
:
le
nom
de
un
constructeur
être
obligatoirement
le
nom
de
son
classe
de
appartenance
;
le
en-tête
de
son
définition
ne
lui
spécifier
pas
de
type
.
syntaxe
de
définition
de
un
constructeur
de
un
classe
de
nom
ClassName
:
public
ClassName
(
formalParameters
)
{
/
/
...
Fields
initializations
...
}
un
constructeur
être
typiquement
utiliser
en
association
avec
le
opérateur
new
.
exemple
de
syntaxe
de
utilisation
de
un
constructeur
de
un
classe
de
nom
ClassName
:
ClassName
object
=
new
ClassName
(
actualParameters
)
;
un
même
classe
pouvoir
comporter
plusieurs
constructeur
sous
condition
que
il
ne
avoir
pas
le
même
paramètre
.
dans
ce
cas
,
pour
éviter
de
le
duplication
de
code
,
un
constructeur
pouvoir
en
appeler
un
autre
avec
le
syntaxe
:
this
(
actualParameters
)
.
exemple
:
public
class
point
{
private
int
x
,
y
;
public
pointe
int
x
,
int
y
)
{
/
/
à
first
constructor
this.x.
=
X
;
this.y.
=
y
;
}
public
point
(
)
{
/
/
à
second
constructor
this
(
,
)
;
}
/
/
...
}
[
]
à
noter
que
ce
définition
,
adopter
par
java
,
ne
prendre
pas
en
considération
le
type
de
le
méthode
.
en
ce
sens|sen
,
le
`
`
signature
`
`
correspondre
à
ce
qui
être
parfois
appeler
par
ailleurs
`
`
profil
`
`
de
le
méthode
.
méthode
main
le
méthode
main
,
comme
en
C
ou
C++
,
être
le
point
de
entrée
de
un
application
au
lancement
de
le
exécution
.
syntaxe
:
public
static
void
main
(
string
[
]
args
)
{
...
}
le
argument
args
capter
le
éventuel
argument
de
le
ligne
de
commande
,
le
premier
argument
de
le
ligne
de
commande
être
stocker
dans
args
[
]
(
et
non
dans
args
[
]
comme
en
C
/
C++
)
exemple
:
considérer
un
application
dont
le
classe
principal
-
celui
contenir
le
méthode
main
-
se
appeler
game
.
supposer
que
le
application
dépendre
de
deux
paramètre
dont
le
valeur
devoir
être
fournir
au
lancement
.
supposer
également
que
le
fichier
source
game
.
java
avoir
être
compiler
en
un
fichier
exécutable
dns-remplacer
.
le
lancement
de
le
application
par
le
commande
:
java
game
Daniel
attribuer
à
args
le
tableau
{
`
`
Daniel
'
'
,
`
`
'
'
}
instruction
sur
le
plan
syntaxique
,
le
instruction
(
statements
)
pouvoir
être
regrouper
en
grand
catégorie
:
-
le
instruction
simple
:
instruction
de
affectation
,
instruction
de
entrée
/
sortie
,
instruction
de
appel
à
un
procédure
.
un
instruction
simple
se
terminer
toujours
par
un
point-virgule
.
un
point-virgule
seul
définir
un
instruction
vide
.
-
le
instruction
de
contrôle
:
instruction
de
sélection
,
instruction
de
boucle
,
instruction
de
rupture
de
séquence
.
-
le
bloc
de
instruction
.
un
bloc
de
instruction
-
aussi
appeler
instruction
composé
-
être
un
séquence
de
instruction
enserrer
entre
accolade
.
le
bloc
{
}
définir
un
instruction
vide
.
instruction
de
affectation
syntaxe
:
variable
=
expression
;
le
symbole
=
être
le
opérateur
de
affectation
.
le
valeur
de
le
expression
situer
en
partie
droit
être
affecter
à
le
variable
spécifier
en
partie
gauche
.
le
type
de
le
expression
devoir
se
apparier
au
type
de
le
variable
.
le
impact
physique
être
différent
selon
que
le
expression
être
de
type
primitif
ou
objet
(
voir
chapitre
)
.
instruction
de
contrôle
instruction
de
sélection
ip-remplacée
>
if-else
premier
forme
:
deuxième
forme
:
if
(
expression
)
{
if
(
expression
)
{
statements
statements
}
}
else
{
statements
}
exemple
:
if
(
dns-remplacer
(
)
=
=
)
{
dns-remplacé
(
`
`
The
field
is
empty
.
`
`
)
;
}
exemple
:
if
(
number
<
)
{
reportError
(
)
;
}
else
{
processNumber
(
number
)
;
}
exemple
:
if
(
n
<
)
{
handleNegative
(
)
;
}
else
if
(
n
=
=
)
{
handlezero
(
)
;
}
else
{
handlePositive
(
)
;
}
ip-remplacée
>
switch
premier
forme
:
deuxième
forme
:
switch
(
expression
)
{
switch
(
expression
)
{
case
value1
:
caser
value1
:
statements
;
/
*
falls
through
*
/
break
;
case
value2
:
case
value2
:
/
*
falls
through
*
/
statements
;
case
value3
:
break
;
statements
;
default
:
break
;
statements
;
case
value4
:
break
;
/
*
falls
through
*
/
}
caser
value5
:
statements
;
break
;
default
:
statements
;
break
;
}
+
un
instruction
switch
pouvoir
avoir
un
nombre
quelconque
de
label
caser
+
le
instruction
break
mettre
fin
à
le
instruction
switch
.
avoir
défaut
de
instruction
break
,
le
exécution
se
poursuivre
sur
le
instruction
du
label
suivant
.
le
deuxième
former
ci-
dessus
exploiter
ce
comportement
:
chacun
du
trois
premier
valeur
conduire
à
le
exécution
de
le
partie
statements
associer
à
value3
;
chacun
du
deux
valeur
suivant
conduire
à
le
exécution
de
le
partie
statements
associer
à
value5
;
+
le
clause
default
être
optionnel
,
mais
recommander
.
à
défaut
,
il
se
pouvoir
que
aucun
cas
ne
conduire
à
un
exécution
.
exemple
:
switch
(
day
)
{
case
:
dayString
=
`
`
Monday
'
'
;
break
;
case
:
dayString
=
`
`
Tuesday
'
'
;
break
;
case
:
dayString
=
`
`
Wednesday
'
'
;
break
;
case
:
dayString
=
`
`
Thursday
'
'
;
break
;
case
:
dayString
=
`
`
Friday
'
'
;
break
;
case
:
dayString
=
`
`
Saturday
'
'
;
break
;
case
:
dayString
=
`
`
Sunday
'
'
;
break
;
default
:
error
(
)
;
break
;
}
exemple
:
switch
(
winterMonth
)
{
case
:
numberOfDays
=
;
break
;
case
:
/
*
falls
through
*
/
case
:
numberOfDays
=
;
break
;
case
:
if
(
isLeapYear
(
)
)
{
numberOfDays
=
;
}
else
{
numberOfDays
=
;
}
break
;
default
:
error
(
)
;
break
;
}
instruction
de
boucle
ip-remplacée
>
while
le
boucle
while
exécuter
un
bloc
de
instruction
aussi
longtemps
que
le
valeur
de
un
expression
donner
être
true
.
le
expression
être
tester
avant
chaque
exécution
du
corps
de
boucle
,
si
bien
que
le
corps
de
boucle
pouvoir
être
exécuter
fois
.
syntaxe
:
while
(
expression
)
{
statements
}
exemple
:
int
i
=
;
while
(
<
dns-remplacer
(
)
)
{
dns-remplacer
(
dns-remplacer
(
)
)
;
i++
;
}
exemple
:
while
(
dns-remplacer
(
)
)
{
processObject
(
dns-remplacer
(
)
;
}
ip-remplacée
>
do-while
le
boucle
do-while
le
exécuter
un
bloc
de
instruction
aussi
longtemps
que
le
valeur
de
un
expression
donner
être
true
.
le
expression
être
tester
après
chaque
exécution
du
corps
de
boucle
,
si
bien
que
le
corps
de
boucle
être
toujours
exécuter
au
moins
fois
.
syntaxe
:
do
{
statements
}
while
(
expression
)
;
exemple
:
do
{
input
=
readInput
(
)
;
if
(
input
=
=
null
)
{
dns-remplacé
(
`
`
Try
again
'
'
)
;
}
}
while
(
input
=
=
null
)
;
ip-remplacée
>
for
le
boucle
for
se
exécuter
aussi
longtemps
que
un
condition
se
évaluer
à
true
.
avant
que
le
boucle
ne
démarrer
,
un
instruction
de
initialisation
être
exécuter
exactement
fois
.
le
condition
être
évaluer
avant
chaque
exécution
du
corps
de
boucle
(
comme
pour
un
boucle
while
)
.
un
instruction
de
mise
à
jour
du
variable
être
exécuter
après
chaque
exécution
du
corps
de
boucle
.
syntaxe
:
for
(
initialization
;
condition
;
update
)
{
statements
}
exemple
:
for
(
int
=
;
<
dns-remplacer
(
)
;
i++
)
{
dns-remplacer
(
dns-remplacer
(
)
)
;
}
ip-remplacée
>
foreach
depuis
le
plate-forme
(
voir
chapitre
)
,
java
offrir
un
boucle
for
améliorer
pour
parcourir
le
élément
de
un
tableau
ou
de
un
collection
(
se
reporter
au
section
respectif
)
.
syntaxe
:
/
/
for
each
element
of
the
collection
,
process
element
for
(
TypeOfElements
element
:
collectionOfElements
)
{
/
/
...
process
element
...
}
instruction
de
entrée
/
sortie
java
offrir
un
nombre
considérable
de
fonction
et
procédure
de
entrée
/
sortir
,
tant
en
mode
texte
que
graphique
.
nous
nous
limiter
dans
ce
section
au
principal
instruction
de
entrée
/
sortir
en
mode
texte
;
pour
du
entrée
/
sortir
en
mode
graphique
,
voir
chapitre
.
le
méthode
de
entrée
/
sortie
primaire
appartenir
au
classe
du
paquetage
java
.
io
.
depuis
le
plate-forme
(
voir
chapitre
)
,
le
classe
scanner
du
paquetage
dns-remplacé
offre
:
-
du
fonctionnalité
de
base
pour
lire
facilement
du
donnée
depuis
tout
flux
de
entrée
;
-
du
sortie
formater
comme
en
C
.
en
complément
,
le
classe
dns-remplacé
permettre
de
spécifier
du
format
de
entrée
ou
de
sortie
.
notion
de
flux
le
flux
ou
flot
(
stream
en
anglais
)
généraliser
le
notion
de
périphérique
de
entrée
/
sortie
.
un
flux
pouvoir
être
voir
comme
un
interface
intelligent
unidirectionnel
relier
le
machine
java
et
le
périphérique
,
et
qui
permettre
,
en
lecture
aussi
bien
que
en
écriture
,
de
se
affranchir
du
spécificité
du
périphérique
concerner
.
réaliser
un
entrée
/
sortie
consister
ainsi
à
:
)
créer
un
flux
du
type
approprié
(
sauf
se
il
exister
déjà
,
ou
être
prédéfinir
(
dns-remplacer
,
dns-remplacer
ou
dns-remplacer
)
)
)
lire
ou
écrire
,
selon
le
cas
,
dans
ce
flux
)
et
souvent
,
dans
le
cas
de
un
lecture
,
convertir
le
donnée
lire
dans
le
type
cibler
souhaiter
pour
un
premier
approche
,
nous
nous
limiter
à
du
flux
à
accès
séquentiel
.
entrée
/
sortie
terminal
le
solution
suivant
ne
se
affranchir
pas
du
erreur
de
saisie
.
pour
gérer
ce
type
de
erreur
,
se
reporter
au
chapitre
exception
(
chapitre
)
.
ip-remplacée
>
affichage
écran
syntaxe
de
un
affichage
écran
en
mode
texte
:
dns-remplacer
(
string
)
;
dns-remplacer
(
string
)
;
dns-remplacer
(
primitiveTypeExpression
)
;
dns-remplacer
(
primitiveTypeExpresstion
)
;
ip-remplacée
>
affichage
formater
depuis
le
plate-forme
,
java
offrir
également
un
méthode
printf
permettre
du
sortie
formater
comme
en
C
(
voir
classe
dns-remplacer
pour
le
spécification
du
format
)
.
exemple
:
dns-remplacer
(
`
`
count
=
`
`
+
count
)
;
dns-remplacer
(
`
`
%
s
%
5d
\n
'
'
,
user
,
total
)
;
fonctionnement
du
printf
et
code
de
formatage
:
un
printf
réclamer
un
chaîne
de
caractère
en
premier
paramètre
.
ce
chaîne
pouvoir
être
suivre
de
n
variable
,
n
>
.
ce
être
ce
chaîne
,
qui
pouvoir
contenir
du
code
de
formatage
,
qui
être
imprimer
.
un
code
de
formatage
commencer
par
le
caractère
%
.
à
chaque
fois
que
un
code
de
formatage
être
rencontrer
,
printf
imprimer
le
variable
suivant
dans
le
liste
de
son
paramètre
.
principal
code
de
formatage
commander
le
affichage
de
un
valeur
de
type
:
%
c
caractère
%
d
entier
%
e
réel
(
en
notation
avec
exposant
)
%
f
réel
#
s
chaîne
de
caractère
le
code
de
formatage
pouvoir
inclure
un
spécification
de
format
du
champ
de
affichage
.
exemple
de
code
de
formatage
champ
de
affichage
spécifier
pour
le
paramètre
du
type
considérer
:
%
6d
champ
de
caractère
%
-6d
champ
de
caractère
avec
justification
à
gauche
%
8.2f
champ
de
caractère
dont
à
droit|droite
de
le
virgule
ip-remplacer
>
lecture
clavier
exemple
:
scanner
input
=
new
scanner
(
dns-remplacer
)
;
string
s1
=
dns-remplacer
(
)
;
/
/
read
avoir
string
(
avoir
word
)
string
s2
=
dns-remplacer
(
)
;
/
/
read
the
rest
of
the
line
int
n
=
dns-remplacer
(
)
;
/
/
read
an
integer
double
r
=
dns-remplacer
(
)
;
/
/
read
avoir
double
dns-remplacer
(
)
;
entrée
/
sortie
fichier
opérer
sur
un
fichier
consister
à
:
)
créer
un
flux
approprier
au
opération
souhaiter
)
lire
ou
écrire
dans
le
fichier
)
fermer
le
fichier
le
solution
suivant
ne
se
affranchir
pas
du
erreur
de
entrée
/
sortie
.
pour
gérer
ce
type
de
erreur
,
se
reporter
au
chapitre
exception
(
chapitre
)
.
ip-remplacée
>
Ecriture
fichier
depuis
le
plate-forme
,
java
offrir
également
un
méthode
printf
permettre
du
sortie
formater
comme
en
C
(
voir
classe
dns-remplacer
pour
le
spécification
du
format
)
.
exemple
de
écriture
dans
un
fichier
texte
:
PrintWriter
out
=
new
PrintWriter
(
outputFileName
)
;
for
(
int
i
=
;
i
<
;
i++
)
dns-remplacer
(
`
`
%
c
%
d
'
'
,
'
\t
'
,
i
)
;
dns-remplacer
(
)
;
ip-remplacée
>
lecture
fichier
exemple
de
lecture
de
un
fichier
texte
mot
à
mot
:
scanner
in
=
new
scanner
(
new
file
(
inputFileName
)
)
;
string
s
;
while
(
dns-remplacer
(
)
)
{
s
=
dns-remplacer
(
)
;
/
/
read
avoir
string
(
avoir
word
)
dns-remplacer
(
s
)
;
}
dns-remplacer
(
)
;
ip-remplacée
>
contexte
particulier
Cas1
.
ouverture
en
lecture
de
un
fichier
texte
stocker
dans
le
fichier
.jar
exécuter
import
dns-remplacer
;
import
dns-remplacé
;
ClassLoader
cl
=
dns-remplacer
(
)
;
InputStream
is
=
dns-remplacer
(
inputFileName
)
;
scanner
in
=
new
scanner
(
is
)
;
Cas2
.
ouverture
en
lecture
de
un
fichier
texte
distant
identifier
par
un
URL
import
dns-remplacer
;
import
dns-remplacé
;
URL
url
=
new
URL
(
`
`
http
:
/
/
dns-remplacer
/
...
/
inputFileName
'
'
)
;
scanner
in
=
new
scanner
(
dns-remplacer
(
)
)
;
nota
.
solution
non
applicable
depuis
un
applet
.
en
outre
,
bien
se
assurer
que
tout
le
condition
de
accessibilité
au
fichier
être
lever
(
pas
de
interdiction
par
le
pare-feu
local
notamment
!
)
Cas3
.
ouverture
de
un
nouveau
page
html
depuis
un
applet
(
de
même
répertoire
)
import
dns-remplacer
;
import
dns-remplacé
;
URL
url
=
new
URL
(
getDocumentBase
(
)
,
`
`
dns-remplacer
'
'
)
;
getAppletContext
(
)
.showDocument
(
url
,
`
`
_blank
'
'
)
;
repaint
(
)
;
lecture
de
un
chaîne
de
caractère
formater
il
être
fréquent
de
avoir
à
lire
un
chaîne
de
caractère
dont
on
connaître
le
format
,
quel
que
être
le
flux
de
entrée
(
terminal
ou
fichier
)
.
depuis
le
plate-forme
,
le
classe
scanner
du
paquetage
dns-remplacer
offrir
du
fonctionnalité
très
pratique
.
exemple
de
lecture
de
un
chaîne
de
caractère
formater
:
string
str
=
`
`
XXX
XXX
yellow
XXX
blue
XXX
'
'
'
'
;
scanner
in
=
new
scanner
(
str
)
.useDelimiter
(
`
`
\\s
*
XXX\\s
*
'
'
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
dns-remplacer
(
)
)
;
dns-remplacer
(
)
;
/
/
Will
display
:
/
/
/
/
/
/
yellow
/
/
blue
HERITAGE
notion
de
héritage
le
héritage
être
un
technique
qui
offrir
de
nombreux
avantage
:
-
éviter
le
duplication
de
code
-
permettre
le
réutilisation
de
code
dans
un
autre
contexte
-
faciliter
le
maintenance
du
programme
-
faciliter
le
extension
de
application
existant
.
le
héritage
(
inheritance
)
être
un
relation
`
`
est_un
`
`
(
non
pas
`
`
a_un
`
`
!
!
!
)
qui
permettre
de
définir
un
classe
comme
le
extension
de
un
autre
.
exemple
:
classe
astre
est_un
est_un
classe
Etoile
classer
planète
un
étoile
être
un
astre
;
un
planète
être
un
astre
.
le
classe
Etoile
étendre
le
classe
astre
=
le
classe
Etoile
hériter
de
le
classe
astre
.
un
super-classe
être
un
classe
qui
être
étendre
par
de
autre
classe
.
un
sous-classe
être
un
classe
qui
étendre
(
hériter
de
)
un
autre
classe
.
elle
hériter
le
état
et
le
comportement
de
tout
son
ancêtre
,
mais
pouvoir
aussi
la|le
redéfinir
.
le
classe
qui
être
lier
par
du
relation
de
héritage
former
un
hiérarchie
de
héritage
.
exemple
de
hiérarchie
de
héritage
:
astre
Etoile
planeter
Exoplanète
planeter
solaire
Pégaside
chtonien
tellurique
habitable
le
constructeur
de
un
sous-classe
devoir
toujours
invoquer
le
constructeur
de
le
super-classe
en
premier
instruction
(
à
défaut
,
java
essayer
de
insérer
un
appel
automatique
)
.
le
forme
de
appel
être
le
suivant
:
super
(
actualParameters
)
;
tout
classe
sans
super-classe
explicite
avoir
Object
comme
super-classe
.
comme
pour
le
hiérarchie
de
classe
,
le
type
former
un
hiérarchie
de
type
.
le
type
définir
par
le
définition
de
un
sous-classe
être
un
sous-type
du
type
définir
par
le
super-classe
.
exemple
:
Etoile
être
un
sous-type
du
type
astre
un
variable
pouvoir
contenir
:
-
un
objet
du
type
déclarer
de
le
variable
-
ou
un
objet
de
tout
sous-type
de
ce
type
déclarer
exemple
:
astre
al
=
new
astre
(
)
;
/
/
correct
astre
a2
=
new
Etoile
)
;
/
/
correct
(
transtypage
ascendre
)
astre
a3
=
new
Planete
(
)
;
/
/
correct
(
transtypage
ascendre
)
Etoile
el
=
new
astre
(
)
;
/
/
erreur
Etoile
e@card@
=
(
Etoile
)
a2
;
/
/
correct
(
un
transtypage
descendant
/
/
devoir
être
explicite
)
un
objet
de
un
sous-type
peut-être
utiliser
partout
où
un
objet
de
un
super-type
être
attendre
.
ceci
se
appeler
le
substitution
.
java
ne
permettre
pas
le
héritage
multiple
:
un
sous-classe
ne
pouvoir
hériter
directement
que
de
un
seul
super-classe
.
que
hériter
un
sous-classe
?
un
sous-classe
hériter
de
tout
le
membre
de
son
super-classe
qui
être
accessible
,
sauf
si
ce
membre
(
attribut
ou
méthode
)
être
redéfinir
dans
le
sous-classe
.
un
sous-classe
hériter
de
son
super-classe
:
-
le
membre
déclarer
public
ou
protected
-
le
membre
déclarer
sans
modificateur
de
accès
,
si
le
sous-classe
être
dans
le
même
paquetage
que
la
super-classe
.
un
sous-classe
ne
hériter
pas
de
son
super-classe
:
-
le
membre
qui
être
redéfinir
dans
le
sous-classe
-
le
constructeur
.
attention
au
choix
du
identificateurs
dans
le
sous-classe
:
ce
choix
pouvoir
involontairement
masquer
un
membre
de
le
super-classe
!
ce
être
particulièrement
le
cas
pour
le
attribut
:
un
attribut
avoir
le
même
nom
que
un
attribut
de
son
super-classe
masquer
le
attribut
de
le
super-
classe
,
même
se
il
être
de
type
différent
.
redéfinir
un
méthode
pour
redéfinir
un
méthode
dans
un
sous-classe
,
il
falloir
que
elle
avoir
le
même
signature
et
le
même
type
de
retour
que
le
méthode
de
le
super-classe
.
le
méthode
redéfinir
pouvoir
autoriser
un
accès
plus
large
mais
pas
moins
(
ex
:
un
méthode
déclarer
protected
dans
le
super-
classe
pouvoir
être
redéfinir
public
dans
le
sous-classe
,
mais
pas
private
)
.
le
exemple
typique
être
le
méthode
toString
de
le
classe
Object
:
appliquer
à
un
objet
,
elle
produire
un
chaîne
de
caractère
former
du
nom
de
son
classe
et
de
son
code
de
hachage
,
mais
ce
méthode
pouvoir
être
redéfinir
dans
tout
classe
.
si
le
méthode
redéfinir
dans
le
sous-classe
avoir
simplement
besoin
de
ajouter
quelque
fonctionnalité
complémentaire
à
celui
de
le
méthode
de
le
super-classe
,
il
ne
être
pas
besoin
de
le
réécrire
complètement
car
elle
pouvoir
appeler
le
méthode
de
le
super-classe
par
:
dns-remplacer
(
actualParameters
)
quelque
règle
:
-
un
méthode
de
instance
ne
pouvoir
pas
redéfinir
un
méthode
de
classe
,
et
réciproquement
-
un
méthode
de
instance
de
un
sous-classe
avoir
le
même
signature
et
type
que
un
méthode
de
instance
dans
le
super-classe
redéfinir
le
méthode
de
le
super-classe
:
le
version
de
le
méthode
invoquer
sur
un
instance
de
le
sous-classe
(
type
dynamique
car
liaison
dynamique
du
méthode
de
instance
)
être
celui
de
le
sous-classe
.
-
un
méthode
de
classe
de
un
sous-classe
avoir
le
même
signature
et
type
que
un
méthode
de
classe
dans
le
super-classe
masquer
le
méthode
de
le
super-classe
:
le
version
de
le
méthode
invoquer
dépendre
de
si
elle
être
appeler
sur
le
super-classe
ou
sur
le
sous-classe
(
car
liaison
statique
du
méthode
de
classe
)
.
-
un
sous-classe
ne
pouvoir
pas
redéfinir
le
méthode
déclarer
final
de
son
super-classe
-
un
sous-classe
devoir
redéfinir
le
méthode
déclarer
abstract
dans
le
super-classe
,
à
moins
que
le
sous-classe
soit
elle
même
déclarer
abstract
.
depuis
le
plate-forme
(
voir
chapitre
)
:
il
être
conseiller
de
utiliser
le
annotation
(
ou
méta-donner
)
@
Override
pour
marquer
tout
méthode
qui
être
supposer
redéfinir
un
méthode
hériter
de
un
classe
parent
.
cela
permettre
au
compilateur
de
signaler
immédiatement
un
erreur
si
jamais
le
redéfinition
ne
être
pas
avérer
(
à
cause
par
exemple
de
un
faute
de
frappe
dans
le
nom
de
le
méthode
)
.
en
outre
,
en
signaler
le
méthode
redéfinir
,
le
annotation
@
Override
permettre
de
accroître
le
lisibilité
du
code
.
le
covariance
du
type
de
retour
être
autoriser
:
un
méthode
de
un
sous-classe
pouvoir
retourner
un
objet
dont
le
type
être
un
sous-classe
du
type
retourner
par
le
méthode
de
même
signature
dans
le
super-classe
.
ce
caractéristique
supprimer
le
besoin
de
test
et
de
conversion
de
type
excessif
.
exemple
:
@
Override
public
string
toString
(
)
{
/
/
...
}
exemple
:
soit
un
classe
point
posséder
deux
attribut
x
et
y
;
soit
un
classe
ColoredPoint
hériter
de
point
et
posséder
un
attribut
spécifique
color
.
où
et
comment
écrire
le
méthode
equals
sans
duplication
de
code
?
/
*
in
the
class
point
*
/
@
Override
public
boolean
equals
(
Object
o
)
{
if
(
o
=
=
null
)
return
false
;
/
/
case
null
if
(
this
=
=
o
)
return
true
;
/
/
reflexivity
if
(
dns-remplacer
(
)
!
=
o.getClass
(
)
)
return
false
;
/
/
symmetry
/
/
Now
,
this
and
o
having
the
same
class
,
comparer
the
fields
point
p
=
(
point
)
o
;
return
(
this.x.
=
=
p.x.
)
&
&
(
this.y.
=
=
p.y.
)
;
}
/
*
in
the
class
ColoredPoint
extending
point
*
/
@
Override
public
boolean
equals
(
Object
o
)
{
/
/
Verify
if
this
and
o
haver
the
same
class
and
if
their
super
/
/
fields
are
equal
if
(
!
dns-remplacer
(
o
)
)
return
false
;
/
/
Now
comparer
the
specific
fields
ColoredPoint
cp
=
(
ColoredPoint
)
o
;
return
dns-remplacer
(
dns-remplacer
)
;
}
exemple
:
public
class
MotherClass
{
public
void
normal
(
)
{
dns-remplacé
(
`
`
the
normal
method
in
MotherClass
'
'
)
;
}
public
static
void
hide
(
)
{
dns-remplacé
(
`
`
the
hide
method
in
MotherClass
'
'
)
;
}
public
void
override
(
)
{
dns-remplacé
(
`
`
the
override
method
in
MotherClass
'
'
)
;
}
}
/
/
end
MotherClass
public
class
DaughterClass
extends
MotherClass
{
@
Override
public
static
void
hide
(
)
{
dns-remplacé
(
`
`
the
hide
method
in
DaughterClass
'
'
)
;
}
@
Override
public
void
override
(
)
{
dns-remplacé
(
`
`
the
override
method
in
DaughterClass
'
'
)
;
}
public
static
void
main
(
string
[
]
args
)
{
DaughterClass
o@card@
=
new
DaughterClass
(
)
;
MotherClass
o2
o1
;
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
!
!
liaison
statique
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
dns-remplacer
(
)
;
/
/
call
dns-remplacé
(
)
!
!
Tiaison
dynamique
}
}
/
/
end
DaughterClass
le
méthode
main
afficher
:
the
normal
method
in
MotherClass
the
normal
method
in
MotherClass
the
hide
method
in
DaugterClass
the
hide
method
in
MotherClass
the
override
method
in
DaugterClass
the
override
method
in
DaugterClass
type
statique
/
dynamique
-
liaison
statique
/
dynamique
ce
section
reprendre
et
formaliser
quelque
un
du
important
concept
introduire
dans
le
section
précédent
.
type
statique
/
dynamique
-
Transtypage
le
type
statique
de
un
objet
être
le
type
spécifier
par
son
déclaration
.
ce
être
le
type
déclarer
.
ce
être
le
type
à
le
compilation
.
le
type
dynamique
de
un
objet
être
le
type
(
i.e.
.
le
classe
de
appartenance
)
de
le
objet
instancié
.
ce
être
le
type
constater
.
ce
être
le
type
effectif
à
le
exécution
.
le
type
dynamique
de
un
objet
être
toujours
soit
son
type
statique
soit
un
sous-type
de
son
type
statique
(
sauf
exception
devoir
au
transtypage
)
.
exemple
:
être
un
classe
à
et
un
classe
B
sous-classe
de
à
.
considérer
le
code
suivre
:
avoir
avoir
;
if
(
dns-remplacer
(
)
)
{
avoir
=
new
à
(
)
;
}
else
{
avoir
=
new
B
(
)
;
/
/
transtypage
ascendre
implicite
}
le
type
statique
de
avoir
être
à
;
le
type
dynamique
de
avoir
être
à
ou
B
mais
ne
pouvoir
être
constater
que
après
que
le
condition
avoir
être
évaluer
.
le
transtypage
(
casting
)
appliquer
à
un
référence
ne
être
que
le
possibilité
de
avoir
un
vue
spécifique
de
le
objet
pointé
.
il
ne
changer
en
rien
le
type
de
le
objet
sous-jacent
!
(
qui
garder
bien
évidemment
tout
au
long
de
son
vie
le
type
avec
lequel
il
avoir
être
créer
)
.
le
opération
de
transtypage
être
purement
syntaxique
et
ne
faire
que
indiquer
au
compilateur
le
point
de
vue
depuis
lequel
il
devoir
voir
le
objet
.
le
transtypage
vers
un
sur-type
être
dire
ascendant
.
le
transtypage
ascendre
être
implicite
.
le
transtypage
vers
un
sous-type
être
dire
descendant
.
un
transtypage
descendre
devoir
être
explicite
.
il
permettre
de
forcer
le
compilation
mais
ne
garantir
pas
nécessairement
le
absence
de
erreur
de
exécution
.
un
transtypage
ne
être
garantir
correct
que
se
il
respecter
le
règle
suivant
:
être
T1
et
T2
deux
type
définir
.
soit
o
un
objet
de
type
dynamique
T3
.
considérer
le
déclaration
:
T1
obj
=
(
T2
)
o
;
ce
transtypage
être
garantir
possible
,
tant
à
le
compilation
qu
'
à
le
exécution
,
si
et
seulement
si
T3
être
un
sous-type
de
T2
et
T2
un
sous-type
de
T1
.
le
opérateur
instanceof
permettre
de
tester
si
un
objet
être
de
un
type
dynamique
donner
ou
de
tout
sous-type
de
ce
type
donner
.
il
pouvoir
donc
permettre
vérifier
le
compatibilité
du
type
avant
de
opérer
un
transtypage
.
exemple
:
supposer
définir
:
public
class
Shape2D
{
...
}
public
class
Circle
extends
Shape2D
{
...
}
public
class
triangle
extends
Shape2D
{
...
}
public
class
date
{
...
}
le
déclaration
suivant
génèreraient
un
erreur
pour
incompatibilité
de
type
:
Shape2D
s
=
(
Shape2D
)
(
new
date
(
)
)
;
/
/
erreur
de
compilation
Circle
c
=
new
Shape2D
(
)
;
/
/
erreur
de
compilation
Circle
c
=
(
Circle
)
(
new
Shape2D
(
)
)
;
/
/
erreur
de
exécution
triangle
t
=
new
triangle
(
)
;
Circle
c
=
(
Circle
)
t
;
/
/
erreur
de
exécution
le
déclaration
suivant
être
sain
:
Shape2D
s
=
new
Circle
(
)
;
Circle
c
=
(
Circle
)
s
;
Shape2D
s
;
if
(
obj
instanceof
Shape2D
)
s
=
(
Shaped2D
)
obj
;
liaison
statique
/
dynamique
considérer
le
invocation
o.m.
où
o
être
un
objet
de
type
statique
T
et
de
type
dynamique
T
'
,
et
m
un
message
(
attribut
ou
méthode
)
envoyer
à
o
.
si
le
message
m
exécuter
être
celui
dont
le
code
être
accessible
depuis
le
classe
T
,
alors
le
liaison
de
le
objet
au
message
être
dire
statique
(
liaison
à
le
compilation
)
sinon
elle
être
dire
dynamique
(
liaison
à
le
exécution
)
.
en
java
:
-
le
liaison
de
un
objet
avec
son
variable
de
instance
être
statique
;
-
le
liaison
de
un
objet
avec
son
méthode
être
dynamique
(
sauf
si
méthode
static
ou
final
)
.
exemple
:
public
class
à
{
public
boolean
m1
(
à
avoir
)
{
return
true
;
}
public
boolean
m2
(
à
avoir
)
{
return
true
;
}
}
public
class
B
extends
à
{
public
boolean
m1
(
à
avoir
)
{
return
false
;
}
public
boolean
m3
(
à
avoir
)
{
return
false
;
}
public
static
void
main
(
string
[
]
args
)
{
à
avoir
=
new
B
(
)
;
dns-remplacer
(
a.m1
(
avoir
)
)
;
dns-remplacer
(
a.m2
(
avoir
)
)
;
/
/
dns-remplacer
(
a.m3
(
avoir
)
)
;
/
/
problème
}
}
le
méthode
main
afficher
:
false
true
pourquoi
?
le
type
statique
de
avoir
être
à
,
et
son
type
dynamique
B
.
ce
être
donc
le
m1
de
B
qui
être
exécuter
.
quant
à
le
méthode
m2
,
elle
ne
être
pas
définir
dans
B
mais
dans
son
super-classe
à
:
B
hériter
donc
normalement
de
m2
et
m2
être
exécuter
.
le
dernier
instruction
dns-remplacer
(
a.m3
(
avoir
)
)
provoquer
un
erreur
à
le
compilation
.
pourquoi
?
parce
que
le
compilateur
ne
connaître
que
le
type
statique
(
i.e.
.
le
type
déclarer
)
:
le
méthode
m3
ne
être
pas
définir
dans
le
classe
à
ni
dans
un
de
son
super-classe
,
le
compilateur
ne
trouver
pas
le
définition
de
m3
(
bien
que
dans
B
)
et
générer
un
erreur
.
le
solution
être
le
transtypage
descendre
préalable
de
avoir
:
dns-remplacer
(
(
(
B
)
avoir
)
.m3
(
avoir
)
)
.
ce
transtypage
être
correct
car
à
posséder
déjà
,
par
création
,
tout
le
attribut
de
un
instance
de
B
.
polymorphisme
un
même
appel
de
méthode
pouvoir
invoquer
du
méthode
différent
car
le
liaison
être
réaliser
dynamiquement
(
i.e.
.
à
le
exécution
et
non
à
le
compilation
)
,
le
identification
du
type
de
le
objet
associer
à
le
appel
être
dynamique
.
exemple
de
polymorphisme
de
héritage
:
public
class
Shape
{
public
void
draw
(
)
{
dns-remplacer
(
this
+
`
`
.draw
(
)
;
'
'
)
;
}
}
public
class
Circle
extends
Shape
{
@
Override
public
string
toString
(
)
{
return
`
`
circle
'
'
;
}
}
public
class
square
extends
Shape
{
@
Override
public
string
toString
(
)
{
return
`
`
square
'
'
;
}
}
public
class
Picture
{
public
static
void
main
(
string
[
]
args
)
{
Vector
<
Shape
>
v
=
new
Vector
<
Shape
>
(
)
;
v.add
(
new
Circle
(
)
)
;
v.add
(
new
square
(
)
)
;
for
(
Shape
s
:
v
)
{
dns-remplacer
(
s.draw
(
)
)
;
/
/
polymorphism
}
le
méthode
main
afficher
:
dns-remplacer
(
)
;
dns-remplacer
(
)
;
classe
et
méthode
particulier
un
classe
déclarer
final
ne
pouvoir
pas
être
sous-classer
.
un
méthode
déclarer
final
ne
pouvoir
pas
être
redéfinir
dans
un
sous-classe
.
un
classe
déclarer
abstract
représenter
un
concept
abstrait
:
elle
ne
pouvoir
pas
être
instanciée
et
ne
pouvoir
être
que
sous-classer
.
un
méthode
déclarer
abstract
être
un
méthode
dont
le
corps
ne
être
pas
spécifier
.
un
classe
abstrait
pouvoir
contenir
du
méthode
non
abstraire
,
mais
tout
classe
contenir
un
méthode
abstrait
devoir
être
déclarer
abstract
.
si
un
sous-classe
ne
implémentir
pas
tout
le
méthode
abstraire
de
son
super-classe
,
elle
devoir
être
déclarer
abstract
.
interface
un
interface
(
au
sens|sen
du
langage
java
,
cf
section
)
être
un
protocole
de
comportement
qui
pouvoir
être
implanter
par
tout
classe
.
un
interface
être
en
dehors
de
le
hiérarchie
du
classe
.
un
interface
se
différencier
principalement
de
un
classe
abstraire
par
ce
caractéristique
:
-
aucun
méthode
concret
(
par
opposition
à
abstrait
)
ne
pouvoir
être
définir
dans
un
interface
;
-
un
classe
pouvoir
implémenter
plusieurs
interface
.
tout
comme
on
pouvoir
construire
un
hiérarchie
de
classe
,
on
pouvoir
construire
un
hiérarchie
de
interface
.
mais
alors
que
un
classe
ne
pouvoir
étendre
directement
que
un
seul
super-classe
,
(
pas
de
héritage
multiple
)
,
un
interface
pouvoir
étendre
directement
plusieurs
super-interface
(
héritage
multiple
possible
)
.
exemple
:
public
interface
List
<
E
>
extends
collection
<
E
>
{
...
}
exemple
:
public
interface
Predator
{
boolean
chasePrey
(
Prey
p
)
;
}
public
interface
Prey
{
boolean
isChasedBy
(
Predator
p
)
;
}
public
interface
Venomous
{
...
}
public
interface
VenomousPredator
extends
Predator
,
Venomous
{
...
}
public
class
pet
{
...
}
public
class
Cat
extends
pet
implements
Predator
{
...
}
public
class
Frog
implements
Predator
,
Prey
{
...
}
exception
un
exception
être
un
objet
fournir
du
information
relatif
à
un
défaillance
du
programme
.
un
exception
être
générer
dans
chacun
du
situation
suivant
:
-
condition
de
exécution
anormal
,
comme
par
exemple
:
tentative
de
division
par
zéro
,
mémoire
insuffisant
,
-
exécution
de
un
instruction
throw
le
paquetage
java
.
lang
définir
nombre
de
classe
de
exception
qui
couvrir
le
cas
le
plus
courant
.
exception
contrôler
et
non
contrôler
tout
exception
être
un
instance
de
le
classe
Throwable
ou
un
de
son
sous-classe
:
Object
Throwable
Error
exception
MyCheckedException
RunTimeException
MyUncheckedException
java
diviser
le
classe
de
exception
en
deux
catégorie
:
-
le
exception
non
contrôler
(
unchecked
)
.
ce
exception
concerner
le
cas
'
'
imprévu
`
`
,
ce
est-à-dire
le
situation
où
il
ne
devoir
pas
y
avoir
de
défaillance
en
fonctionnement
normal
.
elle
concerner
du
situation
qui
pouvoir
être
raisonnablement
éviter
(
exemple
:
un
indice
de
tableau
hors
limite
)
.
ce
exception
indiquer
généralement
un
erreur
de
programme
.
elle
avoir
normalement
vocation
à
conduire
à
un
arrêt
immédiat
et
définitif
du
programme
.
-
le
exception
contrôler
(
checked
)
.
ce
exception
concerner
le
cas
`
`
prévu
`
`
,
ce
est-à-dire
le
situation
où
le
programmeur
devoir
se
attendre
à
ce
que
un
opération
pouvoir
échouer
.
elle
concerner
du
situation
de
défaillance
qui
être
au
delà
du
contrôle
du
programmeur
(
exemple
:
un
disque
devenir
plein
rendre
impossible
un
écriture
dans
un
fichier
)
.
ce
exception
avoir
normalement
vocation
à
être
récupérer
pour
permettre
au
programme
de
se
poursuivre
normalement
.
le
gestion
de
un
exception
contrôler
imposer
le
utilisation
de
le
clause
throws
et
de
le
instruction
de
contrôle
try
.
.
catch
.
le
exception
non
contrôler
être
le
classe
RuntimeException
,
Error
et
leur
sous-
classe
;
tout
le
autre
classe
et
sous-classe
être
du
exception
contrôler
.
classe
de
exception
standard
le
hiérarchie
Error
le
classe
Error
être
le
super-classe
de
un
hiérarchie
de
erreur
grave
non
contrôler
.
ce
hiérarchie
être
habituellement
réserver
au
erreur
de
exécution
système
.
exemple
de
sous-
classe
prédéfinie
:
NoSuchMethodError
StackOverFlowError
OutOfMemoryError
IllegalAccessError
le
hiérarchie
exception
le
classe
exception
être
le
super-classe
de
un
hiérarchie
de
exception
,
exclusion
faire
de
le
sous-hiérarchie
RuntimeException
,
contrôler
.
exemple
de
sous-classe
de
exception
contrôler
prédéfinie
:
DataFormatException
IOException
EOFException
FileNotFoundException
le
hiérarchie
RuntimeException
le
classe
RuntimeException
être
le
super-classe
de
un
hiérarchie
de
exception
non
contrôler
.
exemple
de
sous-classe
prédéfinie
:
ArithmeticException
IllegalArgumentException
NumberFormatException
IllegalStateException
IndexOutOfBoundsException
NullPointerException
lancement
de
un
exception
le
instruction
throw
permettre
de
lancer
un
exception
.
il
être
recommander
de
ne
la|le
appliquer
qu
'
à
du
exception
non
contrôler
.
syntaxe
:
throw
new
ClassOfException
(
`
`
diagnostic
message
to
print
'
'
)
;
exemple
:
if
(
key
=
=
null
)
{
throw
new
NullPointerException
(
`
`
null
key
found
in
method
x
'
'
)
;
}
exemple
:
if
(
key
=
=
)
{
throw
new
IllegalArgumentException
(
`
`
empty
key
received
'
'
)
;
}
exemple
(
dans
un
constructeur
)
:
if
(
dns-remplacer
(
)
=
=
)
{
throw
new
IllegalStateException
(
`
`
name
must
be
provided
-
`
`
+
`
`
object
creation
aborted
'
'
)
;
}
exemple
.
le
opération
remove
(
)
de
le
interface
Iterator
être
spécifier
optionnel
,
ce
est-à-dire
que
son
implémentation
pouvoir
être
dans
ce
cas
:
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
capture
de
un
exception
le
capture
de
un
exception
ne
être
obligatoire
que
pour
le
exception
que
la|le
on
vouloir
contrôler
.
dans
le
cas
du
exception
contrôler
,
le
compilateur
renforcer
son
contrôle
à
le
fois
dans
le
méthode
qui
lancer
un
tel
exception
et
dans
le
appelant
de
ce
méthode
.
clause
throws
un
clause
throws
être
un
déclaration
ajouter
à
le
en-tête
de
un
méthode
susceptible
de
lever
un
exception
contrôler
.
elle
déclarer
le
exception
contrôler
à
prendre
en
compte
dans
le
cadre
de
ce
méthode
.
ceci
être
nécessaire
pour
que
le
compilateur
pouvoir
savoir
quel
excepter
contrôler
.
par
convention
,
le
exception
non
contrôler
ne
devoir
pas
être
inclus
dans
un
clause
throws
.
syntaxe
:
throws
ExceptionClass1
,
ExceptionClass2
,
...
exemple
:
public
void
saveToFile
(
string
filename
)
throws
IOException
{
...
}
instruction
try
.
.
catch
le
instruction
try
.
.
catch
permettre
de
capturer
un
exception
générer
par
le
appel
de
un
méthode
.
quand
un
exception
être
générer
,
le
contrôle
être
transférer
du
code
qui
avoir
générer
le
exception
à
le
clause
catch
qui
avoir
capturer
le
exception
.
le
clause
catch
devoir
avoir
un
seul
paramètre
formel
.
le
type
de
ce
paramètre
devoir
être
le
classe
Throwable
ou
un
de
son
sous-classe
.
un
instruction
try
pouvoir
contenir
plusieurs
bloc
catch
.
dans
ce
cas
,
le
exception
le
plus
général
devoir
être
traiter
en
dernier
.
syntaxe
:
try
{
/
/
protect
one
or
more
statement
here
}
catch
(
ExceptionClass
e
)
{
/
/
report
and
recover
from
the
exception
here
}
finally
{
/
/
in
fine
,
in
any
case
,
always
execute
these
statements
}
le
bloc
finally
être
optionnel
,
mais
il
permettre
souvent
de
éviter
le
duplication
de
code
.
exemple
(
à
partir
de
le
plate-forme
)
:
/
/
Read
avoir
double
from
the
standard
input
stream
scanner
input
=
new
scanner
(
dns-remplacer
)
;
double
x
;
try
{
x
=
dns-remplacer
(
)
;
}
catch
(
InputMismatchException
e
)
{
dns-remplacé
(
`
`
Error
-
double
waited
-
`
`
+
e
)
;
}
dns-remplacer
(
)
;
exemple
(
à
partir
de
le
plate-forme
)
:
/
/
Create
avoir
copy
of
avoir
text
filer
scanner
in
=
null
;
PrintWriter
out
=
null
;
try
{
in
=
new
scanner
(
new
file
(
inputFileName
)
)
;
out
=
new
PrintWriter
(
outputFileName
)
;
while
(
dns-remplacer
(
)
)
{
dns-remplacer
(
dns-remplacer
(
)
)
;
}
}
catch
(
exception
e
)
{
dns-remplacé
(
`
`
Error
in
reading
/
writing
file
-
`
`
+
e
)
;
}
finally
{
if
(
in
!
=
null
)
dns-remplacer
(
)
)
;
if
(
out
!
=
null
)
dns-remplacer
(
)
;
}
exemple
(
à
partir
de
le
plate-forme
)
:
/
/
Read
and
print
avoir
text
file
of
double
scanner
in
=
null
;
try
{
in
=
new
scanner
(
new
file
(
inputFileName
)
)
;
while
(
dns-remplacer
(
)
)
{
dns-remplacer
(
dns-remplacer
(
dns-remplacer
(
)
)
)
;
}
}
catch
(
FileNotFoundException
e
)
{
dns-remplacé
(
`
`
Unable
to
open
the
input
file
.
'
'
+
e
)
;
}
catch
(
NumberFormatException
e
)
{
dns-remplacé
(
`
`
à
token
is
not
avoir
double
.
'
'
+
e
)
;
}
catch
(
exception
e
)
'
dns-remplacer
(
`
`
Problem
in
reading
the
filer
`
`
+
e
)
;
}
finally
{
if
(
in
!
=
null
)
{
try
{
dns-remplacer
(
)
;
}
catch
(
exception
e
)
{
dns-remplacé
(
`
`
Error
in
closing
the
file
.
'
'
+
e
)
;
}
}
définir
un
nouveau
classe
de
exception
un
du
principal
raison
conduire
à
le
définition
de
un
nouveau
classe
de
exception
être
le
besoin
de
inclure
du
information
complémentaire
dans
le
objet
exception
afin
de
permettre
le
diagnostic
et
le
récupération
de
le
erreur
.
tout
nouveau
classe
de
exception
être
définir
comme
sous-classe
de
un
classe
de
exception
existant
de
le
hiérarchie
exception
.
exemple
:
public
class
WrongValueException
extends
exception
{
private
string
key
;
public
WrongValueException
(
string
key
)
{
dns-remplacer
=
key
;
}
public
string
getKey
(
)
{
return
key
;
}
public
string
toString
(
)
{
return
`
`
Wrong
valoir
`
`
+
key
+
`
`
found
'
'
;
}
}
annexe
-
programmation
graphique
référence
:
base
de
swing
et
exemple
de
programmation
de
interface
graphique
:
dns-remplacer
/
doc
/
books
/
tutorial
/
uiswing
/
mini
/
dns-remplacé
gestion
du
événement
et
exemple
de
programmation
:
dns-remplacer
/
doc
/
books
/
tutorial
/
uiswing
/
event
/
dns-remplacer
swing
architecturer
Overview
dns-remplacer
/
products
/
jfc
/
isc
/
article
/
architecturer
ce
chapitre
introduire
à
le
programmation
graphique
avec
le
bibliothèque
dns-remplacer
swing
il
exister
deux
grand
paquetage
de
utilitaire
java
pour
réaliser
du
interface
graphique
:
-
AWT
(
abstract
Window
Toolkit
)
:
le
paquetage
primitif
.
le
composant
de
ce
paquetage
se
importer
par
:
import
dns-remplacé
.
*
;
-
swing
:
le
plus
récent
et
le
plus
évoluer
,
construire
sur
AWT
,
ce
être
le
paquetage
recommander
.
le
composant
de
ce
paquetage
se
importer
par
:
import
dns-remplacé
.
*
;
le
deux
paquetage
swing
le
plus
communément
utiliser
être
:
dns-remplacer
dns-remplacer
le
classe
de
dns-remplacé
le
plus
courant
être
:
JFrame
JPanel
JLabel
JTextField
JButton
JOPtionPane
exemple
de
saisie
/
affichage
dans
un
boîte
de
dialogue
:
/
/
import
dns-remplacé
;
/
/
user
method
showInputDialog
to
prompt
for
some
input
string
inputValue
=
dns-remplacer
(
`
`
valoir
?
`
`
)
;
/
/
user
method
showMessageDialog
to
display
avoir
message
dns-remplacé
(
null
,
'
'
à
message
...
'
'
)
conteneur
et
composant
tout
objet
graphique
être
composer
de
différent
objet
:
du
conteneur
(
container
)
et
du
composant
atomique
,
ce
différent
constituant
être
organiser
en
un
hiérarchie
de
inclusion
.
principal
catégorie
de
conteneur
et
composant
:
+
le
conteneur
de
plus
haut
niveau
pour
que
un
objet
graphique
pouvoir
être
afficher
à
le
écran
,
le
hiérarchie
de
son
constituant
devoir
nécessairement
avoir
pour
racine
le
un
du
trois
conteneur
suivant
:
>
Frame
(
classe
JFrame
)
:
conteneur
le
plus
général
,
il
fournir
le
fenêtre
principal
dans
lequel
le
autre
composant
swing
pouvoir
se
dessiner
.
>
Dialog
(
classe
JDialog
)
:
plus
limiter
que
un
Frame
,
il
fournir
un
fenêtre
de
dialogue
;
le
classe
J0ptionPane
permettre
de
créer
du
fenêtre
de
dialogue
simple
et
standard
;
le
classe
JDialog
permettre
de
créer
du
fenêtre
de
dialogue
personnaliser
.
>
Applet
(
classe
JApplet
)
:
spécialiser
pour
du
interface
web
,
il
fournir
un
fenêtre
qui
être
afficher
par
un
navigateur
web
.
+
le
conteneur
intermédiaire
,
notamment
:
>
panel
(
classe
JPanel
)
:
simplifier
le
positionnement
du
objet
graphique
atomique
.
tout
conteneur
de
haut
niveau
contenir
un
conteneur
intermédiaire
spécial
appeler
ContentPane
.
ce
être
le
conteneur
intermédiaire
principal
.
il
contenir
typiquement
un
ou
plusieurs
panel
.
+
le
composant
atomique
,
par
exemple
:
>
Button
(
classe
JButton
)
>
label
(
classe
JLabel
)
>
Text
field
(
classe
JTextField
)
sauf
pour
le
conteneur
de
plus
haut
niveau
,
tout
le
composant
(
conteneur
intermédiaire
ou
composer
atomique
)
qui
commencer
par
J
hériter
de
le
classe
JComponent
.
pour
ajouter
un
objet
à
un
conteneur
,
on
utiliser
un
méthode
add
.
ce
méthode
prendre
en
général
un
deuxième
argument
qui
spécifier
le
mise
en
page
.
exemple
:
/
/
import
dns-remplacé
.
*
;
frame
=
new
JFrame
(
.
.
.
)
;
paner
=
new
JPanel
(
)
;
button
=
new
JButton
(
.
.
.
)
;
label
=
new
JLabel
(
.
.
.
)
;
dns-remplacer
(
button
)
;
dns-remplacer
(
1abel
)
;
dns-remplacer
(
)
.add
(
paner
,
dns-remplacer
)
;
dns-remplacer
(
)
;
/
/
sizes
at
or
above
preferred
sizes
dns-remplacé
(
true
)
;
/
/
le
objet
frame
ainsi
créer
avoir
pour
hiérarchie
:
JFrame
ContentPane
JPanel
JButton
JLabel
exemple
:
import
dns-remplacé
;
public
class
AppletExample
extends
JApplet
{
public
void
init
)
{
JPanel
paner
=
new
JPanel
(
)
;
dns-remplacer
(
new
JLabel
(
`
`
hello
,
World
!
'
'
)
;
dns-remplacer
(
paner
)
;
gestion
de
le
mise
en
page
le
mise
en
page
(
layout
)
consister
à
fixer
le
taille
et
le
position
du
composant
.
tout
conteneur
posséder
un
gestionnaire
de
mise
en
page
par
défaut
.
se
il
ne
convenir|convier
pas
,
on
pouvoir
le
remplacer
.
le
composant
pouvoir
solliciter
un
taille
et
un
alignement
donné
,
mais
,
in
fine
,
ce
être
le
gestionnaire
de
mise
en
page
du
conteneur
qui
conserver
le
décision
final
.
il
exister
gestionnaire
de
mise
en
page
:
+
BorderLayout
:
gestionnaire
de
mise
en
page
par
défaut
pour
tout
ContentPane
;
définir
zone
de
placement
:
NORTH
,
SOUTH
,
EAST
,
WEST
,
CENTER
+
FlowLayout
:
gestionnaire
de
mise
en
page
par
défaut
pour
tout
JPanel
;
positionner
simplement
le
composant
de
gauche
à
droit|droite
,
passer
à
un
nouveau
ligne
si
nécessaire
+
BoxLayout
:
gestionnaire
de
mise
en
page
très
flexible
;
positionner
le
composant
sur
un
seul
ligne
ou
colonne
en
respecter
le
attente
de
composant
en
matière
de
taille
maximal
et
de
alignement
+
GridLayout
:
gestionnaire
de
mise
en
page
très
simple
;
créer
un
ensemble
de
composant
de
même
taille
et
le
affiche
dans
le
nombre
de
ligne
et
de
colonne
spécifier
+
GridBagLayout
:
gestionnaire
de
mise
en
page
le
plus
sophistiqué
et
le
plus
flexible
;
aligner
le
composant
en
le
placer
dans
un
grille
de
cellule
,
permettre
à
certain
de
se
étendre
sur
plusieurs
cellule
(
le
largeur
du
rangée
et
le
hauteur
du
colonne
,
respectivement
,
pouvoir
être
différent
)
+
CardLayout
:
gestionnaire
de
mise
en
page
pour
usage
spécial
;
permettre
de
implémenter
un
zone
qui
contenir
différent
composant
à
différent
moment
;
utiliser
en
combinaison
avec
de
autre
gestionnaire
de
mise
en
page
exemple
de
changement
du
gestionnaire
de
mise
en
page
par
défaut
:
JPanel
paner
=
new
JPanel
(
)
;
dns-remplacer
(
new
BorderLayout
(
)
)
;
le
taille
et
le
alignement
de
un
composant
pouvoir
être
spécifier
par
le
méthode
suivant
:
setMinimumSize
,
setPreferredSize
,
setMaximumSize
,
setAlignmentX
,
setAlignmentY
.
gestion
du
événement
notion
de
événement
à
chaque
fois
que
le
utilisateur
agir
sur
le
clavier
ou
le
souris
,
un
événement
survenir
,
un
objet
événement
être
générer
.
un
objet
événement
être
un
objet
contenir
du
information
sur
le
source
et
le
nature
de
le
événement
survenir
.
swing
offrir
du
interface
(
au
sens|sen
java
)
appeler
`
`
écouteur
de
événement
`
`
(
event
listeners
)
qui
permettre
de
capter
le
événement
de
façon
sélectif
afin
de
pouvoir
la|le
traiter
.
event
source
event
object
event
listener
event
listener
event
listener
exemple
de
événement
type
de
Listener
clic
de
un
bouton
graphique
ou
enfoncement
de
le
touche
return
ActionListener
lors
de
un
saisie
dans
un
champ
texte
fermeture
de
un
fenêtre
WindowListener
graphique
(
frame
)
clic
de
le
souris
lors
du
passage
du
curseur
sur
un
composant
MouseListener
graphique
afin
de
faciliter
le
travail
du
programmeur
,
swing
associer
généralement
à
chaque
interface
Listener
un
classe
adaptateur
(
adapter
)
.
si
ce
adaptateur
exister
,
ce
être
avec
lui
que
la|le
on
travailler
.
exemple
de
interface
Listener
classer
adapter
associer
ActionListener
none
WindowListener
WindowAdapter
MouseListener
MouseAdapter
KeyListener
KeyAdapter
réaliser
un
gestionnaire
de
événement
réaliser
un
gestionnaire
de
événement
(
event
handler
)
requérir
trois
élément
de
code
:
+
déclarer
un
classe
gestionnaire
de
événement
:
ce
classe
devoir
implémenter
un
interface
Listener
ou
étendre
un
classe
adapter
exemple
:
import
dns-remplacé
.
*
;
public
class
MyClass
implements
ActionListener
{
.
.
.
}
+
définir
dans
ce
classe
gestionnaire
de
événement
le
méthode
de
le
interface
Listener
exemple
:
public
void
actionPerformed
(
ActionEvent
e
)
{
.
.
.
}
+
définir
un
instance
de
ce
classe
gestionnaire
de
événement
et
la|le
enregistrer
sur
le
(
s
)
composer
(
s
)
concerner
(
s
)
exemple
:
dns-remplacer
(
instanceOfMyClass
)
;
le
type
ActionListener
permettre
de
définir
le
gestionnaire
de
événement
le
plus
simple
et
le
plus
commun
.
lorsque
un
événement
de
ce
type
être
générer
(
clic
de
un
bouton
graphique
ou
enfoncement
de
le
touche
return
lors
de
un
saisie
dans
un
champ
texte
)
,
un
message
actionPerformed
être
envoyer
à
tout
le
écouteur
de
événement
qui
être
enregistrer
sur
le
composant
concerner
.
un
classe
gestionnaire
de
événement
être
généralement
implanter
sous
le
forme
de
un
classe
interne
(
inner
class
)
au
sein
de
un
classe
graphique
.
exemple
:
/
/
Ecriture
de
un
MouseListener
public
class
myClass
extends
JPanel
{
...
dns-remplacer
(
new
MyAdapter
(
)
)
;
...
class
MyAdapter
extends
MouseAdapter
{
public
void
mouseClicked
(
MouseEvent
e
)
{
...
}
}
}
typiquement
,
un
classe
gestionnaire
de
événement
être
implanter
sous
le
forme
de
un
classe
interne
anonyme
.
exemple
(
solution
équivalent
à
celui
de
le
exemple
précédent
)
:
/
/
Ecriture
de
un
MouseListener
public
class
myClass
extends
JPanel
{
...
dns-remplacer
(
new
MouseAdapter
(
)
{
public
void
mouseClicked
(
MouseEvent
e
)
{
...
}
}
)
;
...
}
affichage
/
fermeture
de
un
fenêtre
graphique
le
affichage
/
le
masquage
de
un
fenêtre
graphique
de
type
JFrame
se
commander
par
le
méthode
setVisible
.
quand
le
utilisateur
ferme
un
fenêtre
graphique
de
type
JFrame
,
ce
fenêtre
ne
être
en
faire
,
par
défaut
,
que
masquer
.
Quoiqu'invisible
,
le
objet
graphique
exister
toujours
et
le
programme
pouvoir
à
nouveau
le
rendre
visible
.
si
la|le
on
désirer
un
comportement
différent
,
il
être
nécessaire
:
-
soit
de
enregistrer
sur
ce
objet
graphique
un
gestionnaire
de
événement
de
type
WindowListener
et
de
capter
le
message
windowClosing
-
soit
de
spécifier
le
comportement
par
défaut
en
utiliser
le
méthode
setDefaultCloseOperation
.
le
comportement
être
indiquer
en
argument
par
un
constant
(
définir
dans
le
interface
WindowConstant
)
.
exemple
de
argument
:
DISPOSE_ON_CLOSE
architecture
du
composant
swing
objectif
:
du
application
facilement
adaptable
.
le
architecture
du
composant
swing
être
baser
sur
un
adaptation
de
le
très
renommé
architecture
MVC
(
`
`
Modèle-Vue-Contrôleur
`
`
;
voir
section
)
.
dans
le
communauté
swing
,
elle
être
appeler
`
`
architecture
à
modèle
séparable
`
`
:
le
partie
modèle
de
un
composant
swing
(
partie
qui
représenter
le
donnée
de
le
application
)
être
traiter
comme
un
élément
séparer
,
tout
comme
le
préconiser
le
conception
MVC
;
mais
swing
fusionner
le
parti
vue
(
qui
prendre
en
charge
le
représentation
visuel
du
donnée
)
et
contrôleur
(
qui
traiter
le
entrée
utilisateur
)
de
chaque
composant
en
un
seul
objet
interface
utilisateur
(
user
interface
Object
)
.
il
être
en
général
considérer
comme
un
bon
pratique
de
centrer
le
architecture
de
un
application
autour
de
son
donnée
plutôt
que
autour
de
son
interface
utilisateur
.
pour
supporter
ce
paradigme
[
]
,
swing
définir
un
interface
modeler
séparer
pour
chaque
composant
.
ce
séparation
fournir
au
programme
de
application
le
possibilité
de
connecter
facilement
du
composant
swing
dans
son
implémentation
modeler
propre
.
le
table
suivant
montrer
le
interface
modeler
offrir
par
le
composant
swing
:
Component
Model
interface
Model
typer
JButton
ButtonModel
gui
JToggleButton
ButtonModel
gui
/
dater
JCheckBox
ButtonModel
gui
/
dater
JRadioButton
ButtonModel
gui
/
dater
JMenu
ButtonModel
gui
JMenuItem
ButtonModel
gui
JCheckBoxMenuItem
ButtonModel
gui
/
dater
JRadioButtonMenuItem
ButtonModel
gui
/
dater
JComboBox
ComboBoxModel
dater
JProgressBar
BoundedRangeModel
gui
/
dater
JScrollBar
BoundedRangeModel
gui
/
dater
Slider
BoundedRangeModel
gui
/
dater
Component
Model
interface
Model
typer
JTabbedPane
SingleSelectionModel
gui
JList
ListModel
dater
JList
ListSelectionModel
gui
JTable
TableModel
dater
JTable
TableColumnModel
gui
JTree
TreeModel
dater
JTree
TreeSelectionModel
gui
JEditorPane
document
dater
JTextPane
document
dater
JTextArea
document
dater
JTextField
document
dater
JPasswordField
document
dater
le
interface
modeler
fournir
par
swing
relever
de
deux
grand
catégorie
:
le
type
'
'
Etat
de
le
interface
graphique
`
`
(
gui
)
,
qui
définir
le
statut
visuel
du
commande
de
le
interface
graphique
;
et
le
type
`
`
donnée
de
application
`
`
(
dater
)
,
qui
représenter
du
donnée
quantifiable
avoir
sens|sen
pour
le
application
.
certain
modèle
relever
de
type
partager
(
gui
/
dater
)
.
il
être
recommander
de
utiliser
le
catégorie
`
`
donnée
de
application
`
`
(
dater
)
du
modèle
de
swing
car
il
renforcer
grandement
le
adaptabilité
et
le
modularité
du
application
sur
le
long
terme
.
[
]
un
paradigme
être
un
vision
du
monde
qui
reposer
sur
un
modèle
.
Applet
java
permettre
de
créer
deux
type
de
programme
:
-
du
application
,
qui
se
exécuter
directement
sous
le
contrôle
de
le
machine
virtuel
java
-
du
appliquette
(
ou
applette
;
en
anglais
:
applet
)
destiner
à
être
exécuter
par
un
navigateur
Web
pour
réaliser
un
applette
,
le
minimum
consister
à
:
-
créer
un
sous-classe
de
le
classe
JApplet
(
voir
section
)
-
y
créer
le
méthode
init
(
)
,
qui
être
lancer
par
le
navigateur
-
référencer
ce
classe
dans
le
balise
<
APPLET
coder
=
...
>
de
un
fichier
HTML
syntaxe
:
import
dns-remplacé
;
public
class
AppletClassName
extends
JApplet
{
/
/
...
Fields
...
public
void
init
)
{
;
...
}
}
syntaxe
:
<
APPLET
coder
=
'
'
dns-remplacer
'
'
WIDTH
=
anint
HEIGHT
=
anint
>
<
/
APPLET
>
annexe
-
THREADS
référence
:
programmation
concurrent
,
processus
,
threads
dns-remplacer
/
doc
/
books
/
tutorial
/
essential
/
concurrency
/
dns-remplacer
le
threads
permettre
de
programmer
du
tâche
qui
,
à
le
intérieur
de
un
même
programme
,
se
exécuter
concurremment
.
ce
être
du
processus
léger
.
le
tâche
à
exécuter
par
un
thread
devoir
être
implémenter
dans
un
méthode
run
(
)
.
il
exister
deux
façon
de
fournir
le
méthode
run
(
)
:
-
définir
un
sous-classe
de
le
classe
Thread
et
y
redéfinir
le
méthode
run
(
)
-
définir
un
classe
qui
implémente
le
interface
Runnable
et
y
définir
le
méthode
run
(
)
créer
un
thread
par
extension
de
le
classe
Thread
exemple
:
/
/
Example
of
defining
avoir
thread
avoir
extending
Thread
public
class
SimpleThread
extends
Thread
{
public
SimpleThread
(
string
threadName
)
{
super
(
threadName
)
;
}
/
/
The
task
of
this
thread
is
to
print
times
its
name
/
/
at
avoir
random
rater
public
void
run
(
)
{
for
(
int
i
=
;
i
<
;
i++
)
{
dns-remplacer
(
i
+
`
`
`
`
+
getName
(
)
)
;
try
{
sleep
(
(
long
)
(
dns-remplacer
(
)
*
)
)
;
}
catch
(
InterruptedException
e
)
{
}
}
dns-remplacé
(
`
`
DONE
!
`
`
'
'
+
getName
(
)
)
;
}
}
/
/
end
class
SimpleThread
/
/
Example
of
running
two
threads
concurrently
.
/
/
`
`
Jamaica
'
'
and
`
`
Fiji
'
'
Will
be
printed
randomly
times
.
public
static
void
main
(
string
[
]
args
)
{
new
SimpleThread
(
`
`
Jamaica
'
'
)
.start
(
)
;
new
SimpleThread
(
`
`
Fiji
'
'
)
.start
(
)
;
}
créer
un
thread
par
implémentation
de
le
interface
Runnable
ce
façon
de
faire
se
imposer
lorsque
le
classe
à
créer
devoir
sous-classer
un
classe
quelconque
(
le
cas
typique
être
un
Applet
)
,
parce
que
java
ne
supporter
pas
le
héritage
multiple
.
exemple
:
/
/
Example
of
defining
avoir
thread
avoir
implementing
Runnable
public
class
SimpleThread
implements
Runnable
{
string
threadName
;
public
SimpleThread
(
string
threadName
)
{
dns-remplacer
=
threadName
;
}
/
/
The
task
of
this
thread
is
to
print
times
its
name
/
/
at
avoir
random
rater
public
void
run
(
)
{
for
(
int
i
=
;
i
<
;
i++
)
{
dns-remplacer
(
i
+
`
`
`
`
+
threadName
)
;
try
{
dns-remplacer
(
(
long
)
(
dns-remplacer
(
)
*
)
)
;
}
catch
(
InterruptedException
e
)
{
}
}
dns-remplacé
(
`
`
DONE
!
'
'
+
threadName
)
;
}
}
/
/
end
class
SimpleThread
/
/
Example
of
running
two
threads
concurrently
/
/
(
`
`
Jamaica
'
'
and
`
`
Fiji
'
'
Will
be
printed
randomly
times
)
public
static
void
main
(
string
[
]
args
)
{
new
Thread
(
new
SimpleThread
(
`
`
Jamaica
'
'
)
)
.start
(
)
;
new
Thread
(
new
SimpleThread
(
`
`
Fiji
'
'
)
)
.start
(
)
;
}
synchronisation
et
communication
entre
threads
section
critique
et
synchronisation
dans
un
programme
,
du
segment
de
code
qui
accéder
à
un
même
donner
depuis
du
threads
concurrent
être
appeler
section
critique
.
lorsque
deux
threads
concurrent
invoquer
du
méthode
qui
opérer
sur
un
même
donnée
partager
(
méthode
critique
)
,
il
être
nécessaire
que
java
pouvoir
synchroniser
ce
méthode
afin
de
garantir
un
accès
sûr
à
le
information
.
à
ce
fin
,
chacun
de
ce
méthode
devoir
être
déclarer
avec
le
modificateur
synchronized
.
à
le
exécution
,
le
accès
à
le
donnée
partagé
être
ainsi
automatiquement
verrouiller
tant
que
elle
être
utiliser
par
un
méthode
critique
.
exemple
:
get
et
pouvoir
être
supposer
deux
méthode
critique
de
le
objet
partager
.
public
synchronized
int
get
(
)
{
...
}
public
synchronized
void
pouvoir
(
int
valoir
)
{
...
}
communication
entre
threads
pour
que
deux
threads
,
processus
indépendant
qui
se
dérouler
de
façon
asynchrone
,
pouvoir
se
communiquer
du
donnée
,
il
être
nécessaire
que
il
savoir
se
synchroniser
autour
de
un
sas
de
communication
.
le
thread
émetteur
de
le
donnée
être
appeler
producteur
;
le
thread
destinataire
de
le
donnée
être
appeler
consommateur
.
le
thread
producteur
de
le
donnée
devoir
être
capable
de
:
-
attendre
que
le
espace
de
stockage
du
sas
de
communication
être
libre
;
-
puis
y
déposer
un
nouveau
donnée
;
-
puis
informer
le
threads
consommateur
de
le
mise
à
disposition
de
le
donnée
.
de
façon
symétrique
,
le
thread
consommateur
de
le
donnée
devoir
être
capable
de
:
-
attendre
que
le
donnée
être
mettre
à
disposition
dans
le
espace
de
stockage
du
sas
de
communication
;
-
puis
lire
ce
donnée
;
-
puis
informer
le
threads
producteur
de
le
disponibilité
du
sas
de
communication
ou
lui
accuser
réception
.
ce
être
au
sas
de
communication
que
on
confier
le
charge
de
ce
synchronisation
.
le
mise
en
attente
se
réaliser
par
le
méthode
wait
(
)
,
le
notification
au
autre
threads
par
le
méthode
notify
(
)
ou
notifyAll
(
)
.
ce
méthode
être
tout
deux
définir
dans
le
classe
Object
(
)
.
exemple
de
classe
définir
un
sas
de
communication
de
un
seul
élément
de
type
entier
(
attribut
content
)
.
y
noter
en
particulier
le
sécurisation
apporter
par
le
usage
de
un
while
et
non
de
un
if
afin
de
prévenir
de
faux
réveil
éventuel
.
public
class
CubbyHole
{
private
int
content
;
private
boolean
available
=
false
;
public
synchronized
int
get
(
)
{
/
/
called
by
consumer
while
(
available
=
=
false
)
{
try
{
wait
(
)
;
/
/
wait
for
Producer
to
pouvoir
valoir
}
catch
(
InterruptedException
e
)
(
)
{
}
}
available
=
false
;
notifyAll
(
)
;
return
content
;
}
public
synchronized
void
pouvoir
(
int
x
)
{
/
/
called
by
Producer
while
(
available
=
=
true
)
{
try
{
wait
(
)
;
/
/
wait
for
consumer
to
get
valoir
}
catch
(
InterruptedException
e
)
(
)
{
}
}
content
=
x
;
available
=
true
;
notifyAll
(
)
;
}
annexe
-
conception
et
DEVELOPPEMENT
en
java
référence
:
architecture
Modèle-Vue-Contrôleur
:
dns-remplacer
/
blueprints
/
guidelines
/
designing_enterprise_applications_2e
/
app-arch
/
dns-remplacer
développement
de
test
unitaire
avec
le
cadre
de
application
JUnit
:
dns-remplacer
/
doc
/
cookbook
/
dns-remplacer
JavaBeans
:
dns-remplacer
/
products
/
javabeans
/
dns-remplacer
/
doc
/
books
/
tutorial
/
javabeans
/
dns-remplacé
design
pattern
:
ce
section
aller
au-delà
du
langage
java
pour
aborder
quelque
aspect
de
le
conception
et
du
développement
de
programme
java
.
conseil
général
pour
un
bon
conception
du
classe
rechercher
un
couplage
faible
.
le
couplage
décrire
le
interconnectivité
entre
le
classe
.
le
couplage
être
faible
quand
chaque
classe
être
largement
indépendant
du
autre
et
communiquer
avec
elle
via
un
interface
petit
et
bien
définir
(
le
interface
de
un
classe
être
le
partie
visible
publique
de
ce
classe
:
elle
se
définir
typiquement
par
le
liste
du
membre
(
attribut
,
constructeur
,
méthode
)
non
priver
associer
à
leur
commentaire
de
documentation
)
.
rechercher
un
COHESION
fort
.
le
cohésion
décrire
le
adéquation
entre
un
unité
de
code
et
un
entité
ou
tâche
logique
.
le
cohésion
être
fort
quand
chaque
unité
de
code
(
méthode
,
classe
,
module
,
...
.
.
)
être
responsable
de
un
entité
ou
tâcher
très
bien
définir
.
utiliser
au
maximum
le
encapsulation
.
le
encapsulation
être
un
technique
de
base
pour
réduire
le
couplage
.
elle
contribuer
à
séparer
le
quoi
et
le
comment
,
le
vue
et
le
implémentation
,
le
définition
et
le
utilisation
.
principe
de
base
:
rendre
le
attribut
priver
et
utiliser
du
méthode
de
accès
.
DECOUPLER
ENTREES
,
traitement
et
sortir
.
voir
en
particulier
section
adopter
un
conception
DIRIGEE
par
le
responsabilité
.
le
attribution
du
bon
responsabilité
au
bon
classe
être
le
un
du
problème
le
plus
délicat
de
le
conception
orienter
objet
.
le
programmation
diriger
par
le
responsabilité
être
un
processus
de
conception
de
classe
par
attribution
de
responsabilité
bien
définir
à
chaque
classe
.
ce
approche
pouvoir
être
utiliser
pour
déterminer
quel
classer
devoir
implémenter
tel
fonctionnalité
.
un
conception
diriger
par
le
responsabilité
contribuer
à
réduire
le
couplage
.
EVITER
le
duplication
de
code
.
Eviter
que
un
même
segment
de
code
ne
se
retrouver
plus
de
un
fois
dans
un
application
.
utiliser
le
HERITAGE
à
bon
escient
.
le
héritage
être
un
relation
`
`
est_un
`
`
,
pas
un
relation
'
'
a_un
`
`
.
dans
un
hiérarchie
de
héritage
,
le
objet
devoir
avoir
un
relation
`
`
est_un
`
`
avec
leur
classe
de
base
,
afin
que
le
héritage
de
tout
le
attribut
,
propriété
et
méthode
de
le
classe
de
base
garder
sens|sen
(
même
si
le
sous-classe
en
spécialiser
ou
le
complet
)
.
le
objet
ne
relever
pas
strictement
de
un
relation
`
`
est_un
`
`
devoir
se
traduire
par
du
classe
ou
interface
sans
relation
de
héritage
entre
elle
.
limiter
le
taille
et
COMPLEXITE
.
ne
pas
mettre
trop
de
chose
dans
un
méthode
:
un
méthode
être
trop
longue
si
elle
faire
plus
de
un
tâche
logique
.
ne
pas
tout
mettre
dans
un
seul
classe
:
un
classe
être
trop
complexe
si
elle
représenter
plus
de
un
entité
logique
.
chercher
à
faciliter
du
changement
localiser
.
réaliser
du
changement
dans
un
classe
ne
devoir
avoir
que
un
minimum
de
impact
sur
le
autre
classe
.
le
localisation
du
changement
être
le
un
du
but
rechercher
de
un
bon
conception
de
classe
.
elle
être
le
produit
de
un
couplage
faible
et
de
un
cohésion
fort
.
architecture
de
un
application
interactif
:
le
modèle
MVC
le
architecture
Modèle-Vue-Contrôleur
(
Model-View-Controller
,
MVC
)
être
un
modèle
de
architecture
logicielle
recommander
-
et
largement
utiliser
-
pour
le
conception
de
application
interactif
.
ce
modèle
viser
à
minimiser
le
degré
de
couplage
entre
le
objet
de
le
application
en
découpler
structurellement
entrer
,
traitement
et
sortir
.
le
point
essentiel
consister
à
séparer
le
objet
relever
de
le
interface
utilisateur
du
objet
métier
,
afin
de
pouvoir
la|le
faire
évoluer
indépendamment
et
la|le
réutiliser
.
MVC
organiser
un
application
interactif
en
trois
grand
composante
:
le
modèle
,
le
vue
et
le
contrôleur
,
et
découpler
leur
responsabilité
respectif
:
+
le
MODELE
encapsuler
le
fonctionnalité
et
le
donné
cœur
de
le
application
.
il
être
indépendant
de
représentation
de
sortie
spécifique
ou
de
un
comportement
de
entrée
.
il
avoir
à
charge
le
représentation
interne
du
donnée
de
le
application
et
le
logique
de
gestion
de
ce
donnée
.
il
notifier
à
le
composant
vue
le
changement
de
donnée
et
lui
permettre
de
la|le
interroger
sur
son
état
.
il
fournir
au
contrôleur
le
possibilité
de
accéder
à
certain
fonctionnalité
applicatives
encapsuler
dans
le
modèle
.
+
le
vue
afficher
le
information
à
le
utilisateur
.
elle
récupérer
du
modèle
le
donnée
à
présenter
à
le
utilisateur
,
spécifier
leur
présentation
externe
et
mettre
à
jour
le
information
afficher
.
elle
relayer
aussi
au
contrôleur
le
entrée
utilisateur
et
la|le
autoriser
à
sélectionner
le
vue
.
le
séparation
du
modèle
de
un
part
et
de
le
vue
et
du
contrôleur
de
autre
part
permettre
du
vue
multiple
de
un
même
modèle
.
quand
il
y
avoir
plusieurs
vue
du
modèle
,
chaque
vue
avoir
alors
un
contrôleur
associé
.
+
le
CONTROLEUR
gérer
le
entrée
utilisateur
.
il
recevoir
le
entrée
,
généralement
sous
forme
de
événement
encoder
un
mouvement
de
le
souris
,
le
activation
de
un
bouton
,
ou
un
entrée
clavier
(
ou
bien
,
se
il
se
agir
de
un
application
web
,
le
requête
HTTP
GET
et
POST
)
.
le
événement
être
traduire
en
requête
de
service
pour
le
modèle
ou
le
vue
.
un
application
avoir
typiquement
un
contrôleur
pour
chaque
ensemble
de
fonctionnalité
apparenté
.
un
application
pouvoir
avoir
un
contrôleur
séparer
par
type
de
client
si
le
interaction
utilisateur
varier
selon
le
type
de
client
.
le
utilisateur
interagir
avec
le
système
uniquement
au
travers
du
contrôleur
.
le
ensemble
voir
+
contrôleur
composer
le
interface
utilisateur
.
modèle
interrogation
de
état
notification
de
changement
changement
de
état
voir
requêter
utilisateur
sélection
de
vue
contrôleur
invocation
de
méthode
Evènements
en
pratique
,
ce
schéma
de
principe
laisser
place
à
un
grand
variété
de
implémentations
possible
.
un
du
difficulté
pour
un
implémentation
idéal
en
java
résider
notamment
dans
le
fait
que
le
composant
graphique
swing
fusionner
le
partie
voir
et
contrôleur
(
cf
section
)
.
pour
le
petit
programme
tout
particulièrement
,
le
vue
et
le
contrôleur
être
souvent
combiner
,
mais
dans
tout
le
cas
le
modèle
devoir
être
séparer
.
exemple
de
implémentation
de
un
architecture
MVC
:
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacer
;
import
dns-remplacé
;
public
class
Controller
extends
JApplet
implements
ActionListener
{
private
View
view
;
private
Model
model
;
public
void
init
(
)
{
model
=
new
Mode1
(
)
;
view
=
new
View
(
model
,
this
)
;
dns-remplacer
(
view
)
;
dns-remplacer
(
view
)
;
}
public
void
actionPerformed
(
ActionEvent
e
)
{
/
/
process
the
event
}
}
public
class
View
extends
JPanel
implements
observer
{
private
Model
model
;
/
/
Declare
here
the
JPanel
components
.
public
View
(
Model
m
,
ActionListener
listener
)
{
model
=
m
;
makeContentPane
(
listener
)
;
}
public
void
update
(
observable
o
,
Object
arg
)
{
/
/
Automatically
called
when
observer
is
notified
.
/
/
Update
the
view
.
}
public
void
makeContentPane
(
ActionListener
listener
)
{
/
/
Create
and
initialize
the
JPanel
components
and
,
/
/
when
need
be
,
attach
them
the
event
listener
.
/
/
Define
the
layout
.
}
}
public
class
Model
extends
observable
{
/
/
Wherever
the
valoir
of
an
attribute
interesting
the
/
/
View
is
changed
,
insert
these
two
statements
/
/
setChanged
(
)
;
/
/
notifyObservers
(
)
;
or
notifyObservers
(
arg
)
;
}
chercher
à
découpler
le
traitement
du
entrées-sortie
être
classique
en
programmation
.
dans
ce
esprit
,
on
pouvoir
noter
en
particulier
que
le
modèle
MVC
avoir
un
certain
similitude
avec
le
classique
architecture
trois-tiers
(
three-tiers
)
du
système
distribuer
.
un
architecture
trois-
tiers
être
un
architecture
logicielle
client-serveur
dans
lequel
le
interface
utilisateur
,
le
logique
de
traitement
et
le
donnée
être
trois
module
indépendant
:
le
interface
utilisateur
être
stocker
dans
le
client
,
le
gros
de
le
logique
de
le
application
être
stocker
dans
le
ou
le
serveur
de
application
,
et
le
donnée
être
stocker
dans
un
serveur
de
base
de
donnée
.
exemple
.
pour
du
application
web
professionnel
reposer
sur
un
solution
java
EE
(
voir
chapitre
)
,
le
modèle
être
assurer
par
du
EJB
et
/
ou
du
JavaBeans
,
le
contrôleur
être
assurer
par
du
servlets
,
et
le
vue
par
du
JSP
(
glossaire
en
chapitre
)
.
test
unitaire
définition
le
test
être
un
activité
qui
consister
à
déterminer
si
un
segment
de
code
(
méthode
,
classe
ou
programme
)
produire
bien
le
résultat
attendre
.
on
définir
classiquement
trois
niveau
de
test
,
qui
être
mettre
en
œuvre
successivement
:
+
le
test
unitaire
(
unir
testing
)
:
il
se
agir
de
tester
chaque
composante
individuel
(
méthode
,
classe
)
de
le
application
.
+
le
test
de
intégration
(
integration
testing
)
:
il
se
agir
de
tester
du
groupe
de
classe
en
interrelation
puis
tout
le
application
dans
son
ensemble
.
le
test
appliqué
suivre
généralement
un
plan
de
test
(
i.e.
.
un
approche
systématique
et
méthodique
)
.
+
le
test
système
(
system
testing
)
:
il
se
agir
de
tester
le
application
intégrer
dans
son
environnement
de
utilisation
complet
.
ce
test
entrer
dans
le
catégorie
du
test
boîte
noir
,
et
,
en
tant
que
tel
,
ne
devoir
pas
nécessiter
de
connaissance
de
le
conception
interne
du
code
ou
de
son
logique
.
le
considération
suivant
se
limiter
essentiellement
au
test
unitaire
.
un
cas
de
test
être
un
ensemble
de
condition
ou
variable
à
partir
duquel
un
testeur
déterminer
si
un
exigence
requis
être
complètement
ou
partiellement
satisfaire
.
un
cas
de
test
être
caractériser
par
un
entrée
connaître
(
pré-condition
)
et
un
sortie
attendre
(
post-
condition
)
.
de
nombreux
cas
de
test
pouvoir
être
nécessaire
pour
vérifier
un
exigence
donner
.
on
distinguer
généralement
deux
type
de
cas
de
test
:
-
le
cas
de
test
positif
,
qui
consister
à
tester
du
cas
censé
faire
réussir
le
fonctionnalité
.
ce
test
devoir
nous
convaincre
que
le
élément
de
code
tester
fonctionner
bien
comme
espérer
.
-
le
cas
de
test
négatif
,
qui
consister
à
tester
du
cas
censé
mettre
en
échec
le
fonctionnalité
.
ce
être
tout
le
situation
de
valeur
hors
limite
,
de
erreur
,
...
.
exemple
:
entrer
un
valeur
hors
plage
,
lire
un
ensemble
vide
,
...
.
dans
de
tel
cas
,
nous
devoir
nous
attendre
à
ce
que
le
programme
traiter
le
erreur
de
un
façon
contrôler
et
approprier
.
le
simple
correction
du
erreur
détecter
par
un
test
devoir
systématiquement
améliorer
le
qualité
du
programme
.
malheureusement
,
le
expérience
montrer
que
tout
changement
dans
le
programme
pouvoir
introduire
,
de
façon
inattendu
,
de
autre
erreur
.
en
particulier
du
erreur
de
régression
(
regression
bugs
)
:
un
erreur
de
régression
survenir
quand
un
fonctionnalité
qui
fonctionner
précédemment
ne
fonctionner
plus
suite
à
un
modification
du
programme
.
un
méthode
courant
de
test
de
non-régression
(
non-regression
testing
)
consister
à
réexécuter
le
test
réaliser
antérieurement
et
voir
si
du
défaut
apparaître
voire
réapparaître
.
le
test
devant
donc
être
appliquer
non
pas
un
seul
fois
mais
à
chaque
modification
du
logiciel
,
il
être
souhaitable
de
disposer
de
un
batterie
de
test
programmer
afin
de
permettre
un
automatisation
du
test
.
il
se
agir
donc
de
programmer
du
cas
de
test
pour
chaque
méthode
non
trivial
,
en
veiller
à
ce
que
chaque
cas
de
test
être
bien
séparer
du
autre
.
JUnit
JUnit
,
développer
par
le
communauté
open
source
,
offrir
un
cadre
de
application
(
framework
)
pour
le
programmation
de
test
de
régression
.
il
être
utiliser
pour
implémenter
du
test
unitaire
en
java
.
le
classe
TestCase
permettre
de
définir
un
cas
de
test
;
le
classe
Assert
fournir
un
ensemble
de
méthode
faciliter
le
gestion
du
erreur
détecter
;
le
classe
TestSuite
permettre
de
exécuter
un
suite
de
test
;
le
classe
TestRunner
être
un
outil
de
exploitation
permettre
de
définir
un
suite
de
test
à
exécuter
et
de
afficher
le
résultat
.
exemple
de
cas
de
test
:
/
*
*
*
à
test
caser
for
the
class
MyClass
*
/
import
dns-remplacé
.
*
;
public
class
TestMyClass
extends
TestCase
{
/
*
The
test
need
to
run
against
the
background
of
à
known
*
set
of
objects
.
This
set
of
objects
is
called
à
test
*
fixture
.
*
Define
here
an
instance
variable
for
each
partir
of
the
*
fixture
.
*
/
private
MyClass
myObject
;
public
TestMyClass
(
string
name
)
{
super
(
name
)
;
}
/
*
*
*
set
up
the
test
fixture
.
*
setUp
(
)
is
called
before
every
test
caser
method
.
*
Initialize
the
instance
variable
.
*
/
protected
void
setUp
(
)
{
myObject
=
new
MyClass
(
.
.
.
)
;
}
/
*
*
*
Tears
down
the
test
fixture
.
*
tearDown
(
)
is
called
after
every
test
caser
method
.
*
Releases
any
permanent
resource
allocated
in
setUp
*
(
example
:
clore
file
,
...
)
*
/
protected
void
tearDown
(
)
{
/
/
...
}
/
/
once
the
fixture
is
in
place
,
avoir
many
test
case
avoir
/
/
necessary
can
be
written
.
/
*
*
*
test
the
method
methodX
(
)
*
/
public
void
testMethodX
(
)
{
ArgumentType
argument
=
.
.
.
;
ResponseType
expectedResponse
=
.
.
.
;
string
errorMessage
=
`
`
.
.
.
`
`
;
assertTrue
(
errorMessage
,
dns-remplacer
(
MethodX
(
argument
)
)
;
}
}
/
/
end
class
TestMyClass
JUnit
déterminer
le
succès
où
le
échec
de
un
test
via
du
instruction
de
assertion
.
un
assertion
être
simplement
un
procédure
de
comparaison
entre
un
valeur
espérer
et
un
valeur
effectif
et
qui
générer
un
échec
en
cas
de
différence
.
le
procédure
de
assertion
disponible
être
définir
dans
le
classe
dns-remplacé
.
exemple
de
instruction
de
assertion
:
assertTrue
(
errorMessage
,
booleanCondition
)
;
assertFalse
(
errorMessage
,
booleanCondition
)
;
assertEquals
(
errorMessage
,
expectedValue
,
actualValue
)
;
assertEquals
(
errorMessage
,
doubleExpected
,
doubleActual
,
doubleDelta
)
;
pour
exécuter
le
test
,
créer
un
instance
de
ce
classe
avec
en
paramètre
le
nom
de
le
méthode
de
test
.
exemple
new
TestMyClass
(
`
`
testMethodX
'
'
)
;
JUnit
être
intégrer
dans
certain
outil
de
développement
.
de
tel
outil
offrir
alors
du
fonctionnalité
qui
permettre
de
créer
facilement
du
test
.
java
Beans
un
java
Bean
(
`
`
grain
java
`
`
)
être
définir
par
Sun
comme
`
`
un
composant
réutilisable
java
destiner
à
être
manipuler
par
un
outil
de
développement
graphique
visuel
`
`
.
le
java
Beans
être
du
composant
java
(
i.e.
.
du
classe
)
respecter
certain
critère
afin
de
pouvoir
être
facilement
développer
,
assembler
et
réutiliser
pour
créer
du
application
sophistiqué
.
par
exemple
,
le
technologie
java
Beans
être
le
architecture
du
composant
dans
le
plate-forme
java
se
.
le
obligation
que
devoir
respecter
un
java
Bean
être
nombreux
mais
le
enjeu
être
de
importance
:
disposer
de
composant
`
`
Write
One
,
run
Anywhere
`
`
(
WORA
)
réutilisable
.
le
java
Beans
être
du
classe
publique
concret
qui
avoir
pour
caractéristique
commune
de
:
+
supporter
du
`
`
propriété
`
`
:
le
propriété
être
le
attribut
discret
nommer
de
un
java
Bean
qui
pouvoir
affecter
son
apparence
ou
son
comportement
.
le
propriété
être
pour
le
java
Beans
le
équivalent
du
champ
pour
le
objet
.
par
exemple
,
un
bouton
graphique
pouvoir
avoir
un
propriété
nommer
`
`
label
`
`
qui
représenter
le
texte
afficher
dans
le
bouton
.
le
méthode
de
accès
au
propriété
devoir
respecter
du
convention
de
nommage
particulier
,
par
exemple
:
-
pour
le
propriété
simple
(
il
en
exister
de
autre
:
lier
,
contraindre
,
indexer
,
...
)
:
PropertyType
getPropertyName
(
)
;
/
/
simple
getter
void
setPropertyName
(
PropertyType
)
;
/
/
simple
setter
-
pour
le
propriété
booléen
,
on
utiliser
typiquement
is
au
lieu
de
get
+
communiquer
entre
eux
par
événement
:
en
pratique
,
on
utiliser
le
technique
swing
du
`
`
listeners
`
`
(
voir
section
)
;
+
supporter
le
introspection
:
à
le
exécution
et
dans
le
environnement
de
développement
,
on
devoir
être
capable
de
déterminer
et
de
analyser
le
propriété
,
le
événement
et
le
méthode
que
supporter
un
java
Bean
.
à
noter
que
ce
propriété
de
introspection
être
déjà
présent
dans
le
objet
java
puisqu'un
objet
pouvoir
être
analyser
grâce
au
classe
class
,
Method
,
Field
,
+
supporter
le
personnalisation
(
`
`
customization
`
`
)
:
le
outil
de
développement
devoir
permettre
de
modifier
le
apparence
et
le
comportement
de
un
java
Bean
en
phase
de
conception
;
+
supporter
le
persistance
:
le
persistance
de
un
objet
être
le
capacité
de
le
sauvegarder
sur
un
support
de
stockage
et
de
le
restaurer
à
le
identique
afin
que
le
programme
pouvoir
se
terminer
sans
que
ce
objet
être
perdre
.
exemple
de
persistance
:
que
un
objet
pouvoir
prétendre
à
être
un
document
Excel
à
le
intérieur
de
un
document
Word
.
le
mécanisme
qui
rendre
possible
le
persistance
être
appeler
`
`
sérialisation
`
`
(
serialization
)
.
à
ce
fin
,
un
java
Bean
devoir
implémenter
le
interface
Serializable
ou
Externalizable
.
exemple
de
java
Bean
:
package
dns-remplacer
;
import
dns-remplacé
.
*
;
import
dns-remplacé
;
/
*
*
*
SimpleBean
wi11
be
displayed
with
avoir
green
*
centered
rectangle
,
boire
its
color
may
be
changed
1ater
.
*
/
public
class
SimpleBean
extends
Canvas
implements
Serializable
{
private
Color
color
=
dns-remplacer
;
/
/
Property
getter
method
.
public
Color
getColor
(
)
{
return
color
;
}
/
/
Property
setter
method
.
/
/
set
new
SimpleBean
color
and
repaints
.
public
void
setColor
(
Color
newColor
)
{
color
=
newColor
;
repaint
(
)
;
}
public
void
paint
(
Graphics
g
)
{
g.setColor
(
color
)
;
g.fillRect
(
,
,
,
)
;
}
/
/
Constructor
set
inherited
properties
public
SimpleBean
(
)
{
setSize
(
,
)
;
setBackground
(
dns-remplacer
)
;
}
}
/
/
end
class
SimpleBean
pour
être
reconnaître
par
un
outil
de
développement
,
un
java
Bean
devoir
être
conditionnné
dans
un
fichier
de
archiver
au
format
jar
.
bien
que
ce
ne
être
pas
obligatoire
,
il
être
souhaitable
que
le
java
Beans
être
du
paquetage
(
éviter
notamment
le
conflit
en
cas
de
homonymie
du
beans
)
.
design
pattern
ce
section
ne
être
que
un
tout
premier
introduction
au
modèle
de
conception
(
design
pattern
)
[
]
.
le
développement
orienter
objet
de
application
professionnel
conduire
généralement
à
rencontrer
du
problème
de
conception
type
qui
être
familier
à
le
communauté
du
développeur
confirmer
et
pour
lequel
du
solution
éprouver
exister
.
il
ne
se
agir
pas
ici
de
solution
théorique
(
algorithme
)
mais
de
solution
orienter
objet
empirique
dont
le
solidité
et
le
efficacité
avoir
faire
leur
preuve
en
pratique
.
ce
solution
être
appeler
modèle
de
conception
(
design
pattern
)
.
un
développeur
expérimenté
se
devoir
de
la|le
connaître
et
de
disposer
de
un
`
`
panier
`
`
de
modèle
de
conception
que
il
appliquer
aussi
systématiquement
que
possible
.
le
modèle
de
conception
être
du
stratégie
de
résolution
de
grand
type
de
problème
de
conception
orienter
objet
.
il
décrire
du
forme
générique
de
organisation
de
classe
.
il
être
indépendant
du
langage
de
programmation
objet
mettre
en
œuvre
.
à
titre
illustratif
,
le
architecture
MVC
,
décrire
à
le
section
,
être
un
exemple
de
modèle
de
conception
de
architecture
logicielle
(
architectural
design
pattern
)
.
le
plus
connaître
du
modèle
de
conception
de
base
être
le
modèle
fondamental
décrire
par
le
quatre
auteur
qui
être
appeler
collectivement
`
`
The
gang
of
four
`
`
(
`
`
le
bande
du
quatre
`
`
)
ou
tout
simplement
GoF
[
]
.
on
distinguer
habituellement
grand
famille
de
modèle
de
conception
:
[
]
le
expression
design
pattern
être
souvent
traduire
aussi
par
patron
de
conception
.
[
]
-
le
modèle
de
construction
avoir
pour
but
de
organiser
le
création
de
objet
de
façon
à
gagner
en
abstraction
.
exemple
présenter
ci-après
:
le
modèle
singleton
.
-
le
modèle
de
structuration
faciliter
le
organisation
de
le
hiérarchie
du
classe
et
de
leur
relation
.
exemple
présenter
ci-après
:
le
modèle
Decorator
.
-
le
modèle
de
comportement
proposer
du
solution
pour
organiser
le
interaction
et
pour
répartir
le
traitement
entre
le
objet
.
il
tenter
de
répartir
le
responsabilité
entre
chaque
classe
.
exemple
:
le
modèle
Chain
of
Responsibility
permettre
de
créer
un
chaîne
de
objet
tel
que
,
si
le
un
de
eux
ne
pouvoir
pas
répondre
à
un
requête
,
il
pouvoir
le
transmettre
à
son
successeur
jusqu
'
à
ce
que
le
un
de
entre
eux
y
répondre
.
exemple
:
le
modèle
singleton
le
modèle
de
conception
singleton
permettre
de
assurer
que
un
classe
ne
posséder
que
un
instance
au
plus
et
de
offrir
un
méthode
unique
retourner
ce
instance
.
exemple
de
implémentation
(
cas
où
tout
le
information
nécessaire
à
le
création
du
singleton
être
disponible
au
moment
du
chargement
de
le
classe
en
mémoire
)
public
final
class
MySingleton
{
/
/
Creating
at
the
class
loading
private
static
MySingleton
singleInstance
=
new
MySingleton
(
)
;
/
/
Private
constructor
.
Ca
ne
t
be
used
outside
this
class
private
MySingleton
(
)
{
...
}
/
*
*
Get
avoir
singleton
of
this
class
*
/
public
static
MySingleton
getInstance
(
)
{
return
singleInstance
;
}
}
/
/
Creation
of
avoir
singleton
MySingleton
singleton
=
dns-remplacer
(
)
;
exemple
:
le
modèle
Decorator
le
modèle
de
conception
Decorator
permettre
de
ajouter
dynamiquement
du
fonctionnalité
à
un
objet
.
ceci
se
réaliser
en
créer
un
nouveau
classe
Decorator
envelopper
le
classe
original
.
le
modèle
de
conception
Decorator
être
un
alternative
à
le
approche
par
création
de
un
sous-
classe
de
le
classe
original
.
il
se
imposer
notamment
à
un
approche
par
extension
de
le
classe
original
dans
le
cas
suivant
:
le
classe
original
ne
pouvoir
pas
être
étendre
par
héritage
;
le
nombre
de
sous-classe
permettre
de
définir
tout
le
combinaison
possible
de
fonctionnalité
être
trop
important
;
le
ajout
du
fonctionnalité
ne
pouvoir
pas
être
statique
(
i.e.
.
réaliser
à
le
compilation
)
mais
devoir
être
dynamique
(
.e
.
réaliser
à
le
exécution
)
.
exemple
[
Wikipedia
]
.
considérer
du
fenêtre
de
affichage
instance
de
un
classe
Window
et
supposer
que
ce
classe
ne
offrir
pas
le
possibilité
de
ajouter
du
barre
de
défilement
.
créer
un
décorateur
qui
pouvoir
ajouter
dynamiquement
ce
fonctionnalité
à
du
objet
Window
existant
.
/
/
an
interface
common
to
the
decorator
and
the
decorated
public
interface
Window
{
public
void
draw
(
)
;
}
/
/
The
original
class
,
the
instance
of
which
can
be
decorated
public
class
SimpleWindow
implements
Window
public
void
draw
(
)
{
...
}
}
/
/
The
abstract
decorator
public
abstract
class
WindowDecorator
implements
Window
{
protected
Window
decoratedWindow
;
public
WindowDecorator
(
Window
decoratedWindow
)
{
dns-remplacer
=
decoratedWindow
;
}
}
/
/
à
first
concrete
decorator
public
class
VerticalScrollBarDecorator
extends
WindowDecorator
{
public
VerticalScrollBarDecorator
(
Window
decoratedWindow
)
{
super
(
decoratedWindow
)
;
}
public
void
draw
(
)
{
drawVerticalScrollBar
(
)
;
dns-remplacer
(
)
;
}
public
void
drawVerticalScrollBar
(
)
{
...
}
}
/
/
à
second
concrete
decorator
public
class
HorizontalScrollBarDecorator
extends
WindowDecorator
{
public
HorizontalScrollBarDecorator
(
Window
decoratedWindow
)
{
super
(
decoratedWindow
)
;
}
public
void
draw
(
)
{
drawHorizontalScrollBar
(
)
;
dns-remplacer
(
)
;
}
public
void
drawHorizontalScrollBar
(
)
{
...
}
}
/
/
Example
:
creation
of
avoir
fully
decorated
Window
instance
.
Window
decoratedWindow
=
new
HorizontalScrollBarDecorator
(
new
VerticalScrollBarDecorator
(
new
SimpleWindow
(
)
)
)
;
annexe
--
machine
virtuel
java
(
JVM
)
le
objectif
premier
de
ce
chapitre
être
:
-
comprendre
comment
se
opérer
le
chargement
dynamique
du
classe
en
mémoire
lors
de
le
exécution
de
un
programme
java
;
-
comprendre
le
traitement
du
champ
et
bloc
static
au
chargement
de
le
classe
.
un
machine
virtuel
java
(
JVM
)
être
un
interpréteur
de
code
java
compiler
(
bytecode
)
permettre
de
exécuter
un
programme
java
sur
un
machine
cibler
.
le
espace
mémoire
de
le
JVM
comporter
plusieurs
zone
,
notamment
:
-
le
zone
du
méthode
:
contenir
le
code
du
méthode
et
constructeur
ainsi
que
du
information
sur
le
structure
de
chaque
classe
(
notamment
son
table
du
symbole
)
;
-
le
pile
:
espace
propre
à
chaque
thread
,
mémoriser
dynamiquement
le
contexte
de
exécution
(
variable
local
notamment
)
du
méthode
en
cours|cour
de
exécution
;
-
le
tas
:
contenir
le
objet
créer
par
new
(
instance
de
classe
et
tableau
)
(
cf
chapitre
)
.
ce
être
le
demande
de
exécution
de
un
programme
java
qui
lancer
le
machine
virtuel
java
.
le
JVM
réaliser
alors
le
grand
étape
suivant
:
-
chargement
de
le
classe
principal
spécifier
(
main
class
)
et
du
classe
dont
elle
dépendre
immédiatement
(
au
premier
rang
duquel
tout
son
sur-classe
)
:
o
création
du
champ
static
,
création
de
le
table
du
méthode
,
...
o
traitement
du
champ
(
initialisation
)
et
bloc
(
exécution
)
static
-
exécution
de
le
méthode
main
de
le
classe
principal
.
durant
le
exécution
de
un
code
java
,
le
classe
(
leur
bytecode
)
être
charger
dans
le
JVM
au
fur
et
à
mesure
du
besoin
.
dans
un
hiérarchie
de
héritage
,
le
chargement
du
classe
être
opérer
par
ordre
hiérarchique
descendre
(
i.e.
de
le
super-classe
raciner
vers
le
classe
courant
)
.
exemple
:
public
class
classer
{
static
{
dns-remplacer
(
`
`
start
loading
classer
'
'
)
;
}
public
static
final
int
C
;
private
static
int
n
=
;
static
{
C
=
;
}
static
{
dns-remplacer
(
`
`
C
=
`
`
+
C
)
;
dns-remplacer
(
`
`
n
=
`
`
+
n
)
;
}
public
classer
(
)
{
dns-remplacé
(
`
`
start
classer
(
)
'
'
)
;
n
=
n
+
;
dns-remplacer
(
`
`
End
classer
(
)
'
'
)
;
}
public
int
getN
(
)
{
return
n
;
}
static
{
dns-remplacer
(
`
`
End
loading
classer
'
'
)
;
}
}
/
/
end
classer
public
class
ClassB
extends
classer
{
static
{
dns-remplacer
(
`
`
start
loading
ClassB
'
'
)
;
}
private
int
x
=
;
public
ClassB
(
)
{
dns-remplacé
(
`
`
start
ClassB
(
)
'
'
)
;
x
=
x
+
getN
(
)
;
dns-remplacer
(
x
)
;
dns-remplacer
(
`
`
End
ClassB
(
)
'
'
)
;
}
static
{
dns-remplacer
(
`
`
End
loading
ClassB
'
'
)
;
}
}
/
/
end
ClassB
public
class
class
(
)
{
static
{
dns-remplacer
(
`
`
start
loading
Class0
'
'
)
;
}
private
static
int
y
=
initY
(
)
;
private
static
int
initY
(
)
{
dns-remplacer
(
`
`
Init
y
'
'
)
;
return
;
}
public
static
void
main
(
string
[
]
args
)
{
dns-remplacé
(
`
`
start
main
Class0
'
'
)
;
ClassB
b
=
new
ClassB
(
)
;
dns-remplacer
(
`
`
End
main
Class0
'
'
)
;
}
static
{
dns-remplacer
(
`
`
End
loading
Class0
'
'
)
;
}
}
/
/
end
Class0
après
compilation
de
ce
trois
classe
,
le
exécution
de
le
commande
:
java
Class0
afficher
(
commentaire
ajouter
en
marge
)
:
start
loading
Class0
Init
y
End
loading
Class0
start
main
Class0
start
loading
classer
/
/
Sur-classes
de
ClassB
de
abord
C
=
n
=
End
loading
classer
start
loading
ClassB
/
/
puis
enfin
ClassB
.
End
loading
ClassB
start
classer
(
)
/
/
car
super
(
)
de
abord
.
End
classer
(
)
start
ClassB
(
)
/
/
+
classer
(
)
+
ClassB
(
)
End
ClassB
(
)
End
main
Class0
annexe
-
communication
entre
java
et
C
(
JNI
)
référence
:
'
'
The
java
natif
interface
:
programmer
'
s
guide
and
Specification
'
'
dns-remplacer
/
doc
/
books
/
jni
/
tutoriel
:
dns-remplacer
/
doc
/
books
/
jni
/
html
/
dns-remplacer
'
'
java
natif
interface
Specification
v1.5
'
'
dns-remplacer
/
j2se
/
/
doc
/
guide
/
jni
/
spec
/
dns-remplacer
'
'
javah
-
C
Header
and
Stub
filer
Generator
'
'
dns-remplacer
/
javase
/
/
doc
/
technote
/
tools
/
windows
/
dns-remplacer
on
se
poser
le
problème
de
appeler
un
sous-programme
C
depuis
un
méthode
java
dans
un
environnement
Unix
.
le
solution
mettre
en
œuvre
le
interface
de
programmation
JNI
(
java
natif
interface
)
offrir
par
le
plate-forme
java
.
JNI
être
un
ensemble
de
fonctionnalité
qui
permettre
à
un
programme
java
fonctionner
sur
le
machine
virtuel
java
(
JVM
)
de
appeler
ou
de
être
appeler
par
un
programme
écrire
dans
un
autre
langage
(
typiquement
en
C
,
C++
ou
assembleur
)
.
en
permettre
le
interfaçage
avec
du
application
ou
bibliothèque
natif
[
]
,
le
mise
en
œuvre
de
JNI
accroître
le
interopérabilité
du
application
java
,
mais
évidemment
au
détriment
de
leur
portabilité
.
un
bon
architecture
de
le
application
devoir
donc
minimiser
le
nombre
de
classe
faire
référence
à
un
méthode
natif
.
par
le
suite
,
on
supposer
que
le
fichier
java
appeler
le
sous-programme
C
se
nommer
dns-remplacer
,
et
que
le
fichier
C
implémentir
ce
sous-programme
se
nommer
MyRoutines.c.
le
développement
de
le
application
complet
comporter
étape
:
)
Ecrire
le
programme
java
et
le
compiler
:
javac
dns-remplacer
)
produire
le
fichier
de
en-tête
MyClass.h.
pour
le
programme
C
:
javah
MyClass
)
Ecrire
le
sous-programme
C
et
le
compiler
:
gcc
-o
MyRoutines
-c
MyRoutines.c.
-pedantic
-W
-Wal1l
-Idir
où
dir
être
le
répertoire
de
installation
par
le
JDK
du
fichier
de
include
du
JNI
.
par
exemple
(
ce
fichier
être
répartir
dans
deux
répertoire
)
:
gcc
-o
MyRoutines
-c
MyRoutines.c.
-pedantic
-W
-Wall
-I
/
usr
/
lib
/
jdk1.5.0v11
/
include
-I
/
usr
/
lib
/
jdk1.5.0v11
/
include
/
linux
[
]
un
application
ou
un
bibliothèque
de
sous-programme
être
dire
en
code
natif
si
elle
être
dépendant
de
un
environnement
hôte
(
système
de
exploitation
ou
jeu
de
instruction
du
processeur
)
particulier
.
par
exemple
,
un
programme
C
compiler
sur
un
système
de
exploitation
donner
être
en
code
natif
car
il
ne
fonctionner
pas
sur
un
autre
système
de
exploitation
.
)
produire
un
bibliothèque
partagé
(
lib
*
.so
)
qui
être
chargeable
par
le
programme
java
:
gcc
-Wall
-shared
-o
dns-remplacer
MyRoutines.o.
)
avant
le
tout
premier
exécution
,
spécifier
à
le
machine
virtuel
java
le
chemin
de
accès
à
ce
bibliothèque
:
setenv
LD_LIBRARY_PATH
path
où
path
désigner
le
chemin
de
accès
.
en
supposer
que
celui
-ci
soit
le
répertoire
courant
,
le
commande
être
:
setenv
LD_LIBRARY_PATH
.
)
exécuter
le
programme
java
:
java
MyClass
le
façon
de
écrire
le
programme
java
et
de
implémenter
le
sous-programme
C
associé
être
illustrer
ci-après
.
appel
de
un
procédure
C
on
considèrera
de
bout
en
bout
le
même
exemple
.
déclaration
et
appel
java
exemple
de
classe
java
public
class
MyClass
{
/
/
Declaration
of
an
extern
class
procedure
natif
public
static
void
procedure1
(
)
;
/
/
Declaration
of
an
extern
instance
procedure
natif
public
void
procedure2
(
)
;
/
/
test
procedure
public
static
void
main
(
string
[
]
argv
)
{
dns-remplacer
(
)
;
MyClass
o
=
new
MyClasse
(
)
;
o.procedure2
(
)
;
}
/
/
Load
the
library
libMyRoutines
static
{
dns-remplacer
(
`
`
MyRoutine
'
'
)
;
}
}
commentaire
:
-
le
modificateur
natif
indique
que
il
se
agir
de
un
procédure
externe
non
écrire
en
java
.
le
nom
de
le
procédure
être
arbitraire
.
-
le
méthode
loadLibrary
aller
charger
le
bibliothèque
dns-remplacé
;
le
mot
clé
static
qui
encapsuler
le
bloc
de
instruction
dans
lequel
le
appel
être
réaliser
permettre
de
exécuter
ce
bloc
dès
le
chargement
de
le
classe
MyClass
sans
avoir
besoin
de
passer
par
le
appel
de
un
méthode
intermédiaire
.
prototype
C
le
fichier
MyClass.h.
produit
par
javah
(
cf
étape
précédent
)
spécifier
le
prototype
que
devoir
respecter
le
sous-programme
C
à
écrire
.
contenir
(
expurger
)
du
fichier
MyClass.h.
produire
par
javah
/
*
do
NOT
EDIT
THIS
filer
-
it
is
machine
generated
*
/
/
*
Header
for
class
MYClass
*
/
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
(
JNIEnv
*
,
jclass
)
;
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
(
JNIEnv
*
,
jobject
)
;
commentaire
:
-
JNIEXPORT
et
JNICALL
être
deux
macros
prédéfinie
par
JNI
pour
faire
communiquer
java
et
C
-
void
spécifier
que
il
se
agir
de
un
procédure
-
Java_MyClass_procedure1
être
le
nom
imposé
que
devoir
porter
le
procédure
C
correspondant
à
le
méthode
de
nom
procedure1
déclarer
dans
le
programme
java
;
idem
pour
procedure2
-
deux
paramètre
être
systématiquement
introduire
en
tête
de
le
liste
du
paramètre
:
o
le
premier
,
de
type
JNIEnv
*
,
être
un
pointeur
vers
le
environnement
JNIEnv
qui
être
lui
même
un
pointeur
vers
un
structure
contenir
du
fonction
de
interface
avec
le
machine
virtuel
java
(
JVM
)
;
o
le
second
,
de
type
jclass
se
il
se
agir
de
un
méthode
de
classe
ou
jobject
si
il
se
agir
de
un
méthode
de
instance
,
être
un
pointeur
vers
un
descripteur
de
le
classe
ou
de
le
objet
(
un
sorte
de
this
)
de
appel
implémentation
C
exemple
de
fichier
MyRoutines.c.
#
include
<
stdio.h.
>
#
include
`
`
MyClass.h.
'
'
JNIEXPORT
void
JNICALL
Java_MyClass_procedure1
(
JINIEnv
*
penv
,
jclass
cla
)
{
printf
(
`
`
routine
procedure1\n
'
'
)
;
}
JNIEXPORT
void
JNICALL
Java_MyClass_procedure2
(
JINIEnv
*
penv
,
jobject
obj
)
{
printf
(
`
`
routine
procedure2\n
'
'
)
;
}
Echange
de
donnée
entre
java
et
C
le
échange
de
donnée
entre
le
application
java
et
le
sous-programme
C
(
par
le
paramètre
ou
le
résultat
de
le
fonction
)
supposer
un
compatibilité
du
type
correspondant
.
or
il
n
'
y
avoir
pas
de
correspondance
systématique
naturel
entre
le
type
du
langage
java
et
le
type
du
langage
C
(
un
caractère
,
par
exemple
,
être
coder
sur
bit
en
java
et
sur
bit
en
C
)
.
le
JNI
définir
donc
un
ensemble
de
type
en
C
(
de
nom
j
*
)
qui
correspondre
au
type
de
java
.
le
JNI
traiter
le
type
primitif
et
le
type
objet
différemment
.
le
correspondance
du
type
primitif
être
direct
(
voir
tableau
ci-après
)
,
car
elle
reposer
sur
un
représentation
machiner
du
donnée
identique
,
mais
ce
ne
être
pas
le
cas
pour
le
type
objet
.
le
transmission
de
un
chaîne
de
caractère
,
de
un
tableau
,
avoir
fortiori
de
un
instance
quelconque
de
classe
,
ne
être
pas
direct
et
nécessiter
du
conversion
de
type
.
un
paramètre
java
de
type
objet
être
ainsi
transmettre
au
sous-
programme
C
sous
forme
de
un
pointeur
sur
un
structure
de
donnée
interne
à
le
machine
virtuel
java
.
le
organisation
interne
de
ce
structure
être
masquer
au
programmeur
mais
celui
-ci
pouvoir
néanmoins
accéder
au
composante
sous-jacent
via
le
fonction
utilitaire
offrir
par
le
JNI
dans
le
environnement
JNIEnv
.
type
primitif
java
typer
primitif
côté
C
description
boolean
jboolean
unsigned
bit
byte
jbyte
signed
bit
char
jchar
unsigned
bit
short
jshort
signed
bit
int
jint
signed
bit
long
jlong
signed
bit
float
jfloat
bit
double
jdoubler
bit
par
le
suite
,
on
considèrera
de
bout
en
bout
le
même
exemple
.
déclaration
et
appel
java
exemple
de
classe
java
public
class
MyClass
{
/
/
Declaration
of
an
extern
instance
function
natif
public
string
getMessage
(
int
id
,
string
prompt
)
;
/
/
test
procedure
public
static
void
main
(
string
[
]
argv
)
{
MyClass
o
=
new
MyClasse
(
)
;
dns-remplacer
(
o.getMessage
(
,
`
`
Name
:
`
`
)
)
;
}
/
/
Load
the
library
libMyRoutines
static
{
dns-remplacer
(
`
`
libMyRoutine
'
'
)
;
}
}
prototype
C
contenu
(
expurger
)
du
fichier
MyClass.h.
produire
par
javah
/
*
do
NOT
EDIT
THIS
filer
-
it
is
machine
generated
*
/
/
*
Header
for
class
MYClass
*
/
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
(
INIEnv
*
,
jobject
,
jint
,
jstring
)
;
implémentation
C
exemple
de
fichier
MyRoutines.c.
#
include
<
stdio.h.
>
#
include
`
`
MyClass.h.
'
'
JNIEXPORT
jstring
JNICALL
Java_MyClass_getMessage
(
JINIEnv
*
penv
,
jobject
obj
,
jint
jid
,
jstring
jprompt
)
;
{
const
char
*
str
;
char
buf
[
]
;
/
*
Get
the
C
string
from
the
java
string
*
/
str
=
(
*
penv
)
-
>
GetStringUTFChars
(
penv
,
jprompt
,
NULL
)
;
printf
(
`
`
%
d
-
%
s
'
'
,
jid
,
str
)
;
/
*
do
ne
t
forget
this
line
!
!
!
*
/
(
*
penv
)
-
>
ReleaseStringUTFChars
(
penv
,
jprompt
,
str
)
;
/
*
assumer
the
user
does
ne
t
type
more
than
char
*
/
scanf
(
`
`
%
s
'
'
,
buf
)
;
return
(
*
penv
)
-
>
NewStringUTF
(
penv
,
buf
)
;
}
commentaire
:
-
le
représentation
physique
du
chaîne
de
type
jstring
et
de
type
char
*
ne
être
pas
identique
.
un
conversion
devoir
être
réaliser
.
ce
être
le
rôle
du
fonction
GetStringUTFChars
et
NewStringUTF
.
à
noter
que
,
dans
tout
le
cas
,
le
conversion
du
caractère
non
codables
en
ASCII
bit
(
lettre
accentué
,
...
)
poser
problème
.
-
le
fonction
GetStringUTFChars
réaliser
un
allocation
mémoire
dynamique
,
un
désallocation
devoir
être
obligatoirement
réaliser
avant
le
fin
du
sous-
programme
:
ce
être
le
rôle
de
le
fonction
ReleaseStringUTFChars
annexe
-
PLATES-FORMES
java
référence
:
java
Platform
,
standard
Edition
,
api
Specification
:
dns-remplacer
/
javase
/
/
doc
/
api
/
New
features
and
Enhancements
J2SE
:
dns-remplacer
/
j2se
/
/
doc
/
relnote
/
dns-remplacer
java
Platform
,
standard
Edition
:
dns-remplacer
/
javase
/
java
Platform
,
Enterprise
Edition
:
dns-remplacer
/
javaee
/
java
Platform
,
micro
Edition
:
dns-remplacer
/
javame
/
JDK
Tools
and
Utilities
:
dns-remplacer
/
javase
/
/
doc
/
technote
/
tools
/
Sun
Microsystems
fournir
trois
plates-formes
java
permettre
le
développement
et
le
exécution
de
programme
java
:
java
se
(
le
standard
de
base
)
,
java
EE
et
java
me
.
à
noter
que
ce
nom
être
celui
employé
pour
le
version
sortir
depuis
:
antérieurement
,
ce
plates-
forme
être
nommer
respectivement
J2SE
,
J2EE
et
J2ME
.
java
Platform
,
standard
Edition
(
java
se
)
.
ce
plate-forme
être
le
framework
java
de
base
permettre
de
développer
ou
/
et
exécuter
du
programme
java
.
le
dernier
version
nommer
J2SE
être
le
version
et
porter
le
nom
J2SE
:
il
être
à
souligner
que
ce
version
apporter
un
mise
à
jour
majeur
par
rapport
à
le
précédent
.
le
version
actuel
le
plus
récent
date
de
décembre
:
ce
être
le
version
et
elle
porter
le
nom
java
se
.
le
version
(
java
se
)
être
annoncer
comme
nouveau
mise
à
jour
majeur
mais
,
à
mi
,
être
toujours
attendre
.
le
plate-forme
java
se
délivrer
deux
produit
logiciel
principal
:
java
se
Runtime
Environment
(
ou
plus
communément
JRE
)
,
qui
fournir
le
librairie
,
le
machine
java
virtuel
et
de
autre
composante
nécessaire
pour
exécuter
du
programme
java
.
java
se
Development
kit
(
ou
plus
communément
JDK
)
,
qui
inclure
le
JRE
plus
du
outil
de
développement
,
tel
que
compilateur
et
débogueur
,
nécessaire
ou
utile
pour
développer
du
programme
java
.
à
noter
que
le
terme
JDK
,
bien
que
très
populaire
,
être
devenir
imprécis
car
de
autre
plates-forme
java
(
java
EE
par
exemple
)
comporter
elle
aussi
leur
propre
kit
de
développement
.
java
Platform
,
Enterprise
Edition
(
java
EE
)
.
ce
plate-forme
être
un
framework
java
plus
particulièrement
destiner
au
application
de
entreprise
.
elle
offrir
un
cadre
standard
pour
développer
du
application
distribuer
.
java
Platform
,
micro
Edition
(
java
me
)
.
ce
plate-forme
être
un
framework
java
spécialiser
dans
le
application
mobile
.
du
plates-formes
java
compatibles
avec
J2ME
être
embarquer
dans
de
nombreux
téléphone
mobile
et
PDA
.
de
façon
plus
spécifique
,
on
pouvoir
aussi
citer
le
plateforme
java
Card
(
qui
fournir
un
environnement
pour
le
développement
de
application
sur
carte
à
puce
)
et
JavaFX
(
pour
créer
du
Rich
Internet
application
)
.
annexe
-
glossaire
on
trouver
facilement
sur
le
web
de
excellent
définition
en
anglais
du
terme
,
sigle
,
et
même
produire
de
référence
,
informatique
.
parmi
le
source
possible
,
citer
par
exemple
:
-
parmi
le
encyclopédie
:
dns-remplacer
(
le
version
anglais
être
le
plus
complet
)
-
parmi
le
moteur
spécialiser
dans
le
recherche
dans
le
encyclopédie
,
dictionnaire
et
glossaire
:
dns-remplacer
voici
un
glossaire
de
quelque
terme
et
sigle
général
courant
:
sigle
/
terme
définition
commentaire
api
application
Programming
bibliothèque
de
fonctionnalité
commun
,
interface
courant
et
de
bas
niveau
.
constituer
un
interface
entre
couche
bas
et
couche
applicatives
de
plus
haut
niveau
.
exemple
:
dns-remplacer
/
javase
/
/
doc
/
api
/
spécifier
le
api
standard
de
java
fournir
dans
le
JDK
.
Framework
cadre
de
application
Ensemble
cohérent
de
classe
(
généralement
abstraire
)
et
de
interface
permettre
le
développement
rapide
de
application
.
fournir
suffisamment
de
brique
logicielles
pour
pouvoir
produire
un
application
aboutir
.
typiquement
spécialiser
pour
un
type
de
application
.
gui
Graphical
user
interface
interface
homme-machine
graphique
,
par
opposition
à
interface
en
ligne
de
commande
.
IDE
Integrated
Development
programme
regrouper
un
ensemble
de
utilitaire
Environment
logiciel
pour
le
développement
de
programme
(
éditeur
de
texte
,
compilateur
,
débogueur
,
gestionnaire
de
version
,
aide
à
le
production
de
interface
,
...
)
.
généralement
dédier
à
un
seul
langage
de
programmation
.
JDK
java
Development
kit
(
voir
chapitre
)
JFC
java
Foundation
classe
cadre
de
application
graphique
.
ensemble
de
classe
java
permettre
de
construire
du
interface
utilisateur
graphique
portable
.
contenir
notamment
le
composant
swing
.
JRE
java
Runtime
Environment
(
voir
chapitre
)
J2EE
java
Platform
,
Enterprise
(
voir
chapitre
)
Edition
java
se
java
Platform
,
Enterprise
J2ME
java
Platform
,
micro
(
voir
chapitre
)
Edition
java
me
java
Platform
,
micro
Edition
J2SE
java
Platform
,
standard
(
voir
chapitre
)
Edition
java
se
java
Platform
,
standard
Edition
et
plus
spécifiquement
dans
le
cadre
de
application
professionnel
java
distribuer
:
sigle
/
terme
définition
commentaire
EJB
Enterprise
JavaBeans
technologie
java
,
offrir
par
le
plateforme
java
EE
,
permettre
de
créer
du
composant
distribuer
héberger
dans
un
serveur
de
application
.
dans
un
architecture
MVC
,
utiliser
pour
réaliser
le
modèle
.
dns-remplacer
/
products
/
ejb
/
JSP
java
Server
page
technologie
java
,
offrir
par
le
plateforme
java
EE
,
permettre
de
créer
du
page
Web
dynamique
.
dans
un
architecture
MVC
,
utiliser
pour
réaliser
le
vue
.
dns-remplacer
/
products
/
jsp
/
Servlet
technologie
java
,
offrir
par
le
plateforme
java
EE
,
permettre
de
étendre
le
fonctionnalité
de
un
serveur
Web
(
accès
à
du
base
de
donnée
,
transaction
d
'
e-commerce
,
...
...
)
.
dans
un
architecture
MVC
,
utiliser
pour
réaliser
le
contrôleur
.
dns-remplacer
/
products
/
servlet
/
