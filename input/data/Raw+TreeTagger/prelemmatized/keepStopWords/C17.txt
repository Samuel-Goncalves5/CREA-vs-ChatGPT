Cours
introductif
au
PHP
Riad
MOKADEM
Qu'est-ce
que
PHP
?
PHP
est
un
langage
interprété
(
un
langage
de
script
)
exécuté
du
côté
serveur
(
comme
les
scripts
CGI
,
ASP
,
...
)
et
non
du
côté
client
(
un
script
écrit
en
Javascript
ou
une
applet
Java
s'exécute
sur
votre
ordinateur
...
)
.
La
syntaxe
du
langage
provient
de
celles
du
langage
C
,
du
Perl
et
de
Java
.
Ses
principaux
atouts
sont
:
•
Une
grande
communauté
de
développeurs
partageant
des
centaines
de
milliers
d'exemples
de
script
PHP
;
•
•
•
La
gratuité
et
la
disponibilité
du
code
source
(
PHP
est
distribué
sous
licence
GNU
GPL
)
;
•
La
simplicité
d'interfaçage
avec
des
bases
de
données
(
de
nombreux
SGBD
sont
supportés
,
mais
le
plus
utilisé
avec
ce
langage
est
MySQL
,
un
SGBD
gratuit
disponible
sur
de
nombreuses
plateformes
:
Unix
,
Linux
,
Windows
,
MacOs
X
,
Solaris
,
etc
...
)
;
•
L'intégration
au
sein
de
nombreux
serveurs
web
(
Apache
,
Microsoft
IIS
,
etc.
)
.
La
simplicité
d'écriture
de
scripts
;
La
possibilité
d'inclure
le
script
PHP
au
sein
d'une
page
HTML
(
contrairement
aux
scripts
CGi
,
pour
lesquels
il
faut
écrire
des
lignes
de
code
pour
afficher
chaque
ligne
en
langage
HTML
)
;
Origines
de
PHP
Le
langage
PHP
a
été
mis
au
point
au
début
d'automne
1994
par
Rasmus
Lerdorf
.
Ce
langage
de
script
lui
permettait
de
conserver
la
trace
des
utilisateurs
venant
consulter
son
CV
sur
son
site
,
grâce
à
l'accès
à
une
base
de
données
par
l'intermédiaire
de
requêtes
SQL
.
Ainsi
,
étant
donné
que
de
nombreux
internautes
lui
demandèrent
ce
programme
,
Rasmus
Lerdorf
mit
en
ligne
en
1995
la
première
version
de
ce
programme
qu'il
baptisa
Personal
Sommaire
Page
Tools
,
puis
Personal
Home
Page
v1.0
(
traduisez
page
personnelle
version
1.0
)
.
Etant
donné
le
succès
de
PHP
1.0
,
Rasmus
Lerdorf
décida
d'améliorer
ce
langage
en
y
intégrant
des
structures
plus
avancées
telles
que
des
boucles
,
des
structures
conditionnelles
,
et
y
intégra
un
package
permettant
d'interpréter
les
formulaires
qu'il
avait
développé
(
FI
,
Form
Interpreter
)
ainsi
que
le
support
de
mSQL
.
C'est
de
cette
façon
que
la
version
2
du
langage
,
baptisée
pour
l'occasion
PHP/FI
version
2
,
vit
le
jour
durant
l'été
1995
.
Il
fut
rapidement
utilisé
sur
de
nombreux
sites
(
15000
fin
1996
,
puis
50000
en
milieu
d'année
1997
)
.
A
partir
de
1997
,
Zeev
Suraski
et
Andi
Gurmans
rejoignirent
Rasmus
pour
former
une
équipe
de
programmeurs
afin
de
mettre
au
point
PHP
3
(
Stig
Bakken
,
Shane
Caraveo
et
Jim
Winstead
les
rejoignirent
par
la
suite
)
.
C'est
ainsi
que
la
version
3.0
de
PHP
fut
disponible
le
6
juin
1998
.
A
la
fin
de
l'année
1999
la
version
4.0
de
PHP
,
baptisée
PHP4
,
est
apparue
.
PHP
en
est
aujourd'hui
à
sa
cinquième
version
.
SGBD
supportés
par
PHP
PHP
permet
un
interfaçage
simple
avec
de
nombreux
systèmes
de
gestion
de
bases
de
données
(
SGBD
)
,
parmi
lesquels
:
•
•
•
•
•
•
•
•
•
•
Adabas
D
dBase
Empress
FilePro
Informix
Interbase
mSQL
MySQL
Oracle
PostgreSQL
•
•
•
•
Solid
Sybase
Velocis
Unix
dbm
L'interprétation
du
code
par
le
serveur
Un
script
PHP
est
un
simple
fichier
texte
contenant
des
instructions
écrites
à
l'aide
de
caractères
ASCII
7
bits
(
des
caractères
non
accentués
)
incluses
dans
un
code
HTML
à
l'aide
de
balises
spéciales
et
stocké
sur
le
serveur
.
Ce
fichier
doit
avoir
l'extension
«
.php
»
pour
pouvoir
être
interprété
par
le
serveur
.
Ainsi
,
lorsqu'un
navigateur
(
le
client
)
désire
accéder
à
une
page
dynamique
réalisé
en
PHP
:
•
•
le
serveur
reconnait
l'extension
d'un
fichier
PHP
et
le
transmet
à
l'interpréteur
PHP
•
•
L'interpréteur
exécute
l'instruction
puis
envoie
les
sorties
éventuelles
au
serveur
Dès
que
l'interpréteur
rencontre
une
balise
indiquant
que
les
lignes
suivantes
sont
du
code
PHP
,
il
ne
lit
plus
les
instructions
:
il
les
exécute
!
A
la
fin
du
script
,
le
serveur
transmet
le
résultat
au
client
(
le
navigateur
)
.
Un
script
PHP
est
interprété
par
le
serveur
,
les
utilisateurs
ne
peuvent
donc
pas
voir
le
code
source
!
Le
code
PHP
stocké
sur
le
serveur
n'est
donc
jamais
visible
directement
par
le
client
puisque
dès
qu'il
en
demande
l'accès
,
le
serveur
l'interprète
!
De
cette
façon
aucune
modification
n'est
à
apporter
sur
les
navigateurs
.
Implantation
au
sein
du
code
HTML
Pour
que
le
script
soit
interprété
par
le
serveur
deux
conditions
sont
nécessaires
:
•
•
Le
fichier
contenant
le
code
doit
avoir
l'extension
telle
que
.php
et
non
.html
Le
code
PHP
contenu
dans
le
code
HTML
doit
être
délimité
par
des
balises
du
type
<
?
et
?
>
Un
script
PHP
doit
:
•
•
comporter
l'extension
.php
être
imbriqué
entre
les
délimiteurs
<
?
et
?
>
Pour
des
raisons
de
conformité
avec
certaines
normes
(
XML
et
ASP
par
exemple
)
,
plusieurs
balises
peuvent
être
utilisées
pour
délimiter
un
code
PHP
:
1
.
2
.
3
.
4
.
<
?
et
?
>
<
?
php
et
?
>
<
script
language=
''
php
''
>
et
<
/script
>
<
%
php
et
%
>
Un
exemple
de
script
simple
Voici
ci-dessous
l'exemple
classique
de
script
PHP
:
<
html
>
<
head
>
<
title
>
Exemple
<
/title
>
<
/head
>
<
body
>
<
?
php
echo
``
Hello
world
''
;
?
>
<
/body
>
<
/html
>
On
notera
bien
évidemment
que
la
fonction
echo
permet
d'afficher
sur
le
navigateur
la
chaine
délimitée
par
les
guillemets
.
L'interprétation
du
code
Un
code
PHP
(
celui
compris
entre
les
délimiteurs
<
?
php
et
?
>
)
est
un
ensemble
d'instructions
se
terminant
chacune
par
un
point-virgule
(
comme
en
langage
C
)
.
Lorsque
le
code
est
interprété
,
les
espaces
,
retours
chariot
et
tabulation
ne
sont
pas
pris
en
compte
par
le
serveur
.
Il
est
tout
de
même
conseillé
d'en
mettre
(
ce
n'est
pas
parce
qu'ils
ne
sont
pas
interprétés
que
l'on
ne
peut
pas
les
utiliser
)
afin
de
rendre
le
code
plus
lisible
(
pour
vous
,
puisque
les
utilisateurs
ne
peuvent
lire
le
code
source
:
il
est
interprété
)
.
Les
commentaires
Une
autre
façon
de
rendre
le
code
plus
compréhensible
consiste
à
insérer
des
commentaires
,
des
lignes
qui
seront
tout
simplement
ignorées
par
le
serveur
lors
de
l'interprétation
.
Pour
ce
faire
,
il
est
possible
,
comme
en
langage
C
,
d'utiliser
des
balises
qui
vont
permettre
de
délimiter
les
explications
afin
que
l'interpréteur
les
ignore
et
passe
directement
à
la
suite
du
fichier
.
Ces
délimiteurs
sont
/
*
et
*
/
.
Un
commentaire
sera
donc
noté
de
la
façon
suivante
:
/
*
Voici
un
commentaire
!
*
/
Il
y
a
toutefois
quelques
règles
à
respecter
:
•
Les
commentaires
peuvent
être
placés
n'importe
où
à
l'intérieur
des
délimiteurs
de
script
PHP
•
•
•
•
Les
commentaires
ne
peuvent
contenir
le
délimiteur
de
fin
de
commentaire
(
*
/
)
Les
commentaires
ne
peuvent
être
imbriqués
Les
commentaires
peuvent
être
écrits
sur
plusieurs
lignes
Les
commentaires
ne
peuvent
pas
couper
un
mot
du
code
en
deux
Il
est
possible
aussi
d'utiliser
un
type
de
commentaire
permettant
de
mettre
toute
la
fin
d'une
ligne
en
commentaire
en
utilisant
le
double
slash
(
//
)
.
Tout
ce
qui
se
situe
à
droite
de
ce
symbole
sera
mis
en
commentaire
.
Typologie
La
manière
d'écrire
les
choses
en
langage
PHP
a
son
importance
.
Le
langage
PHP
est
par
exemple
sensible
à
la
casse
(
en
anglais
case
sensitive
)
,
cela
signifie
qu'un
nom
contenant
des
majuscules
est
différent
du
même
nom
écrit
en
minuscules
.
Toutefois
,
cette
règle
ne
s'applique
pas
aux
fonctions
,
les
spécifications
du
langage
PHP
précisent
que
la
fonction
print
peut
être
appelée
print
(
)
,
Print
(
)
ou
PRINT
(
)
.
Enfin
,
toute
instruction
se
termine
par
un
point-virgule
.
Introduction
Un
serveur
web
est
un
logiciel
permettant
de
rendre
accessibles
à
de
nombreux
ordinateurs
(
les
clients
)
des
pages
web
stockées
sur
le
disque
.
Cette
fiche
pratique
explique
comment
installer
le
serveur
web
Apache
sur
un
système
de
type
UNIX
(
typiquement
une
distribution
de
Linux
telle
que
RedHat
,
Mandrake
ou
n'importe
quelle
autre
)
.
Pour
cela
quelques
connaissances
sur
Linux
ou
bien
Unix
sont
nécessaires
.
Le
but
de
cette
fiche
va
être
d'être
capable
de
récupérer
les
sources
des
différents
éléments
nécessaires
et
de
les
compiler
(
un
compilateur
C
est
donc
nécessaire
,
il
est
généralement
installé
par
défaut
sur
la
plupart
des
distributions
Linux
)
afin
d'avoir
un
système
opérationnel
.
L'installation
suivante
comprend
l'installation
de
l'interpréteur
PHP
,
un
langage
de
programmation
permettant
de
créer
des
pages
créées
dynamiquement
,
ainsi
que
le
SGBD
MySQL
,
un
système
de
gestion
de
bases
de
données
relationnelles
puissant
fonctionnant
sous
Linux
(
et
gratuit
!
)
.
Télécharger
les
sources
•
•
•
Les
sources
de
PHP
peuvent
être
téléchargées
sur
le
site
http
:
//www.php.net
Les
sources
de
Apache
peuvent
être
téléchargées
sur
le
site
http
:
//www.apache.org
Les
sources
de
MySQL
peuvent
être
téléchargées
sur
le
site
http
:
//www.mysql.org
installer
Apache
et
PHP
1
.
Décompresser
les
archives
:
2.
tar
zxvf
apache_1.3.x.tar.gz
tar
zxvf
php-3.0.x.tar
3
.
Configurer
Apache
4.
cd
apache_1.3.x
./configure
--
prefix=/www
5
.
Configurer
PHP
6.
cd
..
/php-3.0.x
./configure
--
with-mysql
--
with-apache=
..
/apache_1.3.x
-enable-track-vars
7
.
Si
vous
préférez
installer
PHP
dans
un
autre
répertoire
,
il
faut
utiliser
l'option
de
configuration
-with-config-file-path=/path
Compiler
PHP
8.
make
make
install
9
.
Installer
Apache
10.
cd
..
/apache_1.3.x
11
.
./configure
--
prefix=/www
--
activatemodule=src/modules/php3/libphp3.a
12.
make
make
install
13
.
Modifier
le
fichier
de
configuration
de
PHP
14.
cd
..
/php-3.0.x
cp
php3.ini-dist
/usr/local/lib/php3.ini
Vous
pouvez
désormais
éditer
le
fichier
de
configuration
/usr/local/lib/php3.ini
.
15
.
Editez
le
fichier
de
configuration
du
serveur
apache
(
généralement
httpd.conf
ou
srm.conf
et
ajoutez
la
ligne
suivante
:
AddType
application/x-httpd-php3
.php3
Il
s'agit
de
choisir
l'extension
associée
aux
scripts
PHP
.
Par
souci
d'homogénéité
,
il
est
courant
de
choisir
l'extension
.php3
16
.
Démarrez
le
serveur
Apache
.
(
Il
est
essentiel
d'arrêter
et
redémarrer
le
serveur
,
et
non
uniquement
de
le
relancer
.
Il
suffit
généralement
de
taper
apachectl
stop
,
puis
apachectl
start
)
.
Premier
lancement
Pour
vérifier
si
l'installation
a
bien
fonctionnée
,
il
vous
suffit
de
créer
un
petit
fichier
dans
la
racine
des
documents
du
serveur
web
(
appelée
DocumentRoot
dans
le
fichier
de
configuration
httpd.conf
)
.
Nommez
ce
fichier
toto.php3
,
et
mettez
le
code
suivant
dans
ce
fichier
:
<
html
>
<
head
>
<
title
>
Exemple
<
/title
>
<
/head
>
<
body
>
<
?
php
echo
``
PHP
fonctionne
!
``
;
?
>
<
/body
>
<
/html
>
Lancez
un
navigateur
sur
cette
machine
et
entrez
l'URL
suivante
:
http
:
//localhost/toto.php3
localhost
désigne
la
machine
sur
laquelle
vous
vous
trouvez
...
Vous
devriez
logiquement
voir
apparaître
la
phrase
``
PHP
fonctionne
!
''
sur
votre
navigateur
!
Introduction
à
EasyPHP
Afin
de
faire
fonctionner
PHP
,
il
est
nécessaire
à
la
base
d'en
télécharger
les
sources
depuis
un
site
spécialisé
(
par
exemple
PHP.net
)
,
puis
de
compiler
celui-ci
(
ainsi
que
d'éditer
les
liens
)
afin
de
créer
un
fichier
exécutable
.
Ce
processus
demande
des
notions
avancées
en
informatique
,
c'est
pourquoi
trois
adeptes
de
PHP
(
Emmanuel
Faivre
,
Laurent
Abbal
et
Thierry
Murail
)
ont
mis
au
point
un
package
(
appelé
EasyPHP
)
contenant
3
produits
incontournables
de
la
scène
PHP
:
•
•
•
•
Le
serveur
Web
Apache
Le
moteur
de
scripts
PHP4
La
base
de
données
MySQL
Un
outil
de
gestion
de
base
de
donnée
graphique
,
Phpmyadmin
EasyPHP
est
ainsi
un
pack
fonctionnant
sous
Windows
permettant
d'installer
en
un
clin
d'oeil
les
éléments
nécessaires
au
fonctionnement
d'un
site
web
dynamique
développé
en
PHP
Récupérer
EasyPHP
Le
pack
EasyPHP
est
disponible
sur
les
sites
suivants
:
•
•
www.manucorp.com
www.easyphp.org
Il
vous
suffit
dans
un
premier
temps
de
télécharger
la
version
la
plus
récente
de
EasyPHP
.
Vous
pouvez
la
télécharger
à
cette
adresse
:
Page
de
téléchargement
de
EasyPhP
Installer
EasyPHP
L'installation
de
EasyPHP
est
très
simple
,
notamment
avec
l'apparition
de
la
version
1.4
comportant
un
installeur
automatique
.
Pour
installer
EasyPHP
,
il
vous
suffit
dans
un
premier
temps
de
double-cliquer
sur
le
fichier
téléchargé
précédemment
:
L'écran
d'installation
de
EasyPHP
suivant
devrait
apparaître
,
cliquez
sur
Next
(
Suivant
<
/
)
:
L'installeur
va
ensuite
vous
demander
de
préciser
le
répertoire
d'installation
:
Puis
il
va
demander
la
création
d'un
groupe
dans
le
menu
démarrer
Et
enfin
il
va
vous
récapituler
les
éléments
de
l'installation
avant
de
procéder
à
la
copie
des
fichiers
.
Après
la
copie
des
fichiers
,
EasyPHP
vous
présente
l'écran
suivant
indiquant
que
l'installation
s'est
déroulée
correctement
Il
se
peut
lors
de
l'installation
que
l'installeur
vous
indique
l'erreur
suivante
:
Cette
erreur
indique
que
la
librairie
msvcrt.dll
n
'
a
pû
être
copiée
.
La
raison
de
cette
erreur
provient
du
fait
que
votre
système
Windows
est
actuellement
en
train
d'utiliser
cette
libraire
et
ne
peut
donc
l'écraser
.
Pour
y
remédier
,
copiez
cette
librairie
(
par
exemple
dans
c
:
\
)
sur
votre
disque
dur
(
cliquez
ici
pour
télécharger
la
librairie
pour
Windows
9x
)
,
puis
redémarrez
en
mode
MS-DOS
,
puis
tapez
copy
c
:
\msvcrt.dll
c
:
\windows\system
.
Le
système
va
vous
demander
de
confirmer
cet
écrasement
répondez
``
Oui
''
(
Y
ou
O
)
,
redémarrez
Windows
et
EasyPHP
devrait
fonctionner
!
Démarrage
de
EasyPHP
Pour
démarrer
Apache
,
MySQL
et
PHP
,
il
vous
suffit
de
lancer
EasyPHP
à
partir
du
groupe
créé
dans
le
menu
démarrer
:
Pour
vérifier
si
EasyPHP
fonctionne
,
il
vous
suffit
de
taper
dans
votre
navigateur
préféré
:
•
•
http
:
//localhost
ou
http
:
//127.0.0.1
Les
deux
adresses
ci-dessus
représentant
votre
machine
locale
.
Editer
votre
site
Pour
créer
votre
site
web
dynamique
avec
EasyPHP
,
il
vous
suffit
de
déposer
vos
créations
dans
le
sousrépertoire
/www
de
EasyPHP
.
Par
exemple
créez
un
fichier
texte
contenant
le
texte
suivant
:
<
?
phpinfo
(
)
;
?
>
Puis
renommez
ce
fichier
en
phpinfo.php3
et
déposez-le
dans
le
sous-répertoire
/www
.
Vous
pouvez
désormais
visualiser
le
résultat
à
l'adresse
suivante
:
http
:
//localhost/phpinfo.php3
Plus
d'informations
Pour
plus
d'informations
ou
en
cas
de
problème
avec
EasyPHP
,
allez
sur
EasyPHP.org
.
En
cas
de
problème
,
commencez
par
consulter
la
FAQ
,
puis
consultez
le
Forum
Concept
de
variable
avec
PHP
Une
variable
est
un
objet
repéré
par
son
nom
,
pouvant
contenir
des
données
,
qui
pourront
être
modifiées
lors
de
l'exécution
du
programme
.
Les
variables
en
langage
PHP
peuvent
être
de
trois
types
:
•
•
•
scalaires
tableaux
tableaux
associatifs
Quelque
soit
le
type
de
variable
,
son
nom
doit
obligatoirement
être
précédé
du
caractère
dollar
(
$
)
.
Contrairement
à
de
nombreux
langages
de
programmation
,
comme
le
langage
C
,
les
variables
en
PHP
n'ont
pas
besoin
d'être
déclarées
,
c'est-à-dire
que
l'on
peut
commencer
à
les
utiliser
sans
en
avoir
averti
l'interpréteur
précédemment
,
ainsi
si
la
variable
existait
précédemment
,
son
contenu
est
utilisé
,
sinon
l'interpréteur
lui
affectera
la
valeur
en
lui
assignant
0
par
défaut
.
De
cette
façon
si
vous
ajoutez
3
à
une
nouvelle
variable
(
non
définie
plus
haut
dans
le
code
)
,
sa
valeur
sera
3
...
Nommage
des
variables
Avec
PHP
,
les
noms
de
variables
doivent
répondre
à
certains
critères
:
•
un
nom
de
variable
doit
commencer
par
une
lettre
(
majuscule
ou
minuscule
)
ou
un
``
_
''
(
pas
par
un
chiffre
)
•
un
nom
de
variable
peut
comporter
des
lettres
,
des
chiffres
et
le
caractère
_
(
les
espaces
ne
sont
pas
autorisés
!
)
Nom
de
variable
correct
Nom
de
variable
incorrect
Raison
$
Variable
$
Nom
de
Variable
comporte
des
espaces
$
Nom_De_Variable
$
123Nom_De_Variable
commence
par
un
chiffre
$
nom_de_variable
$
toto
@
mailcity.com
caractère
spécial
@
$
nom_de_variable_123
$
Nom-de-variable
signe
-
interdit
$
nom_de_variable
nom_de_variable
ne
commence
pas
par
$
Les
noms
de
variables
sont
sensibles
à
la
casse
(
le
langage
PHP
fait
la
différence
entre
un
nom
en
majuscule
et
un
nom
en
minuscules
)
,
il
faut
donc
veiller
à
utiliser
des
noms
comportant
la
même
casse
!
Toutefois
,
les
noms
de
fonctions
font
exception
à
cette
règle
...
Variables
scalaires
Le
langage
PHP
propose
trois
types
de
variables
scalaires
:
•
•
entiers
:
nombres
naturels
sans
décimale
(
sans
virgule
)
réels
:
nombres
décimaux
(
on
parle
généralement
de
type
double
,
car
il
s'agit
de
nombre
décimaux
à
double
précision
)
•
chaines
de
caractères
:
ensembles
de
caractères
Il
n'est
pas
nécessaire
en
PHP
de
typer
les
variables
,
c'est-à-dire
de
définir
leur
type
,
il
suffit
de
leur
assigner
une
valeur
pour
en
définir
le
type
:
•
•
•
entiers
:
nombre
sans
virgule
réels
:
nombres
avec
une
virgule
(
en
réalité
un
point
)
chaines
de
caractères
:
ensembles
de
caractères
entre
guillemets
simples
ou
doubles
Instruction
Type
de
la
variable
$
Variable
=
0
;
type
entier
$
Variable
=
12
;
type
entier
$
Variable
=
0.0
;
type
réel
$
Variable
=
12.0
;
type
réel
$
Variable
=
``
0.0
''
;
type
chaîne
$
Variable
=
``
Bonjour
tout
le
monde
''
;
type
chaîne
Il
existe
des
caractères
repérés
par
un
code
ASCII
spécial
permettant
d'effectuer
des
opérations
particulières
.
Ces
caractères
peuvent
être
représentés
plus
simplement
en
langage
PHP
grâce
au
caractère
'\
'
suivi
d'une
lettre
,
qui
précise
qu'il
s'agit
d'un
caractère
de
contrôle
:
Caractère
Description
\
''
guillemet
\\
barre
oblique
inverse
(
antislash
)
\r
retour
chariot
\n
retour
à
la
ligne
\t
tabulation
En
effet
,
certains
de
ces
caractères
ne
pourraient
pas
être
représentés
autrement
(
un
retour
à
la
ligne
ne
peut
pas
être
représenté
à
l'écran
)
.
D'autre
part
,
les
caractères
\
et
``
ne
peuvent
pas
faire
partie
en
tant
que
tel
d'une
chaîne
de
caractère
,
pour
des
raisons
évidente
d'ambiguité
...
Variables
tableaux
Les
variables
,
telles
que
nous
les
avons
vues
,
ne
permettent
de
stocker
qu'une
seule
donnée
à
la
fois
.
Or
,
pour
de
nombreuses
données
,
comme
cela
est
souvent
le
cas
,
des
variables
distinctes
seraient
beaucoup
trop
lourdes
à
gérer
.
Heureusement
,
PHP
propose
des
structures
de
données
permettant
de
stocker
l'ensemble
de
ces
données
dans
une
``
variable
commune
''
.
Ainsi
,
pour
accéder
à
ces
valeurs
il
suffit
de
parcourir
la
variable
de
type
complexe
composée
de
«
variables
»
de
type
simple
.
Les
tableaux
stockent
des
données
sous
forme
de
liste
.
Les
données
contenues
dans
la
liste
sont
accessibles
grâce
à
un
index
(
un
numéro
représentant
l'élément
de
la
liste
)
.
Contrairement
à
des
langages
tels
que
le
langage
C
,
il
est
possible
de
stocker
des
éléments
de
types
différents
dans
un
même
tableau
.
Ainsi
,
pour
désigner
un
élément
de
tableau
,
il
suffit
de
faire
suivre
au
nom
du
tableau
l'indice
de
l'élément
entre
crochets
:
$
Tableau
[
0
]
=
12
;
$
Tableau
[
1
]
=
``
CCM
''
;
Avec
PHP
,
il
n'est
pas
nécessaire
de
préciser
la
valeur
de
l'index
lorsque
l'on
veut
remplir
un
tableau
,
car
il
assigne
la
valeur
0
au
premier
élément
(
si
le
tableau
est
vide
)
et
incrémente
les
indices
suivants
.
De
cette
façon
,
il
est
facile
de
remplir
un
tableau
avec
des
valeurs
.
Le
code
précédent
est
équivalent
à
:
$
Tableau
[
]
=
12
;
$
Tableau
[
]
=
``
CCM
''
;
•
•
Les
indices
de
tableau
commencent
à
zéro
tous
les
types
de
variables
peuvent
être
contenus
dans
un
tableau
Lorsqu'un
tableau
contient
d'autres
tableaux
,
on
parle
de
tableaux
multidimensionnels
.
Il
est
possible
de
créer
directement
des
tableaux
multidimensionnels
en
utilisant
plusieurs
paires
de
crochets
pour
les
index
(
autant
de
paires
de
crochets
que
la
dimension
voulue
)
.
Par
exemple
,
un
tableau
à
deux
dimensions
pourra
être
déclaré
comme
suit
:
$
Tableau
[
0
]
[
0
]
$
Tableau
[
0
]
[
1
]
$
Tableau
[
1
]
[
0
]
$
Tableau
[
1
]
[
1
]
=
=
=
=
12
;
''
CCM
''
;
1245.652
;
''
Au
revoir
''
;
Variables
tableaux
associatifs
PHP
permet
l'utilisation
de
chaînes
de
caractères
au
lieu
de
simples
entiers
pour
définir
les
indices
d'un
tableau
,
on
parle
alors
de
tableaux
associatifs
.
Cette
façon
de
nommer
les
indices
peut
parfois
être
plus
agréable
à
utiliser
:
$
Toto
[
``
Age
''
]
=
12
;
$
Toto
[
``
Adresse
''
]
=
``
22
rue
des
bois
fleuris
''
;
$
Toto
[
``
Nom
''
]
=
``
Ah
,
vous
auriez
bien
aimé
connaître
le
nom
de
famille
de
Toto
...
''
;
Portée
(
visibilité
)
des
variables
Selon
l'endroit
où
on
déclare
une
variable
,
celle-ci
pourra
être
accessible
(
visible
)
de
partout
dans
le
code
ou
bien
que
dans
une
portion
confinée
de
celui-ci
(
à
l'intérieur
d'une
fonction
par
exemple
)
,
on
parle
de
portée
(
ou
visibilité
)
d'une
variable
.
Lorsqu'une
variable
est
déclarée
dans
le
code
même
,
c'est-à-dire
à
l'extérieur
de
toute
fonction
ou
de
tout
bloc
d'instructions
,
elle
est
accessible
de
partout
dans
le
code
(
n'importe
quelle
fonction
du
programme
peut
faire
appel
à
cette
variable
)
.
On
parle
alors
de
variable
globale
Lorsque
l'on
déclare
une
variable
à
l'intérieur
d'un
bloc
d'instructions
(
entre
des
accolades
)
,
sa
portée
se
confine
à
l'intérieur
du
bloc
dans
lequel
elle
est
déclarée
.
•
Une
variable
déclarée
au
début
du
code
,
c'est-à-dire
avant
tout
bloc
de
donnée
,
sera
globale
,
on
pourra
alors
les
utiliser
à
partir
de
n'importe
quel
bloc
d'instructions
•
Une
variable
déclarée
à
l'intérieur
d'un
bloc
d'instructions
(
dans
une
fonction
ou
une
boucle
par
exemple
)
aura
une
portée
limitée
à
ce
seul
bloc
d'instructions
,
c'est-à-dire
qu'elle
est
inutilisable
ailleurs
,
on
parle
alors
de
variable
locale
D'une
manière
générale
il
est
préférable
de
donner
des
noms
différents
aux
variables
locales
et
globales
pour
des
raisons
de
lisibilité
et
de
compréhension
du
code
.
Définition
de
constantes
Une
constante
est
une
variable
dont
la
valeur
est
inchangeable
lors
de
l'exécution
d'un
programme
.
Avec
PHP
,
les
constantes
sont
définies
grâce
à
la
fonction
define
(
)
.
la
syntaxe
de
la
fonction
define
(
)
est
la
suivante
:
define
(
``
Nom_de_la_variable
''
,
Valeur
)
;
Le
nom
d'une
constante
définie
à
l'aide
de
la
fonction
define
(
)
ne
doit
pas
commencer
par
le
caractère
$
(
de
cette
façon
aucune
affectation
n'est
possible
)
.
Qu'est-ce
qu'un
opérateur
?
Les
opérateurs
sont
des
symboles
qui
permettent
de
manipuler
des
variables
,
c'est-à-dire
effectuer
des
opérations
,
les
évaluer
,
...
On
distingue
plusieurs
types
d'opérateurs
:
•
•
•
•
•
•
•
les
opérateurs
de
calcul
les
opérateurs
d'assignation
les
opérateurs
d'incrémentation
les
opérateurs
de
comparaison
les
opérateurs
logiques
(
les
opérateurs
bit-à-bit
)
(
les
opérateurs
de
rotation
de
bit
)
Les
opérateurs
de
calcul
Les
opérateurs
de
calcul
permettent
de
modifier
mathématiquement
la
valeur
d'une
variable
Opérateur
Dénomination
Effet
Résultat
(
pour
x=7
)
Exemple
+
opérateur
d'addition
Ajoute
deux
valeurs
$
x+3
10
-
opérateur
de
soustraction
Soustrait
deux
valeurs
$
x-3
4
*
opérateur
de
multiplication
Multiplie
deux
valeurs
$
x
*
3
21
/
plus
:
opérateur
de
division
Divise
deux
valeurs
$
x/3
2.3333333
=
opérateur
d'affectation
Affecte
une
valeur
à
une
variable
$
x=3
Met
la
valeur
3
dans
la
variable
$
x
%
opérateur
modulo
$
x
%
3
1
Donne
le
reste
de
la
division
entière
entre
2
nombres
Les
opérateurs
d'assignation
Ces
opérateurs
permettent
de
simplifier
des
opérations
telles
que
ajouter
une
valeur
dans
une
variable
et
stocker
le
résultat
dans
la
variable
.
Une
telle
opération
s'écrirait
habituellement
de
la
façon
suivante
par
exemple
:
$
x=
$
x+2
Avec
les
opérateurs
d'assignation
il
est
possible
d'écrire
cette
opération
sous
la
forme
suivante
:
$
x+=2
Ainsi
,
si
la
valeur
de
x
était
7
avant
opération
,
elle
sera
de
9
après
...
Les
autres
opérateurs
du
même
type
sont
les
suivants
:
Opérateur
Effet
+=
addition
deux
valeurs
et
stocke
le
résultat
dans
la
variable
(
à
gauche
)
-=
soustrait
deux
valeurs
et
stocke
le
résultat
dans
la
variable
*
=
multiplie
deux
valeurs
et
stocke
le
résultat
dans
la
variable
/=
divise
deux
valeurs
et
stocke
le
résultat
dans
la
variable
%
=
donne
le
reste
de
la
division
deux
valeurs
et
stocke
le
résultat
dans
la
variable
|=
Effectue
un
OU
logique
entre
deux
valeurs
et
stocke
le
résultat
dans
la
variable
^=
Effectue
un
OU
exclusif
entre
deux
valeurs
et
stocke
le
résultat
dans
la
variable
&
=
Effectue
un
Et
logique
entre
deux
valeurs
et
stocke
le
résultat
dans
la
variable
.=
Concatène
deux
chaînes
et
stocke
le
résultat
dans
la
variable
Les
opérateurs
d'incrémentation
Ce
type
d'opérateur
permet
de
facilement
augmenter
ou
diminuer
d'une
unité
une
variable
.
Ces
opérateurs
sont
très
utiles
pour
des
structures
telles
que
des
boucles
,
qui
ont
besoin
d'un
compteur
(
variable
qui
augmente
de
un
en
un
)
.
Un
opérateur
de
type
$
x++
permet
de
remplacer
des
notations
lourdes
telles
que
$
x=
$
x+1
ou
bien
$
x+=1
Opérateur
Dénomination
Effet
Syntaxe
Résultat
(
avec
x
valant
7
)
++
Incrémentation
Augmente
d'une
unité
la
variable
$
x++
8
--
Décrémentation
Diminue
d'une
unité
la
variable
6
$
x
--
Les
opérateurs
de
comparaison
Opérateur
Dénomination
==
A
ne
pas
confondre
avec
opérateur
d'égalité
le
signe
d'affectation
(
=
)
!
!
Effet
Compare
deux
valeurs
et
vérifie
leur
égalité
Exemple
$
x==3
Résultat
Retourne
1
si
$
x
est
égal
à
3
,
sinon
0
<
opérateur
d'infériorité
stricte
Vérifie
qu'une
variable
est
strictement
inférieure
à
$
x
<
3
une
valeur
Retourne
1
si
$
x
est
inférieur
à
3
,
sinon
0
<
=
opérateur
d'infériorité
Vérifie
qu'une
variable
est
inférieure
ou
égale
à
une
$
x
<
=3
valeur
Retourne
1
si
$
x
est
inférieur
ou
égale
à
3
,
sinon
0
>
opérateur
de
supériorité
stricte
Vérifie
qu'une
variable
est
strictement
supérieure
à
$
x
>
3
une
valeur
Retourne
1
si
$
x
est
supérieur
à
3
,
sinon
0
>
=
opérateur
de
supériorité
Vérifie
qu'une
variable
est
supérieure
ou
égale
à
une
$
x
>
=3
valeur
Retourne
1
si
$
x
est
supérieur
ou
égal
à
3
,
sinon
0
!
=
opérateur
de
différence
Vérifie
qu'une
variable
est
$
x
!
=3
différente
d'une
valeur
Retourne
1
si
$
x
est
différent
de
3
,
sinon
0
Les
opérateurs
logiques
(
booléens
)
Ce
type
d'opérateur
permet
de
vérifier
si
plusieurs
conditions
sont
vraies
:
Opérateur
Dénomination
Effet
Syntaxe
||
ou
OR
OU
logique
Vérifie
qu'une
des
conditions
est
réalisée
(
(
condition1
)
||
(
condition2
)
)
&
&
ou
AND
ET
logique
Vérifie
que
toutes
les
conditions
sont
réalisées
(
(
condition1
)
&
&
(
condition2
)
)
XOR
OU
exclusif
Vérifie
qu'une
et
une
seule
des
conditions
est
réalisée
(
(
condition1
)
XOR
(
condition2
)
)
!
NON
logique
Inverse
l'état
d'une
variable
booléenne
(
retourne
(
!
condition
)
la
valeur
1
si
la
variable
vaut
0
,
0
si
elle
vaut
1
)
(
Les
opérateurs
bit-à-bit
)
Si
vous
ne
comprenez
pas
ces
opérateurs
cela
n'est
pas
important
,
vous
n'en
aurez
probablement
pas
l'utilité
.
Pour
ceux
qui
voudraient
comprendre
,
rendez-
vous
aux
chapitres
suivants
:
•
•
•
compréhension
du
binaire
représentation
des
données
Instructions
arithmétiques
et
logiques
en
assembleur
Ce
type
d'opérateur
traite
ses
opérandes
comme
des
données
binaires
,
plutôt
que
des
données
décimales
,
hexadécimales
ou
octales
.
Ces
opérateurs
traitent
ces
données
selon
leur
représentation
binaire
mais
retournent
des
valeurs
numériques
standard
dans
leur
format
d'origine
.
Les
opérateurs
suivants
effectuent
des
opérations
bit-à-bit
,
c'est-à-dire
avec
des
bits
de
même
poids
.
Opérateur
Dénomination
&
ET
bit-à-bit
Effet
Retourne
1
si
les
deux
bits
de
même
poids
sont
à
1
Syntaxe
9
&
12
(
1001
&
1100
)
Résultat
8
(
1000
)
|
OU
bit-à-bit
Retourne
1
si
l'un
ou
l'autre
des
deux
bits
de
même
poids
est
à
1
(
ou
les
deux
)
9
|
12
(
1001
|
1100
)
13
(
1101
)
^
OU
exclusif
Retourne
1
si
l'un
des
deux
bits
de
même
poids
est
à
1
(
mais
pas
les
deux
)
9
^
12
(
1001
^
5
(
0101
)
1100
)
~
Complément
(
NON
)
Retourne
1
si
le
bit
est
à
0
(
et
inversement
)
~9
(
~1001
)
6
(
0110
)
(
Les
opérateurs
de
rotation
de
bit
)
Si
vous
ne
comprenez
pas
ces
opérateurs
cela
n'est
pas
important
,
vous
n'en
aurez
probablement
pas
l'utilité
.
Pour
ceux
qui
voudraient
comprendre
,
rendez-
vous
aux
chapitres
suivants
:
•
•
•
compréhension
du
binaire
représentation
des
données
Instructions
arithmétiques
et
logiques
en
assembleur
Ce
type
d'opérateur
traite
ses
opérandes
comme
des
données
binaires
d'une
longueur
de
32
bits
,
plutôt
que
des
données
décimales
,
hexadécimales
ou
octales
.
Ces
opérateurs
traitent
ces
données
selon
leur
représentation
binaire
mais
retournent
des
valeurs
numériques
standards
dans
leur
format
d'origine
.
Les
opérateurs
suivants
effectuent
des
rotations
sur
les
bits
,
c'est-à-dire
qu'il
décale
chacun
des
bits
d'un
nombre
de
bits
vers
la
gauche
ou
vers
la
droite
.
La
première
opérande
désigne
la
donnée
sur
laquelle
on
va
faire
le
décalage
,
la
seconde
désigne
le
nombre
de
bits
duquel
elle
va
être
décalée
.
Opérateur
Dénomination
Effet
Syntaxe
Décale
les
bits
vers
la
gauche
(
multiplie
par
2
à
chaque
décalage
)
.
Les
zéros
qui
sortent
à
gauche
sont
perdus
,
tandis
que
des
zéros
sont
insérés
à
droite
<
<
Rotation
à
gauche
>
>
Décale
les
bits
vers
la
droite
(
divise
par
2
à
Rotation
à
droite
avec
chaque
décalage
)
.
Les
zéros
qui
sortent
à
droite
conservation
du
signe
sont
perdus
,
tandis
que
le
bit
non-nul
de
poids
plus
fort
est
recopié
à
gauche
Résultat
6
<
<
1
12
(
110
<
<
1
)
(
1100
)
6
>
>
1
(
0110
>
>
1
)
3
(
0011
)
Autres
opérateurs
Les
opérateurs
ne
peuvent
pas
être
classés
dans
une
catégorie
spécifique
mais
ils
ont
tout
de
même
chacun
leur
importance
!
Opérateur
Dénomination
Effet
Syntaxe
.
Concaténation
Joint
deux
chaînes
bout
à
bout
''
Bonjour
''
.
``
Au
revoir
''
$
Référencement
de
variable
Permet
de
définir
une
variable
$
MaVariable
=
2
;
-
>
Propriété
d'un
objet
Permet
d'accéder
aux
données
membres
d'une
classe
$
MonObjet
>
Propriete
Résultat
''
BonjourAu
revoir
''
Les
priorités
Lorsque
l'on
associe
plusieurs
opérateurs
,
il
faut
que
l'interprêteur
PHP
sache
dans
quel
ordre
les
traiter
,
voici
donc
dans
l'ordre
décroissant
les
priorités
de
tous
les
opérateurs
:
Priorité
des
opérateurs
+++++++++++++++
(
)
++++++++++++++
--
[
]
++
!
~
+++++++++++++
*
/
++++++++++++
+
-
+++++++++++
<
<
=
>
=
>
++++++++++
==
!
=
+++++++++
&
++++++++
^
+++++++
|
%
-
++++++
&
&
+++++
||
++++
?
:
+++
=
+=
-=
*
=
/=
%
=
<
<
=
>
>
=
>
>
>
=
&
=
^=
|=
++
AND
+
XOR
Qu'est-ce
qu'une
structure
conditionnelle
?
On
appelle
structure
conditionnelle
les
instructions
qui
permettent
de
tester
si
une
condition
est
vraie
ou
non
,
c'est-à-dire
si
la
valeur
de
son
expression
vaut
0
ou
1
(
le
PHP
associe
le
mot
clé
true
à
1
et
false
à
0
)
.
Ces
structures
conditionnelles
peuvent
être
associées
à
des
structures
qui
se
répètent
suivant
la
réalisation
de
la
condition
,
on
appelle
ces
structures
des
structures
de
boucle
La
notion
de
bloc
Une
expression
suivie
d'un
point-virgule
est
appelée
instruction
.
Par
exemple
a++
;
est
une
instruction
.
Lorsque
l'on
veut
regrouper
plusieurs
instructions
,
on
peut
créer
ce
que
l'on
appelle
un
bloc
,
c'est-à-dire
un
ensemble
d'instructions
(
suivies
respectivement
par
des
point-virgules
)
et
comprises
entre
les
accolades
{
et
}
.
Les
instructions
if
,
while
et
for
peuvent
par
exemple
être
suivies
d'un
bloc
d'instructions
à
exécuter
...
L'instruction
if
L'instruction
if
est
la
structure
de
test
la
plus
basique
,
on
la
retrouve
dans
tous
les
langages
(
avec
une
syntaxe
différente
...
)
.
Elle
permet
d'exécuter
une
série
d'instruction
si
jamais
une
condition
est
réalisée
.
La
syntaxe
de
cette
expression
est
la
suivante
:
if
(
condition
réalisée
)
{
liste
d'instructions
}
Remarques
:
•
•
la
condition
doit
être
entre
des
parenthèses
il
est
possible
de
définir
plusieurs
conditions
à
remplir
avec
les
opérateurs
ET
et
OU
(
&
&
et
||
)
par
exemple
l'instruction
suivante
teste
si
les
deux
conditions
sont
vraies
:
if
(
(
condition1
)
&
&
(
condition2
)
)
L'instruction
ci-dessous
exécutera
les
instructions
si
l'une
ou
l'autre
des
deux
conditions
est
vraie
:
if
(
(
condition1
)
||
(
condition2
)
)
•
s'il
n
'
y
a
qu'une
instruction
,
les
accolades
ne
sont
pas
nécessaires
...
L'instruction
if
...
else
L'instruction
if
dans
sa
forme
basique
ne
permet
de
tester
qu'une
condition
,
or
la
plupart
du
temps
on
aimerait
pouvoir
choisir
les
instructions
à
exécuter
en
cas
de
non
réalisation
de
la
condition
...
L'expression
if
...
else
permet
d'exécuter
une
autre
série
d'instruction
en
cas
de
non-réalisation
de
la
condition
.
La
syntaxe
de
cette
expression
est
la
suivante
:
if
(
condition
réalisée
)
{
liste
d'instructions
}
else
{
autre
série
d'instructions
}
L'instruction
if
...
elseif
...
else
L'instruction
if
...
else
ne
permet
de
tester
qu'une
condition
,
or
il
est
parfois
nécessaire
de
tester
plusieurs
conditions
de
façon
exclusive
,
c'est-à-dire
que
sur
toutes
les
conditions
une
seule
sera
réalisée
...
L'expression
if
...
elseif
...
else
permet
d'enchaîner
une
série
d'instructions
et
évite
d'avoir
à
imbriquer
des
instructions
if
.
La
syntaxe
de
cette
expression
est
la
suivante
:
if
(
condition
réalisée
)
{
liste
d'instructions
}
elseif
(
autre
condition
réalisée
)
{
autre
série
d'instructions
}
...
else
(
dernière
condition
réalisée
)
{
série
d'instructions
}
une
façon
plus
courte
de
faire
un
test
(
opérateur
ternaire
)
Il
est
possible
de
faire
un
test
avec
une
structure
beaucoup
moins
lourde
grâce
à
la
structure
suivante
,
appelée
opérateur
ternaire
:
(
condition
)
?
instruction
si
vrai
:
instruction
si
faux
Remarques
:
•
•
•
la
condition
doit
être
entre
des
parenthèses
Lorsque
la
condition
est
vraie
,
l'instruction
de
gauche
est
exécutée
Lorsque
la
condition
est
fausse
,
l'instruction
de
droite
est
exécutée
L'instruction
switch
L'instruction
switch
permet
de
faire
plusieurs
tests
de
valeurs
sur
le
contenu
d'une
même
variable
.
Ce
branchement
conditionnel
simplifie
beaucoup
le
test
de
plusieurs
valeurs
d'une
variable
,
car
cette
opération
aurait
été
compliquée
(
mais
possible
)
avec
des
if
imbriqués
.
Sa
syntaxe
est
la
suivante
:
switch
(
Variable
)
{
case
Valeur1
:
Liste
d'instructions
break
;
case
Valeur2
:
Liste
d'instructions
break
;
case
Valeurs
...
:
Liste
d'instructions
break
;
default
:
Liste
d'instructions
break
;
}
Les
parenthèses
qui
suivent
le
mot
clé
switch
indiquent
une
expression
dont
la
valeur
est
testée
successivement
par
chacun
des
case
.
Lorsque
l'expression
testée
est
égale
à
une
des
valeurs
suivant
un
case
,
la
liste
d'instructions
qui
suit
celui-ci
est
exécutée
.
Le
mot
clé
break
indique
la
sortie
de
la
structure
conditionnelle
.
Le
mot
clé
default
précède
la
liste
d'instructions
qui
sera
exécutée
si
l'expression
n'est
jamais
égale
à
une
des
valeurs
.
N'oubliez
pas
d'insérer
des
instructions
break
entre
chaque
test
,
ce
genre
d'oubli
est
difficile
à
détecter
car
aucune
erreur
n'est
signalée
...
Les
boucles
Les
boucles
sont
des
structures
qui
permettent
d'exécuter
plusieurs
fois
la
même
série
d'instructions
jusqu
'
à
ce
qu'une
condition
ne
soit
plus
réalisée
...
On
appelle
parfois
ces
structures
instructions
répétitives
ou
bien
itérations
.
La
façon
la
plus
commune
de
faire
une
boucle
,
est
de
créer
un
compteur
(
une
variable
qui
s'incrémente
,
c'est-à-dire
qui
augmente
de
1
à
chaque
tour
de
boucle
)
et
de
faire
arrêter
la
boucle
lorsque
le
compteur
dépasse
une
certaine
valeur
.
La
boucle
for
L'instruction
for
permet
d'exécuter
plusieurs
fois
la
même
série
d'instructions
:
c'est
une
boucle
!
Dans
sa
syntaxe
,
il
suffit
de
préciser
le
nom
de
la
variable
qui
sert
de
compteur
(
et
éventuellement
sa
valeur
de
départ
,
la
condition
sur
la
variable
pour
laquelle
la
boucle
s'arrête
(
basiquement
une
condition
qui
teste
si
la
valeur
du
compteur
dépasse
une
limite
)
et
enfin
une
instruction
qui
incrémente
(
ou
décrémente
)
le
compteur
.
La
syntaxe
de
cette
expression
est
la
suivante
:
for
(
compteur
;
condition
;
modification
du
compteur
)
{
liste
d'instructions
}
Par
exemple
:
for
(
$
i=1
;
$
i
<
6
;
$
i++
)
{
echo
``
$
i
<
br
>
''
;
}
Cette
boucle
affiche
5
fois
la
valeur
de
$
i
,
c'est-à-dire
1,2,3,4,5
Elle
commence
à
$
i=1
,
vérifie
que
$
i
est
bien
inférieur
à
6
,
etc
...
jusqu
'
à
atteindre
la
valeur
$
i=6
,
pour
laquelle
la
condition
ne
sera
plus
réalisée
,
la
boucle
s'interrompra
et
le
programme
continuera
son
cours
.
D'autre
part
,
le
langage
PHP
autorise
la
déclaration
de
la
variable
de
boucle
dans
l'instruction
for
elle-même
!
Par
exemple
:
for
(
$
i=0
;
$
i
<
10
;
$
i++
)
{
echo
``
$
i
<
br
>
''
;
}
•
il
faudra
toujours
vérifier
que
la
boucle
a
bien
une
condition
de
sortie
(
i.e
le
compteur
s'incrémente
correctement
)
•
une
instruction
echo
dans
votre
boucle
est
un
bon
moyen
pour
vérifier
la
valeur
du
compteur
pas
à
pas
en
l'affichant
!
•
il
faut
bien
compter
le
nombre
de
fois
que
l'on
veut
faire
exécuter
la
boucle
:
o
for
(
$
i=0
;
$
i
<
10
;
$
i++
)
exécute
10
fois
la
boucle
(
$
i
de
0
à
9
)
o
for
(
$
i=0
;
$
i
<
=10
;
$
i++
)
exécute
11
fois
la
boucle
(
$
i
de
0
à
10
)
o
for
(
$
i=1
;
$
i
<
10
;
$
i++
)
exécute
9
fois
la
boucle
(
$
i
de
1
à
9
)
o
for
(
$
i=1
;
$
i
<
=10
;
$
i++
)
exécute
10
fois
la
boucle
(
$
i
de
1
à
10
)
L'instruction
while
L'instruction
while
représente
un
autre
moyen
d'exécuter
plusieurs
fois
la
même
série
d'instructions
.
La
syntaxe
de
cette
expression
est
la
suivante
:
while
(
condition
réalisée
)
{
liste
d'instructions
}
Cette
instruction
exécute
la
liste
d'instructions
tant
que
(
while
est
un
mot
anglais
qui
signifie
tant
que
)
la
condition
est
réalisée
.
La
condition
de
sortie
pouvant
être
n'importe
quelle
structure
conditionnelle
,
les
risques
de
boucle
infinie
(
boucle
dont
la
condition
est
toujours
vraie
)
sont
grands
,
c'est-à-dire
qu'elle
risque
de
provoquer
un
plantage
du
navigateur
!
Saut
inconditionnel
Il
peut
être
nécessaire
de
faire
sauter
à
la
boucle
une
ou
plusieurs
valeurs
sans
pour
autant
mettre
fin
à
celle-ci
.
La
syntaxe
de
cette
expression
est
``
continue
;
''
(
cette
instruction
se
place
dans
une
boucle
!
)
,
on
l'associe
généralement
à
une
structure
conditionnelle
,
sinon
les
lignes
situées
entre
cette
instruction
et
la
fin
de
la
boucle
seraient
obsolètes
.
Exemple
:
Imaginons
que
l'on
veuille
imprimer
pour
$
x
allant
de
1
à
10
la
valeur
de
1/
(
$
x-7
)
...
il
est
évident
que
pour
$
x=7
il
y
aura
une
erreur
.
Heureusement
,
grâce
à
l'instruction
continue
il
est
possible
de
traiter
cette
valeur
à
part
puis
de
continuer
la
boucle
!
$
x=1
;
while
(
$
x
<
=10
)
{
if
(
$
x
==
7
)
{
echo
``
Division
par
zéro
!
``
;
continue
;
}
$
a
=
1/
(
$
x-7
)
;
echo
``
$
a
<
br
>
''
;
$
x++
;
}
Il
y
avait
une
erreur
dans
ce
programme
...
peut-être
ne
l'avez-vous
pas
vue
:
Lorsque
$
x
est
égal
à
7
,
le
compteur
ne
s'incrémente
plus
,
il
reste
constamment
à
la
valeur
7
,
il
aurait
fallu
écrire
:
$
x=1
;
while
(
$
x
<
=10
)
{
if
(
$
x
==
7
)
{
echo
``
division
par
0
''
;
$
x++
;
continue
;
}
$
a
=
1/
(
$
x-7
)
;
echo
``
$
a
<
br
>
''
;
$
x++
;
}
Arrêt
inconditionnel
A
l'inverse
,
il
peut
être
voulu
d'arrêter
prématurément
la
boucle
,
pour
une
autre
condition
que
celle
précisé
dans
l'en-tète
de
la
boucle
.
L'instruction
break
permet
d'arrêter
une
boucle
(
for
ou
bien
while
)
.
Il
s'agit
,
tout
comme
continue
,
de
l'associer
à
une
structure
conditionnelle
,
sans
laquelle
la
boucle
ne
ferait
jamais
plus
d'un
tour
!
Dans
l'exemple
de
tout
à
l'heure
,
par
exemple
si
l'on
ne
savait
pas
à
quel
moment
le
dénominateur
(
$
x-7
)
s'annule
(
bon
...
OK
...
pour
des
équations
plus
compliquées
par
exemple
)
il
serait
possible
de
faire
arrêter
la
boucle
en
cas
d'annulation
du
dénominateur
,
pour
éviter
une
division
par
zéro
!
for
(
$
x=1
;
$
x
<
=10
;
$
x++
)
{
$
a
=
$
x-7
;
if
(
$
a
==
0
)
{
echo
``
division
par
0
''
;
break
;
}
echo
``
1/
$
a
<
br
>
''
;
}
Arrêt
d'exécution
du
script
PHP
autorise
l'utilisation
de
la
commande
exit
,
qui
permet
d'interrompre
totalement
l'interprétation
du
script
,
ce
qui
signifie
que
le
serveur
n'envoie
plus
d'informations
au
navigateur
:
le
script
est
figé
dans
son
état
actuel
.
cette
instruction
est
particulièrement
utile
lors
de
l'apparition
d'erreur
La
notion
de
fonction
On
appelle
fonction
un
sous-programme
qui
permet
d'effectuer
un
ensemble
d'instructions
par
simple
appel
de
la
fonction
dans
le
corps
du
programme
principal
.
Les
fonctions
permettent
d'exécuter
dans
plusieurs
parties
du
programme
une
série
d'instructions
,
cela
permet
une
simplicité
du
code
et
donc
une
taille
de
programme
minimale
.
D'autre
part
,
une
fonction
peut
faire
appel
à
elle-même
,
on
parle
alors
de
fonction
récursive
(
il
ne
faut
pas
oublier
de
mettre
une
condition
de
sortie
au
risque
sinon
de
ne
pas
pouvoir
arrêter
le
programme
...
)
.
La
déclaration
d'une
fonction
PHP
recèle
de
nombreuses
fonctions
intégrées
permettant
d'effectuer
des
actions
courantes
.
Toutefois
,
il
est
possible
de
définir
des
fonctions
,
dites
fonctions
utilisateurs
afin
de
simplifier
l'exécution
de
séries
d'instructions
répétitives
.
Contrairement
à
de
nombreux
autres
langages
,
PHP
nécessite
que
l'on
définisse
une
fonction
avant
que
celle-ci
puisse
être
utilisée
,
car
pour
l'appeler
dans
le
corps
du
programme
il
faut
que
l'interpréteur
la
connaisse
,
c'est-à-dire
qu'il
connaisse
son
nom
,
ses
arguments
et
les
instructions
qu'elle
contient
.
La
définition
d'une
fonction
s'appelle
``
déclaration
''
et
peut
se
faire
n'importe
où
dans
le
code
.
La
déclaration
d'une
fonction
se
fait
grâce
au
mot-clé
function
,
selon
la
syntaxe
suivante
:
function
Nom_De_La_Fonction
(
argument1
,
argument2
,
...
)
{
liste
d'instructions
}
Remarques
:
•
le
nom
de
la
fonction
suit
les
mêmes
règles
que
les
noms
de
variables
:
o
le
nom
doit
commencer
par
une
lettre
o
un
nom
de
fonction
peut
comporter
des
lettres
,
des
chiffres
et
les
caractères
_
et
&
(
les
espaces
ne
sont
pas
autorisés
!
)
o
le
nom
de
la
fonction
,
comme
celui
des
variables
est
sensible
à
la
casse
(
différenciation
entre
les
minuscules
et
majuscules
)
•
Les
arguments
sont
facultatifs
,
mais
s'il
n
'
y
a
pas
d'arguments
,
les
parenthèses
doivent
rester
présentes
•
Il
ne
faut
pas
oublier
de
refermer
les
accolades
•
Le
nombre
d'accolades
ouvertes
(
fonction
,
boucles
et
autres
structures
)
doit
être
égal
au
nombre
d'accolades
fermées
!
•
La
même
chose
s'applique
pour
les
parenthèses
,
les
crochets
ou
les
guillemets
!
Une
fois
cette
étape
franchie
,
votre
fonction
ne
s'exécutera
pas
tant
que
l'on
ne
fait
pas
appel
à
elle
quelque
part
dans
la
page
!
Appel
de
fonction
Pour
exécuter
une
fonction
,
il
suffit
de
faire
appel
à
elle
en
écrivant
son
nom
(
une
fois
de
plus
en
respectant
la
casse
)
suivie
d'une
parenthèse
ouverte
(
éventuellement
des
arguments
)
puis
d'une
parenthèse
fermée
:
Nom_De_La_Fonction
(
)
;
Remarques
:
•
le
point
virgule
signifie
la
fin
d'une
instruction
et
permet
à
l'interpréteur
de
distinguer
les
différents
blocs
d'instructions
•
si
jamais
vous
avez
défini
des
arguments
dans
la
déclaration
de
la
fonction
,
il
faudra
veiller
à
les
inclure
lors
de
l'appel
de
la
fonction
(
le
même
nombre
d'arguments
séparés
par
des
virgules
!
)
Nom_De_La_Fonction
(
argument1
,
argument2
)
;
Renvoi
d'une
valeur
par
une
fonction
La
fonction
peut
renvoyer
une
valeur
(
et
donc
se
terminer
)
grâce
au
mot-clé
return
.
Lorsque
l'instruction
return
est
rencontrée
,
la
fonction
évalue
la
valeur
qui
la
suit
,
puis
la
renvoie
au
programme
appelant
(
programme
à
partir
duquel
la
fonction
a
été
appelée
)
.
Une
fonction
peut
contenir
plusieurs
instructions
return
,
ce
sera
toutefois
la
première
instruction
return
rencontrée
qui
provoquera
la
fin
de
la
fonction
et
le
renvoi
de
la
valeur
qui
la
suit
.
La
syntaxe
de
l'instruction
return
est
simple
:
return
valeur_ou_variable
;
Les
arguments
d'une
fonction
Il
est
possible
de
passer
des
arguments
à
une
fonction
,
c'est-à-dire
lui
fournir
une
valeur
ou
le
nom
d'une
variable
afin
que
la
fonction
puisse
effectuer
des
opérations
sur
ces
arguments
ou
bien
grâce
à
ces
arguments
.
Le
passage
d'arguments
à
une
fonction
se
fait
au
moyen
d'une
liste
d'arguments
(
séparés
par
des
virgules
)
entre
parenthèses
suivant
immédiatement
le
nom
de
la
fonction
.
Les
arguments
peuvent
être
de
simple
variables
,
mais
aussi
des
tableaux
ou
des
objets
.
A
noter
qu'il
est
possible
de
donner
une
valeur
par
défaut
à
ces
arguments
en
faisant
suivre
le
nom
de
la
variable
par
le
signe
``
=
''
puis
la
valeur
que
l'on
affecte
par
défaut
à
la
variable
.
Lorsque
vous
voulez
utiliser
un
argument
dans
le
corps
de
la
fonction
en
tant
que
variable
,
celui-ci
doit
être
précédé
par
le
signe
$
.
<
?
function
dire_texte
(
$
qui
,
$
texte
=
'Bonjour
'
)
{
if
(
empty
(
$
qui
)
)
{
//
$
qui
est
vide
,
on
retourne
faux
return
false
;
}
else
{
echo
``
$
texte
$
qui
''
;
//
on
affiche
le
texte
return
true
;
//
fonction
exécutée
avec
succès
}
}
?
>
Ainsi
cette
fonction
peut
être
appelée
de
deux
façons
différentes
:
<
?
//
Passage
des
deux
paramètres
dire_texte
(
``
cher
phpeur
''
,
``
Bienvenue
''
)
;
//
affiche
``
Bienvenue
cher
phpeur
''
//
Utilisation
de
la
valeur
par
défaut
du
deuxième
paramètre
dire_texte
(
``
cher
phpeur
''
)
;
//
affiche
``
Bonjour
cher
phpeur
''
?
>
Travailler
sur
des
variables
dans
les
fonctions
Lorsque
vous
manipulerez
des
variables
dans
des
fonctions
,
il
vous
arrivera
de
constater
que
vous
avez
beau
modifier
la
variable
dans
la
fonction
celle-ci
retrouve
sa
valeur
d'origine
dès
que
l'on
sort
de
la
fonction
...
Cela
est
du
à
la
portée
des
variables
,
c'est-à-dire
si
elles
ont
été
définies
comme
variables
globales
ou
locales
.
Il
existe
plusieurs
niveaux
de
définition
de
variables
:
•
Une
variable
précédée
du
mot
clé
global
sera
visible
dans
l'ensemble
du
code
,
c'est-à-dire
que
sa
portée
ne
sera
pas
limitée
à
la
fonction
seulement
.
Ainsi
,
toutes
les
fonctions
pourront
utiliser
et
modifier
cette
même
variable
•
Le
niveau
static
permet
de
définir
une
variable
locale
à
la
fonction
,
qui
persiste
durant
tout
le
temps
d'exécution
du
script
•
Par
défaut
,
la
variable
possède
le
niveau
local
,
c'est-à-dire
que
la
variable
ne
sera
modifiée
qu
'
à
l'intérieur
de
la
fonction
et
retrouvera
la
valeur
qu'elle
avait
juste
avant
l'appel
de
fonction
à
la
sortie
de
celle-ci
<
?
$
chaine
=
``
Nombre
de
camions
:
``
;
function
ajoute_camion
(
$
mode=
''
)
{
global
$
chaine
;
static
$
nb=0
;
$
nb++
;
//
on
incrémente
le
nombre
de
camions
if
(
$
mode
==
``
affiche
''
)
{
echo
$
chaine.
$
nb
;
//
on
affiche
le
nombre
de
camions
}
}
ajoute_camion
(
)
;
//
nb
==
ajoute_camion
(
)
;
//
nb
==
ajoute_camion
(
)
;
//
nb
==
ajoute_camion
(
``
affiche
''
)
;
?
>
1
2
3
//
affiche
Nombre
de
camions
:
4
Passage
de
paramètre
par
référence
Une
autre
méthode
pour
modifier
une
variable
consiste
à
la
faire
précéder
du
caractère
&
,
précisant
qu'il
s'agit
alors
d'un
alias
:
la
valeur
de
la
variable
est
modifiée
à
la
sortie
de
la
fonction
.
On
parle
alors
de
passage
par
référence
.
Dans
ce
cas
on
passe
la
référence
(
adresse
mémoire
)
de
la
variable
à
la
fonction
,
ce
qui
permet
de
modifier
sa
valeur
.
<
?
function
dire_texte
(
$
qui
,
&
$
texte
)
{
$
texte
=
``
Bienvenue
$
qui
''
;
}
$
chaine
=
``
Bonjour
``
;
dire_texte
(
``
cher
phpeur
''
,
$
chaine
)
;
echo
$
chaine
;
//
affiche
``
Bienvenue
cher
phpeur
''
?
>
Retourner
plusieurs
variables
Lorsque
vous
souhaitez
qu'une
fonction
retourne
plusieurs
valeurs
,
le
plus
simple
est
d'utiliser
un
tableau
.
<
?
function
nom_fonction
(
)
{
.....
return
array
(
$
variable1
,
$
variable2
,
$
variable3
)
;
//
on
retourne
les
valeurs
voulues
dans
un
tableau
}
$
retour
=
nom_fonction
(
)
;
echo
``
$
retour
[
0
]
-
$
retour
[
1
]
-
$
retour
[
2
]
''
;
?
>
La
récursivité
Les
fonctions
récursives
sont
des
fonctions
qui
s'appellent
elles-mêmes
.
Ce
type
de
fonction
se
révéle
indispensable
pour
parcourir
une
arborescence
par
exemple
.
Voici
un
exemple
simple
.
<
?
function
fonction_recursive
(
$
n=0
)
{
$
n++
;
echo
``
$
n
<
br
>
''
;
if
(
$
n
<
10
)
{
//
si
n
est
inférieur
à
10
on
continue
fonction_recursive
(
$
n
)
;
}
}
fonction_recursive
(
)
;
//
affiche
les
nb
de
1
à
10
?
>
La
notion
de
classe
Php3
intègre
un
soupçon
de
caractéristiques
empruntées
aux
langages
orientés
objet
,
c'est-à-dire
la
possibilité
d'utiliser
des
objets
,
entités
regroupant
des
données
et
des
fonctions
au
sein
d'une
structure
et
rendant
la
programmation
plus
simple
qu'en
programmation
habituelle
(
appelée
programmation
procédurale
par
opposition
à
la
programmation
orientée
objet
)
.
On
appelle
classe
la
structure
d'un
objet
,
c'est-à-dire
la
déclaration
de
l'ensemble
des
entités
qui
composeront
un
objet
.
Un
objet
est
donc
``
issu
''
d'une
classe
,
c'est
le
produit
qui
sort
d'un
moule
.
En
réalité
on
dit
qu'un
objet
est
une
instanciation
d'une
classe
,
c'est
la
raison
pour
laquelle
on
pourra
parler
indifféremment
d'objet
ou
d'instance
(
éventuellement
d'occurrence
)
.
Une
classe
est
composée
de
deux
parties
:
•
Les
attributs
(
parfois
appelés
données
membres
)
:
il
s'agit
des
données
représentant
l'état
de
l'objet
•
Les
méthodes
(
parfois
appelées
fonctions
membres
)
:
il
s'agit
des
opérations
applicables
aux
objets
déclaration
d'une
classe
Pour
pouvoir
manipuler
des
objets
,
il
est
essentiel
de
définir
des
classes
,
c'est-à-dire
définir
la
structure
d'un
objet
.
Avec
Php
,
cette
définition
se
fait
de
la
manière
suivante
:
class
Nom_de_la_classe
{
//
Déclarations
des
données
membres
var
$
Donnee_Membre_1
;
var
$
Donnee_Membre_2
;
var
$
...
//
Déclarations
des
méthodes
function
Nom_de_la_fonction_membre1
(
parametres
)
{
liste
d'instructions
;
}
}
Nom_de_la_classe
représente
bien
évidemment
le
type
d'objet
désigné
par
la
classe
ou
du
moins
le
nom
que
vous
leur
attribuez
.
Contrairement
aux
langages
orientés
objet
comme
le
C++
,
Php
n'inclut
pas
dans
sa
version
3
de
niveaux
de
visibilité
des
éléments
de
la
classe
,
il
n
'
y
a
donc
pas
de
concept
d'encapsulation
,
un
des
concepts
majeurs
de
la
programmation
orientée
objet
.
Contrairement
à
la
déclaration
de
classes
en
C++
,
la
déclaration
de
la
classe
ne
se
finit
pas
par
un
point-virgule
!
Instanciation
de
la
classe
Après
avoir
déclaré
une
classe
,
il
faut
instancier
des
objets
pour
pouvoir
l'exploiter
.
Cette
opération
se
fait
à
l'aide
du
mot
clé
new
permettant
de
faire
des
objets
découlant
d'une
classe
.
La
syntaxe
du
mot
clé
new
est
la
suivante
:
$
Nom_de_l_objet
=
new
Nom_de_la_classe
;
A
partir
du
moment
où
l'objet
est
instancié
,
il
possède
des
propriétés
qui
lui
sont
propres
,
cela
signifie
que
si
vous
instanciez
un
nouvel
objet
,
la
modification
des
propriétés
de
l'un
n'influera
aucunement
sur
celles
de
l'autre
.
Il
existe
une
méthode
spéciale
(
portant
le
même
nom
que
la
classe
)
s'exécutant
automatiquement
lors
de
l'instanciation
de
l'objet
.
Cette
méthode
,
appelée
constructeur
est
très
utile
pour
initialiser
les
données
membres
lors
de
l'instanciation
.
Accéder
aux
propriétés
d'un
objet
L'accès
aux
propriétés
d'un
objet
se
fait
grâce
au
nom
de
l'objet
,
suivi
d'une
flêche
(
-
>
)
représentée
par
un
moins
(
-
)
et
un
signe
supérieur
(
>
)
,
puis
du
nom
de
la
donnée
membre
(
sans
le
signe
$
)
.
Par
exemple
:
$
Nom_de_l_objet-
>
Nom_de_la_donnee_membre
=
Valeur
;
Accéder
aux
méthodes
d'un
objet
L'accès
aux
méthodes
d'un
objet
se
fait
comme
pour
l'accès
aux
propriétés
,
c'est-à-dire
par
le
nom
de
l'objet
,
suivi
d'une
flêche
et
du
nom
de
la
méthode
.
La
méthode
est
suivie
de
parenthèses
,
contenant
les
paramètres
,
si
il
y'en
a
.
L'accès
à
une
méthode
se
fait
donc
de
la
façon
suivante
:
$
Nom_de_l_objet-
>
Nom_de_la_fonction_membre
(
parametre1
,
parametre2
,
...
)
;
La
variable
courante
$
this
Le
mot
clé
$
this
permet
de
désigner
l'objet
dans
lequel
on
se
trouve
,
c'est-à-dire
que
lorsque
l'on
désire
faire
référence
dans
une
fonction
membre
à
l'objet
dans
lequel
elle
se
trouve
,
on
utilise
this
.
Grâce
à
cette
variable
spéciale
,
il
est
possible
dans
une
fonction
membre
de
faire
référence
aux
propriétés
situées
dans
le
même
objet
que
la
fonction
membre
.
Ainsi
,
lorsque
l'on
désire
accéder
à
une
propriété
d'un
objet
à
partir
d'une
méthode
du
même
objet
,
il
suffit
de
faire
précéder
le
nom
de
la
donnée
membre
par
$
this-
>
.
Par
exemple
:
class
Toto
{
var
$
age
;
var
$
sexe
;
var
$
adresse
;
function
DefineTotoAge
(
$
Age
)
{
$
this-
>
age
=
$
Age
;
}
}
$
toto_test
=
new
Toto
;
$
toto_test-
>
DefineTotoAge
(
10
)
;
echo
``
L'age
de
TOTO
:
``
.
$
toto_test-
>
age
.
``
<
br/
>
''
;
Les
limitations
de
l'utilisation
de
classes
avec
Php
PHP
,
dans
sa
version
3
,
reste
assez
limité
du
point
de
vue
de
la
programmation
objet
.
La
plupart
des
aspects
marquants
de
la
programmation
objet
ne
sont
pas
présents
dans
le
langage
:
•
•
•
l'encapsulation
l'héritage
le
polymorphisme
Le
but
de
PHP
est
de
permettre
la
création
de
pages
web
dynamiques
,
ainsi
son
but
premier
est
de
pouvoir
envoyer
des
données
au
navigateur
.
Les
trois
fonctions
standards
PHP
fournit
3
fonctions
permettant
d'envoyer
du
texte
au
navigateur
.
Ces
fonctions
ont
la
particularité
de
pouvoir
insérer
dans
les
données
envoyées
des
valeurs
variables
,
pouvant
être
fonction
d'une
valeur
récupérée
par
exemple
,
c'est
ce
qui
rend
possible
la
création
de
pages
dynamiques
.
Les
3
fonctions
sont
les
suivantes
:
•
•
•
echo
print
printf
La
fonction
echo
La
fonction
echo
permet
d'envoyer
au
navigateur
la
chaîne
de
caractères
(
délimitée
par
des
guillemets
)
qui
la
suit
.
La
syntaxe
de
cette
fonction
est
la
suivante
:
echo
Expression
;
L'expression
peut
être
une
chaîne
de
caractères
ou
une
expression
que
l'interpréteur
évalue
echo
``
Chaine
de
caracteres
''
;
echo
(
1+2
)
*
87
;
Ainsi
,
étant
donné
que
la
chaîne
de
caractères
est
délimitée
par
des
guillemets
,
l'insertion
de
guillemets
doubles
dans
la
chaîne
provoquerait
une
erreur
.
C'est
la
raison
pour
laquelle
les
guillemets
doubles
,
ainsi
que
tous
les
caractères
spéciaux
,
doivent
être
précédés
d'un
antislash
.
Voici
un
récapitulatif
des
caractères
spéciaux
nécessitant
l'ajout
d'un
antislash
:
Caractère
Description
<
TD\
''
<
td
>
<
TDGUILLEMET
<
td
>
<
TD\
$
<
td
>
<
TDCARACT
&
EGRAVE
;
RE
td
$
<
>
<
TD\\
<
td
>
<
inverse
oblique
>
<
TD\R
<
td
>
<
>
<
TD\N
<
td
>
<
la
à
>
<
TD\T
<
td
>
<
TDTABULATION
<
td
>
Le
caractère
$
a
un
rôle
particulier
dans
la
mesure
où
l'interpréteur
le
comprend
comme
une
variable
,
ce
qui
signifie
que
lorsque
le
caractère
$
est
rencontré
dans
la
chaîne
qui
suit
la
fonction
echo
,
l'interpréteur
récupère
le
nom
de
la
variable
qui
suit
le
caractère
$
et
le
remplace
par
sa
valeur
.
Dans
l'exemple
suivant
par
exemple
,
on
assigne
la
date
actuelle
à
une
variable
appelée
$
MaDate
,
puis
on
l'affiche
sur
le
navigateur
:
<
HTML
>
<
HEAD
>
<
TITLE
>
Affichage
de
l'heure
<
/TITLE
>
<
/HEAD
>
<
BODY
>
<
?
//
Récupération
de
la
date
//
et
stockage
dans
une
variable
$
MaDate
=
date
(
``
Y
''
)
;
echo
``
Nous
sommes
en
$
MaDate
''
;
?
>
<
/BODY
>
<
/HTML
>
La
fonction
print
La
fonction
print
est
similaire
à
la
fonction
echo
à
la
différence
près
que
l'expression
à
afficher
est
entre
parenthèses
.
La
syntaxe
de
la
fonction
print
est
la
suivante
:
print
(
expression
)
;
L'expression
peut
,
comme
pour
la
fonction
echo
être
une
chaîne
de
caractères
ou
une
expression
que
l'interpréteur
évalue
:
print
(
``
Chaine
de
caracteres
''
)
;
print
(
(
1+2
)
*
87
)
;
La
fonction
printf
La
fonction
printf
(
)
(
empruntée
au
langage
C
)
est
rarement
utilisée
car
sa
syntaxe
est
plus
lourde
.
Toutefois
,
contrairement
aux
deux
fonctions
précédentes
,
elle
permet
un
formatage
des
données
,
cela
signifie
que
l'on
peut
choisir
le
format
dans
lequel
une
variable
sera
affichée
à
l'écran
.
La
syntaxe
de
printf
(
)
est
la
suivante
:
printf
(
chaîne
formattée
)
;
Une
chaîne
formattée
est
une
chaîne
contenant
des
codes
spéciaux
permettant
de
repérer
l'emplacement
d'une
valeur
à
insérer
et
son
format
,
c'est-à-dire
sa
représentation
.
A
chaque
code
rencontré
doit
être
associé
une
valeur
ou
une
variable
,
que
l'on
retrouve
en
paramètre
à
la
fin
de
la
fonction
printf
.
Les
valeurs
à
insérer
dans
la
chaîne
formattées
sont
séparées
par
des
virgules
et
doivent
apparaître
dans
l'ordre
où
les
codes
apparaissent
dans
la
chaîne
formattée
Les
codes
de
formatage
des
types
de
données
sont
les
suivants
:
Code
Type
de
format
%
b
Entier
en
notation
binaire
%
c
Caractère
codé
par
son
code
ASCII
%
d
Entier
en
notation
décimale
%
e
Type
double
(
nombre
à
virgule
)
au
format
scientifique
(
1.76e+3
)
%
f
Type
double
(
nombre
à
virgule
)
%
o
Entier
en
notation
octale
%
s
Chaîne
de
caractères
%
x
Entier
en
notation
hexadécimale
(
lettres
en
minuscules
)
%
X
Entier
en
notation
hexadécimale
(
lettres
en
majuscules
)
%
%
Caractère
%
Imaginons
que
l'on
définisse
une
variable
en
virgule
flottante
,
afin
d'obtenir
une
précision
de
calcul
plus
grande
qu'avec
un
entier
,
mais
qu'on
désire
l'afficher
en
tant
qu'entier
.
Dans
ce
cas
la
fonction
printf
prend
toute
son
importance
:
$
Pi
=
3.1415927
;
$
R
=
24.546
;
$
Perimetre
=
2
*
$
Pi
*
$
R
;
printf
(
``
Le
périmètre
du
cercle
est
%
d
''
,
$
Perimetre
)
;
L'importance
de
l'implantation
du
code
php
au
sein
du
code
HTML
Le
code
PHP
peut
être
implanté
au
sein
du
code
HTML
.
Cette
caractéristique
n'est
pas
à
négliger
car
le
fait
d'écrire
uniquement
du
code
PHP
là
où
il
est
nécessaire
rend
la
programmation
plus
simple
(
il
est
plus
simple
d'écrire
du
code
HTML
que
des
fonctions
echo
ou
print
,
dans
lesquelles
les
caractères
spéciaux
doivent
être
précédés
d'un
antislash
sous
peine
de
voir
des
erreurs
lors
de
l'exécution
)
.
L'exemple
le
plus
simple
concerne
les
pages
dynamiques
dont
l'en-tête
est
toujours
le
même
:
dans
ce
cas
,
le
code
PHP
peut
ne
commencer
qu
'
à
partir
de
la
balise
<
BODY
>
,
au
moment
où
la
page
peut
s'afficher
différemment
selon
une
variable
par
exemple
.
Mieux
,
il
est
possible
d'écrire
plusieurs
portions
de
script
en
PHP
,
séparées
par
du
code
HTML
statique
car
les
variables/fonctions
déclarées
dans
une
portion
de
script
seront
accessibles
dans
les
portions
de
scripts
inférieures
.
Notion
de
variable
d'environnement
Les
variables
d'environnement
sont
,
comme
leur
nom
l'indique
,
des
données
stockées
dans
des
variables
permettant
au
programme
d'avoir
des
informations
sur
son
environnement
.
L'environnement
,
dans
le
cas
du
script
PHP
est
:
•
•
Le
serveur
Le
client
Ces
variables
sont
créées
par
le
serveur
à
chaque
fois
que
le
script
PHP
est
appelé
,
le
serveur
les
lui
fournit
en
paramètres
cachés
lors
de
l'exécution
de
l'interpréteur
.
Elles
permettent
notamment
d'avoir
des
informations
sur
le
type
de
serveur
,
son
administrateur
,
la
date
à
laquelle
le
script
a
été
appelé
,
l'adresse
IP
et
le
type
de
navigateur
du
client
,
...
Les
variables
d'environnement
On
peut
donc
classer
les
variables
d'environnement
en
deux
catégories
:
•
•
Les
variables
d'environnement
dépendant
du
client
Les
variables
d'environnement
dépendant
du
serveur
Les
variables
d'environnement
dépendant
du
client
Variable
d'environnement
Description
$
AUTH_TYPE
Il
s'agit
de
la
méthode
d'authentification
qui
a
été
utilisée
par
le
client
pour
accéder
au
script
PHP
$
COMSPEC
Location
de
l'interpréteur
de
commandes
sur
la
machine
(
Sous
Windows
)
$
CONTENT_TYPE
Type
de
données
contenu
présent
dans
le
corps
de
la
requête
.
Il
s'agit
du
type
MIME
des
données
$
DOCUMENT_ROOT
Racine
des
documents
sur
le
serveur
$
DOCUMENT_URI
Adresse
du
script
PHP
en
relatif
(
à
partir
de
la
racine
du
serveur
)
$
HTTP_ACCEPT
Types
MIME
reconnus
par
le
serveur
(
séparés
par
des
virgules
)
$
HTTP_ACCEPT_ENCODING
Types
d'encodage
que
le
serveur
peut
réaliser
(
gzip
,
deflate
)
$
HTTP_ACCEPT_LANGUAGE
Langue
utilisée
par
le
serveur
(
par
défaut
en-us
)
$
HTTP_CONNECTION
Type
de
connexion
ouverte
entre
le
client
et
le
serveur
(
par
exemple
KeepAlive
)
$
HTTP_HOST
Nom
d'hôte
de
la
machine
du
client
(
associée
à
l'adresse
IP
)
$
HTTP_REFERER
URL
de
la
page
qui
a
appelé
le
script
PHP
Cette
variable
permet
d'avoir
des
informations
sur
le
type
de
navigateur
utilisé
par
le
client
,
ainsi
que
son
système
d'exploitation
.
Voici
quelques
exemples
de
User-Agents
:
$
HTTP_USER_AGENT
•
•
•
•
•
•
•
Mozilla/4.0
(
compatible
;
MSIE
5.01
;
Windows
NT
;
TUCOWS
Network
)
Mozilla/4.7
[
en
]
(
X11
;
I
;
Linux
2.2.14-15mdk
i686
)
$
LAST_MODIFIED
Date
et
heure
de
dernière
modification
du
fichier
$
PATH
Il
s'agit
du
chemin
d'accès
aux
différents
répertoires
sur
le
serveur
$
PATH_INFO
Il
s'agit
du
chemin
d'accès
au
script
PHP
en
relatif
(
de
la
racine
du
serveur
jusqu'au
script
PHP
)
$
PHP_SELF
Nom
du
script
PHP
$
REDIRECT_STATUS
Il
s'agit
de
l'état
de
la
redirection
(
echec
ou
succès
)
$
REDIRECT_URL
Il
s'agit
de
l'URL
vers
laquelle
le
navigateur
du
client
a
été
redirigé
$
QUERY_STRING
Il
s'agit
de
la
partie
de
l'URL
(
ayant
servi
à
accéder
au
script
PHP
)
située
après
le
point
d'interrogation
.
C'est
de
cette
manière
que
sont
transmises
les
données
d'un
formulaire
dans
le
cas
de
la
méthode
GET
$
REMOTE_ADDR
Cette
variable
contient
l'adresse
IP
du
client
appelant
le
script
CGI
$
REMOTE_PORT
Cette
variable
permet
de
savoir
le
port
sur
lequel
la
requête
HTTP
a
été
envoyée
au
serveur
Chemin
d'accès
complet
au
script
PHP
$
SCRIPT_FILENAME
$
SCRIPT_NAME
•
Sous
windows
,
il
sera
de
la
forme
:
c
:
/php/php.exe
Chemin
d'accès
relatif
(
par
rapport
au
chemin
d'accès
à
la
racine
web
(
$
DOCUMENT_ROOT
)
)
au
script
PHP
Les
variables
d'environnement
dépendant
du
serveur
Variable
d'environnement
Description
$
DATE_GMT
Date
actuelle
au
format
GMT
$
DATE_LOCAL
Date
actuelle
au
format
local
$
DOCUMENT_ROOT
Racine
des
documents
Web
sur
le
serveur
$
GATEWAY_INTERFACE
Version
des
spécifications
CGI
utilisées
par
le
serveur
$
HTTP_HOST
Nom
de
domaine
du
serveur
$
SERVER_ADDR
Adresse
IP
du
serveur
$
SERVER_ADMIN
Adresse
de
l'administrateur
du
serveur
$
SERVER_NAME
Nom
donné
au
serveur
en
local
$
SERVER_PORT
Numéro
de
port
associé
au
protocole
HTTP
sur
le
serveur
$
SERVER_PROTOCOL
Nom
et
version
du
protocole
utilisé
pour
envoyer
la
requête
au
script
PHP
Type
(
logiciel
)
du
serveur
web
$
SERVER_SOFTWARE
•
Pour
un
serveur
Apache
sous
Unix
:
Apache/1.3.2
(
Unix
)
PHP/3.0.5
•
Pour
un
serveur
Apache
sous
Windows
:
Apache/1.3.2
(
Win32
)
PHP/3.0.5
Affichage
des
variables
d'environnement
Il
est
possible
de
créer
un
script
permettant
de
visualiser
l'ensemble
des
variables
d'environnement
.
La
première
façon
consiste
à
utiliser
la
fonction
phpinfo
(
)
qui
affiche
toute
seule
un
tableau
récapitulatif
des
paramètres
du
serveur
et
de
l'intepréteur
PHP
,
ainsi
qu'un
tableau
des
variables
d'environnement
<
?
phpinfo
(
)
;
?
>
PHP
fournit
la
fonction
getenv
(
)
permettant
de
retourner
la
valeur
de
la
variable
d'environnement
passée
en
paramètre
:
<
?
echo
getenv
(
``
HTTP_USER_AGENT
''
)
;
?
>
Enfin
il
est
possible
de
définir
des
variables
d'environnement
:
<
?
echo
putenv
(
``
MA_VARIABLE=mavaleur
La
gestion
des
fichiers
avec
PHP
Avec
PHP
,
la
création
ou
la
lecture
de
fichiers
est
,
une
fois
de
plus
,
assez
simple
.
Il
existe
une
multitude
de
fonctions
dédiées
à
l'utilisation
des
fichiers
.
La
communication
entre
le
script
PHP
et
le
fichier
est
repérée
par
une
variable
,
indiquant
l'état
du
fichier
et
que
l'on
peut
passer
en
paramètre
aux
fonctions
spécialisées
pour
le
manipuler
.
La
fonction
fopen
(
)
La
fonction
de
base
est
la
fonction
fopen
(
)
.
C'est
elle
qui
permet
d'ouvrir
un
fichier
,
que
ce
soit
pour
le
lire
,
le
créer
,
ou
y
écrire
.
Voilà
sa
syntaxe
:
entier
fopen
(
chaine
nomdufichier
,
chaine
mode
)
;
Le
mode
indique
le
type
d'opération
qu'il
sera
possible
d'effectuer
sur
le
fichier
après
ouverture
.
Il
s'agit
d'une
lettre
(
en
réalité
une
chaîne
de
caractères
)
indiquant
l'opération
possible
:
•
•
r
(
comme
read
)
indique
une
ouverture
en
lecture
seulement
w
(
comme
write
)
indique
une
ouverture
en
écriture
seulement
(
la
fonction
crée
le
fichier
s'il
n'existe
pas
)
•
a
(
comme
append
)
indique
une
ouverture
en
écriture
seulement
avec
ajout
du
contenu
à
la
fin
du
fichier
(
la
fonction
crée
le
fichier
s'il
n'existe
pas
)
Lorsque
le
mode
est
suivi
du
caractère
+
celui-ci
peut
être
lu
et
écrit
.
Enfin
,
le
fait
de
faire
suivre
le
mode
par
la
lettre
b
entre
crochets
indique
que
le
fichier
est
traité
de
façon
binaire
.
Voici
un
tableau
récapitulant
l'ensemble
des
modes
de
fichiers
possibles
:
Mode
Description
r
ouverture
en
lecture
seulement
w
ouverture
en
écriture
seulement
(
la
fonction
crée
le
fichier
s'il
n'existe
pas
)
a
ouverture
en
écriture
seulement
avec
ajout
du
contenu
à
la
fin
du
fichier
(
la
fonction
crée
le
fichier
s'il
n'existe
pas
)
r+
ouverture
en
lecture
et
écriture
w+
ouverture
en
lecture
et
écriture
(
la
fonction
crée
le
fichier
s'il
n'existe
pas
)
a+
ouverture
en
lecture
et
écriture
avec
ajout
du
contenu
à
la
fin
du
fichier
(
la
fonction
crée
le
fichier
s'il
n'existe
pas
)
Voici
des
exemples
d'utilisations
possibles
de
cette
fonction
:
$
fp
=
fopen
(
``
..
/fichier.txt
''
,
''
r
''
)
;
//lecture
//écriture
depuis
début
du
fichier
$
fp
=
fopen
(
``
ftp
:
//phpfrance.com/pub/fichier.txt
''
,
''
w
''
)
;
//écriture
depuis
fin
du
fichier
$
fp
=
fopen
(
``
http
:
//igalaxie.com/fichier.txt
''
,
''
a
''
)
;
De
plus
,
la
fonction
fopen
permet
d'ouvrir
des
fichiers
présents
sur
le
web
grâce
à
leur
URL
.
Voici
un
script
permettant
de
récupérer
le
contenu
d'une
page
d'un
site
web
:
<
?
$
fp
=
fopen
(
``
http
:
//www.commentcamarche.net
''
,
''
r
''
)
;
//lecture
du
fichier
while
(
!
feof
(
$
fp
)
)
{
//on
parcourt
toutes
les
lignes
$
page
.=
fgets
(
$
fp
,
4096
)
;
//
lecture
du
contenu
de
la
ligne
}
?
>
Il
est
généralement
utile
de
tester
si
l'ouverture
de
fichier
s'est
bien
déroulée
ainsi
que
d'éventuellement
stopper
le
script
PHP
si
cela
n'est
pas
le
cas
:
<
?
if
(
!
$
fp
=
fopen
(
``
http
:
//www.commentcamarche.net
''
,
''
r
''
)
)
{
echo
``
Echec
de
l'ouverture
du
fichier
''
;
exit
;
}
else
{
//
votre
code
;
}
?
>
Un
fichier
ouvert
avec
la
fonction
fopen
(
)
doit
être
fermé
,
à
la
fin
de
son
utilisation
,
par
la
fonction
fclose
(
)
en
lui
passant
en
paramètre
l'entier
retourné
par
la
fonction
fopen
(
)
Lecture
et
écriture
Une
fois
que
le
fichier
a
été
ouvert
avec
le
mode
désiré
,
il
est
possible
de
lire
son
contenu
et
d
'
y
écrire
des
informations
grâce
aux
fonctions
:
•
fputs
(
)
(
aussi
parfois
appelée
fwrite
(
)
,
les
deux
noms
sont
équivalents
,
on
parle
d'alias
)
permettant
d'écrire
une
chaîne
de
caractères
dans
le
fichier
entier
fputs
(
entier
Etat_du_fichier
,
chaine
Sortie
)
;
La
fonction
fputs
(
)
renvoie
le
nombre
de
caractères
effectivement
écrits
dans
le
fichier
•
fgets
(
)
permettant
de
récupérer
une
ligne
du
fichier
chaîne
fgets
(
entier
Etat_du_fichier
,
entier
Longueur
)
;
Le
paramètre
Longueur
désigne
le
nombre
de
caractères
maximum
que
la
fonction
est
sensée
récupérer
sur
la
ligne
.
La
fonction
fgets
(
)
renvoie
0
en
cas
d'échec
,
la
chaîne
dans
le
cas
contraire
Etant
donné
que
la
fonction
fgets
(
)
récupère
à
chaque
appel
une
nouvelle
ligne
du
fichier
,
il
est
essentiel
,
pour
récupérer
l'intégralité
du
contenu
d'un
fichier
de
l'insérer
dans
une
boucle
while
.
Ainsi
,
on
utilise
la
fonction
feof
(
)
,
fonction
testant
si
la
fin
du
fichier
n
'
a
pas
été
atteinte
,
en
tant
que
test
de
la
boucle
while
.
De
cette
façon
,
tant
que
la
fin
du
fichier
n
'
a
pas
été
atteinte
,
on
lit
la
ligne
suivante
du
fichier
...
<
?
if
(
!
$
fp
=
fopen
(
``
fichier.txt
''
,
''
r
''
)
)
{
echo
``
Echec
de
l'ouverture
du
fichier
''
;
exit
;
}
else
{
while
(
!
feof
(
$
fp
)
)
{
//
On
récupère
une
ligne
$
Ligne
=
fgets
(
$
fp,255
)
;
//
On
affiche
la
ligne
echo
$
Ligne
;
//
On
stocke
l'ensemble
des
lignes
dans
une
variable
$
Fichier
.=
$
Ligne
;
}
fclose
(
$
fp
)
;
//
On
ferme
le
fichier
}
?
>
Pour
stocker
des
infos
dans
le
fichier
,
il
faut
dans
un
premier
temps
ouvrir
le
fichier
en
écriture
en
le
créant
si
il
n'existe
pas
.
On
a
donc
le
choix
entre
le
mode
'
w
'
et
le
mode
'
a
'
.
On
préférera
le
second
puisque
le
pointeur
se
trouve
en
fin
de
fichier
(
autrement
dit
on
écrit
à
la
suite
de
ce
qui
se
trouve
dans
le
fichier
au
lieu
d'écraser
le
contenu
existant
éventuellement
déjà
)
.
<
?
$
fp
=
fopen
(
``
php_8_fichier.txt
''
,
''
a
''
)
;
//
ouverture
du
fichier
en
écriture
fputs
(
$
fp
,
``
\n
''
)
;
//
on
va
a
la
ligne
fputs
(
$
fp
,
``
$
nom|
$
email
''
)
;
//
on
écrit
le
nom
et
email
dans
le
fichier
fclose
(
$
fp
)
;
?
>
Voici
un
petit
script
permettant
de
récupérer
le
titre
d'une
page
Web
(
le
texte
compris
entre
les
balises
<
TITLE
>
et
<
/TITLE
>
)
.
Il
utilise
les
expressions
régulières
pour
localiser
le
texte
.
<
?
$
fp
=
fopen
(
``
http
:
//www.commentcamarche.net
''
,
''
r
''
)
;
//lecture
du
fichier
while
(
!
feof
(
$
fp
)
)
{
//on
parcourt
toutes
les
lignes
$
page
.=
fgets
(
$
fp
,
4096
)
;
//
lecture
du
contenu
de
la
ligne
}
$
titre
=
eregi
(
``
<
title
>
(
.
*
)
<
/title
>
''
,
$
page
,
$
regs
)
;
//on
isole
le
titre
echo
$
regs
[
1
]
;
fclose
(
$
fp
)
;
?
>
Les
tests
de
fichiers
PHP
fournit
de
nombreuses
fonctions
permettant
de
faire
des
tests
sur
les
fichiers
pour
connaître
leurs
propriétés
.
Voici
la
liste
des
fonctions
des
tests
:
•
is_dir
(
)
permet
de
savoir
si
le
fichier
dont
le
nom
est
passé
en
paramètre
correspond
à
un
répertoire
booléen
is_dir
(
chaine
Nom_du_fichier
)
;
La
fonction
is_dir
(
)
renvoie
1
si
il
s'agit
d'un
répertoire
,
0
dans
le
cas
contraire
<
?
if
(
!
is_dir
(
``
install
''
)
)
{
echo
``
Il
ne
s'agit
pas
d'un
répertoire
''
;
}
else
{
echo
``
Il
s'agit
bien
d'un
répertoire
''
;
}
?
>
•
is_executable
(
)
permet
de
savoir
si
le
fichier
dont
le
nom
est
passé
en
paramètre
est
exécutable
booléen
is_executable
(
chaine
Nom_du_fichier
)
;
La
fonction
is_executable
(
)
renvoie
1
si
le
fichier
est
exécutable
,
0
dans
le
cas
contraire
•
is_file
(
)
permet
de
savoir
si
le
fichier
dont
le
nom
est
passé
en
paramètre
ne
correspond
ni
à
un
répertoire
,
ni
à
un
lien
symbolique
booléen
is_file
(
chaine
Nom_du_fichier
)
;
La
fonction
is_file
(
)
renvoie
1
si
il
s'agit
d'un
fichier
,
0
dans
le
cas
contraire
•
is_link
(
)
permet
de
savoir
si
le
fichier
dont
le
nom
est
passé
en
paramètre
correpond
à
un
lien
symbolique
booléen
is_link
(
chaine
Nom_du_fichier
)
;
La
fonction
is_link
(
)
renvoie
1
si
il
s'agit
d'un
lien
symbolique
,
0
dans
le
cas
contraire
D'autres
façons
de
lire
et
écrire
Dans
certains
cas
,
il
peut
être
rébarbatif
de
devoir
mettre
en
oeuvre
les
fonctions
fopen
(
)
et
fgets
pour
lire
l'intégralité
du
contenu
d'un
fichier
.
Pour
cette
raison
PHP
fournit
des
fonctions
supplémentaires
permettant
de
faire
directement
certaines
opérations
.
La
fonction
file
(
)
permet
de
retourner
dans
un
tableau
l'intégralité
d'un
fichier
en
mettant
chacune
de
ces
lignes
dans
un
élément
du
tableau
(
rappel
:
le
premier
élément
d'un
tableau
est
repéré
par
l'indice
0
)
.
Voilà
sa
syntaxe
:
Tableau
file
(
chaine
nomdufichier
)
;
L'exemple
suivant
montre
comment
parcourir
l'ensemble
du
tableau
afin
d'afficher
le
fichier
.
<
?
$
Fichier
=
``
fichier.txt
''
;
if
(
is_file
(
$
Fichier
)
)
{
if
(
$
TabFich
=
file
(
$
Fichier
)
)
{
for
(
$
i
=
0
;
$
i
<
count
(
$
TabFich
)
;
$
i++
)
echo
$
TabFich
[
$
i
]
;
}
else
{
echo
``
Le
fichier
ne
peut
être
lu
...
<
br
>
''
;
}
}
else
{
echo
``
Désolé
le
fichier
n'est
pas
valide
<
br
>
''
;
}
?
>
La
fonction
fpassthru
(
)
permet
d'envoyer
le
contenu
du
fichier
dans
la
fenêtre
du
navigateur
.
La
syntaxe
de
cette
fonction
est
la
suivante
:
booléen
fpassthru
(
entier
etat
)
;
Cette
fonction
permet
en
réalité
d'envoyer
le
contenu
du
fichier
à
partir
de
la
position
courante
dans
le
fichier
,
c'est-à-dire
qu'il
est
possible
par
exemple
de
lire
quelques
lignes
avec
fgets
(
)
,
puis
d'envoyer
le
reste
au
navigateur
...
Le
script
suivant
permet
de
parcourir
tous
les
fichiers
HTML
contenus
dans
votre
site
et
d'en
afficher
l'arborescence
:
<
HTML
>
<
HEAD
>
<
TITLE
>
Affichage
de
l'arborescence
<
/TITLE
>
<
/HEAD
>
<
BODY
>
<
?
function
ScanDir
(
$
Directory
)
{
if
(
is_dir
(
$
Directory
)
&
&
is_readable
(
$
Directory
)
)
{
if
(
$
MyDirectory
=
opendir
(
$
Directory
)
)
{
while
(
$
Entry
=
readdir
(
$
MyDirectory
)
)
{
if
(
is_dir
(
$
Directory
.
``
/
''
.
$
Entry
)
)
{
if
(
(
$
Entry
!
=
``
.
''
)
&
&
(
$
Entry
!
=
``
..
''
)
)
{
echo
``
<
li
>
<
b
>
Repertoire
<
/b
>
:
$
Directory/
$
Entry
<
/li
>
\n
''
;
echo
``
<
ul
>
''
;
ScanDir
(
$
Directory
.
``
/
''
.
$
Entry
)
;
echo
``
<
/ul
>
''
;
}
}
else
{
echo
``
<
li
>
<
b
>
Fichier
<
/b
>
:
$
Directory/
$
Entry
<
/li
>
\n
''
;
if
(
eregi
(
``
(
\.html
)
|
(
\.htm
)
''
,
$
Entry
)
)
{
$
MetaTags
=
get_meta_tags
(
$
Directory
.
``
/
''
.
$
Entry
)
;
}
}
}
closedir
(
$
MyDirectory
)
;
}
}
}
$
open_basedir=
''
.
``
;
echo
``
<
ul
>
''
;
ScanDir
(
``
.
``
)
;
echo
``
<
/ul
>
''
;
?
>
<
/BODY
>
<
/HTML
>
